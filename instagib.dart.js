// Generated by dart2js, the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart() {
  this.x = 0;
  delete this.x;
}
var A = new dart;
var B = new dart;
var C = new dart;
var D = new dart;
var E = new dart;
var F = new dart;
var G = new dart;
var H = new dart;
var J = new dart;
var K = new dart;
var L = new dart;
var M = new dart;
var N = new dart;
var O = new dart;
var P = new dart;
var Q = new dart;
var R = new dart;
var S = new dart;
var T = new dart;
var U = new dart;
var V = new dart;
var W = new dart;
var X = new dart;
var Y = new dart;
var Z = new dart;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = Object.create(null);

// Native classes
(function(reflectionData) {
  "use strict";
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    },
    "%": "ANGLEInstancedArrays|Animation|AnimationEffect|AnimationNode|AnimationTimeline|AudioListener|AudioParam|BarProp|CSS|Cache|CacheStorage|Canvas2DContextAttributes|CanvasGradient|CanvasPattern|CircularRegion|ConsoleBase|Coordinates|Counter|Credential|CredentialsContainer|Crypto|CryptoKey|DOMError|DOMFileSystem|DOMFileSystemSync|DOMImplementation|DOMMatrix|DOMMatrixReadOnly|DOMParser|DataTransfer|Database|DatabaseSync|DeprecatedStorageInfo|DeprecatedStorageQuota|DeviceRotationRate|DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|EXTBlendMinMax|EXTFragDepth|EXTShaderTextureLOD|EXTTextureFilterAnisotropic|EntrySync|FederatedCredential|FetchBodyStream|FileEntrySync|FileError|FileReaderSync|FileWriterSync|FormData|GamepadButton|Geofencing|GeofencingRegion|Geolocation|Geoposition|HTMLAllCollection|IDBCursor|IDBCursorWithValue|IDBFactory|IDBIndex|IDBKeyRange|IDBObjectStore|ImageBitmap|ImageData|InjectedScriptHost|LocalCredential|MediaDeviceInfo|MediaError|MediaKeyError|MediaKeys|MediaQueryList|MemoryInfo|MessageChannel|Metadata|MutationObserver|MutationRecord|Navigator|NavigatorUserMediaError|NodeFilter|NodeIterator|OESElementIndexUint|OESStandardDerivatives|OESTextureFloat|OESTextureFloatLinear|OESTextureHalfFloat|OESTextureHalfFloatLinear|OESVertexArrayObject|PagePopupController|Path2D|PerformanceEntry|PerformanceMark|PerformanceMeasure|PerformanceNavigation|PerformanceResourceTiming|PerformanceTiming|PeriodicWave|PositionError|PushManager|PushRegistration|RGBColor|RTCIceCandidate|RTCSessionDescription|RTCStatsResponse|Range|ReadableStream|Rect|Request|Response|SQLError|SQLResultSet|SQLTransaction|SQLTransactionSync|SVGAngle|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPreserveAspectRatio|SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGPreserveAspectRatio|SVGRenderingIntent|SVGUnitTypes|SVGViewSpec|Screen|Selection|ServiceWorkerClient|ServiceWorkerClients|ServiceWorkerContainer|SourceInfo|SpeechRecognitionAlternative|SpeechSynthesisVoice|StorageInfo|StorageQuota|Stream|StyleMedia|SubtleCrypto|TextMetrics|Timing|TreeWalker|VTTRegion|ValidityState|VideoPlaybackQuality|VideoTrack|WebGLActiveInfo|WebGLBuffer|WebGLCompressedTextureATC|WebGLCompressedTextureETC1|WebGLCompressedTexturePVRTC|WebGLCompressedTextureS3TC|WebGLContextAttributes|WebGLDebugRendererInfo|WebGLDebugShaders|WebGLDepthTexture|WebGLDrawBuffers|WebGLExtensionLoseContext|WebGLFramebuffer|WebGLLoseContext|WebGLProgram|WebGLRenderbuffer|WebGLShader|WebGLShaderPrecisionFormat|WebGLTexture|WebGLUniformLocation|WebGLVertexArrayObjectOES|WebKitCSSMatrix|WebKitMutationObserver|WorkerConsole|WorkerLocation|WorkerNavigator|WorkerPerformance|XMLSerializer|XPathEvaluator|XPathExpression|XPathNSResolver|XPathResult|XSLTProcessor|mozRTCIceCandidate|mozRTCSessionDescription"
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    checkMutable$1: function(receiver, reason) {
      if (!!receiver.immutable$list)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    checkGrowable$1: function(receiver, reason) {
      if (!!receiver.fixed$length)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    add$1: function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    remove$1: function(receiver, element) {
      var i;
      this.checkGrowable$1(receiver, "remove");
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        this.add$1(receiver, t1.__internal$_current);
    },
    forEach$1: function(receiver, f) {
      var $length, i;
      $length = receiver.length;
      for (i = 0; i < $length; ++i) {
        f.call$1(receiver[i]);
        if ($length !== receiver.length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1;
      if (growable)
        return H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
      else {
        t1 = H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
        t1.fixed$length = Array;
        return t1;
      }
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, receiver.length, 0, null);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength, null, null));
      this.checkGrowable$1(receiver, "set length");
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      this.checkMutable$1(receiver, "indexed set");
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      receiver[index] = value;
    },
    $isJSArray: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: null
  },
  JSNumber: {
    "^": "Interceptor;",
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    abs$0: function(receiver) {
      return Math.abs(receiver);
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    roundToDouble$0: function(receiver) {
      if (receiver < 0)
        return -Math.round(-receiver);
      else
        return Math.round(receiver);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $negate: function(receiver) {
      return -receiver;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    $is$double: true,
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    $is$double: true,
    $isnum: true
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.charCodeAt(index);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      H.checkInt(startIndex);
      if (endIndex == null)
        endIndex = receiver.length;
      H.checkInt(endIndex);
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (typeof times !== "number")
        return H.iae(times);
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    indexOf$2: function(receiver, pattern, start) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      return receiver.indexOf(pattern, start);
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver[index];
    },
    $isJSIndexable: true,
    $isString: true
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }

      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : H.IsolateNatives__getJSFunctionFromName(functionName);
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(0, new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  },
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__getJSFunctionFromName: function(functionName) {
    return init.globalFunctions[functionName]();
  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    J.send$1$x(replyTo, ["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused === true) {
      context.addPause$2(t3, t3);
      init.globalState.topEventLoop.events._add$1(0, new H._IsolateEvent(context, t2, "start isolate"));
    } else
      t2.call$0();
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:6;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    }
  },
  startRootIsolate_closure0: {
    "^": "Closure:6;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    }
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      this.topEventLoop = new H._EventLoop(P.ListQueue$(null, H._IsolateEvent), 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t1);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log) {
              self.console.log(object);
            } else {
              self.postMessage(serialize(object));
            }
          };
        }(H._Manager__serializePrintMessage);
      }
    },
    static: {_Manager__serializePrintMessage: function(object) {
        return H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null));
      }}
  },
  _IsolateContext: {
    "^": "Object;id,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized,isPaused,delayedEvents,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$asx(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$ax(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      t1 = J.getInterceptor(pingType);
      if (!t1.$eq(pingType, 0))
        t2 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        J.send$1$x(responsePort, null);
        return;
      }
      t2 = new H._IsolateContext_handlePing_respond(responsePort);
      if (t1.$eq(pingType, 2)) {
        init.globalState.topEventLoop.events._add$1(0, new H._IsolateEvent(this, t2, "ping"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(0, t2);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      t1 = J.getInterceptor(priority);
      if (!t1.$eq(priority, 0))
        t2 = t1.$eq(priority, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        this.kill$0();
        return;
      }
      if (t1.$eq(priority, 2)) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1.events._add$1(0, new H._IsolateEvent(this, t2, "kill"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(0, this.get$kill());
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message, t2;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (this.errorsAreFatal === true && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = init;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : J.toString$0(stackTrace);
      for (t2 = new P.LinkedHashSetIterator(t1, t1._modifications, null, null), t2._cell = t1._first; t2.moveNext$0();)
        J.send$1$x(t2._collection$_current, message);
    },
    eval$1: function(code) {
      var old, result, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.handleUncaughtError$2(e, s);
        if (this.errorsAreFatal === true) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      }
 finally {
        this._isExecutingEvent = false;
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(0, portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2, t3;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(t1), t3 = t2._iterable, t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, t3.get$iterator(t3), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2.__internal$_current._close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
          J.send$1$x(t1.__internal$_current, null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 1]
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:1;responsePort_0",
    call$0: function() {
      J.send$1$x(this.responsePort_0, null);
    }
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return t1.removeFirst$0();
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(0, init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:1;this_0",
    call$0: function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    }
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.isPaused) {
        t1.delayedEvents.push(this);
        return;
      }
      t1.eval$1(this.fn);
    }
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:6;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    }
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:1;topLevel_0,args_1,message_2,isSpawnUri_3,context_4",
    call$0: function() {
      var t1, t2, t3;
      this.context_4.initialized = true;
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    }
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(_, message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this._receivePort;
      if (t3.get$_isClosed())
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (isolate.get$controlPort() === t3) {
        t1 = t1.msg_0;
        t2 = J.getInterceptor$asx(t1);
        switch (t2.$index(t1, 0)) {
          case "pause":
            isolate.addPause$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "resume":
            isolate.removePause$1(t2.$index(t1, 1));
            break;
          case "add-ondone":
            isolate.addDoneListener$1(t2.$index(t1, 1));
            break;
          case "remove-ondone":
            isolate.removeDoneListener$1(t2.$index(t1, 1));
            break;
          case "set-errors-fatal":
            isolate.setErrorsFatal$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "ping":
            isolate.handlePing$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "kill":
            isolate.handleKill$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "getErrors":
            t1 = t2.$index(t1, 1);
            isolate.errorPorts.add$1(0, t1);
            break;
          case "stopErrors":
            t1 = t2.$index(t1, 1);
            isolate.errorPorts.remove$1(0, t1);
            break;
        }
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(0, new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_NativeJsSendPort && J.$eq(this._receivePort, other._receivePort);
    },
    get$hashCode: function(_) {
      return this._receivePort.get$_id();
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:6;box_0,this_1,shouldSerialize_2",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1._receivePort;
      if (!t1.get$_isClosed()) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(0, this.box_0.msg_0);
      }
    }
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(_, message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_WorkerSendPort && J.$eq(this._workerId, other._workerId) && J.$eq(this._isolateId, other._isolateId) && J.$eq(this._receivePortId, other._receivePortId);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = this._workerId;
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = this._isolateId;
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 << 16 ^ t2 << 8 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;_id<,_handler,_isClosed<",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    _close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    __isolate_helper$_add$1: function(_, dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x._id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    },
    visitFunction$1: function(topLevelFunction) {
      var $name = !!topLevelFunction.$isClosure ? topLevelFunction.$name : null;
      if ($name == null)
        throw H.wrapException(P.UnsupportedError$("only top-level functions can be sent."));
      return ["function", $name];
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x._receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x._id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    },
    visitFunction$1: function(topLevelFunction) {
      var $name = !!topLevelFunction.$isClosure ? topLevelFunction.$name : null;
      if ($name == null)
        throw H.wrapException(P.UnsupportedError$("only top-level functions can be sent."));
      return H.IsolateNatives__getJSFunctionFromName($name);
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$asx(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$asx(list, 1));
    },
    deserializeFunction$1: function(list) {
      return H.IsolateNatives__getJSFunctionFromName(J.$index$asx(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function(_) {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function(_) {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0(0);
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      if (!!t1.$isFunction)
        return this.visitFunction$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, i;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (i = 0; i < len; ++i)
        copy[i] = this._dispatch$1(t1.$index(list, i));
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      J.forEach$1$ax(map, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitFunction$1: function(f) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:7;box_0,this_1",
    call$2: function(key, val) {
      var t1 = this.this_1;
      J.$indexSet$ax(this.box_0.copy_0, t1._dispatch$1(key), t1._dispatch$1(val));
    }
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1, t2;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      t2 = J.getInterceptor$x(map);
      return ["map", t1, this._serializeList$1(J.toList$0$ax(t2.get$keys(map))), this._serializeList$1(J.toList$0$ax(t2.get$values(map)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      for (i = 0; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitFunction$1: function(f) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$asx(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        case "function":
          return this.deserializeFunction$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$asx(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$asx(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$asx(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = self.setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(0, new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:1;this_0,callback_1",
    call$0: function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    }
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:1;this_2,callback_3",
    call$0: function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    }
  },
  CapabilityImpl: {
    "^": "Object;_id<",
    get$hashCode: function(_) {
      var hash = this._id;
      if (typeof hash !== "number")
        return hash.$shr();
      hash = C.JSNumber_methods._shrOtherPositive$1(hash, 0) ^ C.JSNumber_methods._tdivFast$1(hash, 4294967296);
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this._id;
        t2 = other._id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [P.$int];
    for (t1 = new H.ListIterator(codePoints, codePoints.length, 0, null); t1.moveNext$0();) {
      i = t1.__internal$_current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = new H.ListIterator(charCodes, charCodes.length, 0, null); t1.moveNext$0();) {
      i = t1.__internal$_current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_lazyAsJsDate: function(receiver) {
    if (receiver.date === void 0)
      receiver.date = new Date(receiver.millisecondsSinceEpoch);
    return receiver.date;
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkNum: function(value) {
    if (typeof value !== "number")
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  checkInt: function(value) {
    if (typeof value !== "number" || Math.floor(value) !== value)
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(false, null, null, null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = Array;
    reflectionInfo.fixed$length = Array;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$asx(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = Array;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto = Object.getPrototypeOf(obj);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_oRe();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }

        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }

        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:8;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    }
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    }
  },
  invokeClosure_closure: {
    "^": "Closure:6;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure:6;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure:6;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure:6;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure:6;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    $isClosure: true,
    $isFunction: true,
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      t1 = H.Primitives_objectHashCode(this._target);
      if (typeof receiverHashCode !== "number")
        return receiverHashCode.$xor();
      return (receiverHashCode ^ t1) >>> 0;
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    $isError: true,
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = Object.create(null);
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + H.S(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  initHooks_closure: {
    "^": "Closure:8;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    }
  },
  initHooks_closure0: {
    "^": "Closure:9;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    }
  },
  initHooks_closure1: {
    "^": "Closure:10;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    }
  }
}],
["bspparser", "package:bspparser/BSPParser.dart", , B, {
  "^": "",
  vectorList: function(num) {
    return P.List_List$generate(num, new B.vectorList_closure(), true, Q.Vector);
  },
  DotProduct: function(a, b) {
    var t1, t2, t3, t4, t5, t6;
    if (0 >= a.length)
      return H.ioore(a, 0);
    t1 = a[0];
    t2 = J.$index$asx(b, 0);
    if (typeof t1 !== "number")
      return t1.$mul();
    if (typeof t2 !== "number")
      return H.iae(t2);
    t3 = a.length;
    if (1 >= t3)
      return H.ioore(a, 1);
    t4 = a[1];
    t5 = b.length;
    if (1 >= t5)
      return H.ioore(b, 1);
    t6 = b[1];
    if (typeof t4 !== "number")
      return t4.$mul();
    if (typeof t6 !== "number")
      return H.iae(t6);
    if (2 >= t3)
      return H.ioore(a, 2);
    t3 = a[2];
    if (2 >= t5)
      return H.ioore(b, 2);
    t5 = b[2];
    if (typeof t3 !== "number")
      return t3.$mul();
    if (typeof t5 !== "number")
      return H.iae(t5);
    return t1 * t2 + t4 * t6 + t3 * t5;
  },
  VectorCopy: function(a, b) {
    var t1, t2, i, t3;
    for (t1 = J.getInterceptor$asx(b), t2 = J.getInterceptor$asx(a), i = 0; i < t1.get$length(b); ++i) {
      t3 = t2.$index(a, i);
      if (i >= b.length)
        return H.ioore(b, i);
      b[i] = t3;
    }
  },
  VectorMA: function(v, s, b, o) {
    var t1, t2, t3, t4;
    t1 = J.getInterceptor$asx(v);
    t2 = J.$add$ns(t1.$index(v, 0), J.$mul$ns(J.$index$asx(b, 0), s));
    t3 = o.array;
    if (0 >= t3.length)
      return H.ioore(t3, 0);
    t3[0] = t2;
    t2 = t1.$index(v, 1);
    t3 = b.length;
    if (1 >= t3)
      return H.ioore(b, 1);
    t2 = J.$add$ns(t2, J.$mul$ns(b[1], s));
    t4 = o.array;
    if (1 >= t4.length)
      return H.ioore(t4, 1);
    t4[1] = t2;
    t1 = t1.$index(v, 2);
    if (2 >= t3)
      return H.ioore(b, 2);
    t1 = J.$add$ns(t1, J.$mul$ns(b[2], s));
    t3 = o.array;
    if (2 >= t3.length)
      return H.ioore(t3, 2);
    t3[2] = t1;
  },
  VectorNormalize: function(v) {
    var t1, t2, $length, ilength;
    if (0 >= v.length)
      return H.ioore(v, 0);
    t1 = v[0];
    t1 = J.$mul$ns(t1, t1);
    if (1 >= v.length)
      return H.ioore(v, 1);
    t2 = v[1];
    t2 = J.$add$ns(t1, J.$mul$ns(t2, t2));
    if (2 >= v.length)
      return H.ioore(v, 2);
    t1 = v[2];
    t1 = J.$add$ns(t2, J.$mul$ns(t1, t1));
    if (typeof t1 !== "number")
      H.throwExpression(P.ArgumentError$(t1));
    $length = Math.sqrt(t1);
    if ($length !== 0) {
      ilength = 1 / $length;
      if (0 >= v.length)
        return H.ioore(v, 0);
      t1 = J.$mul$ns(v[0], ilength);
      t2 = v.length;
      if (0 >= t2)
        return H.ioore(v, 0);
      v[0] = t1;
      if (1 >= t2)
        return H.ioore(v, 1);
      t2 = J.$mul$ns(v[1], ilength);
      t1 = v.length;
      if (1 >= t1)
        return H.ioore(v, 1);
      v[1] = t2;
      if (2 >= t1)
        return H.ioore(v, 2);
      t1 = J.$mul$ns(v[2], ilength);
      if (2 >= v.length)
        return H.ioore(v, 2);
      v[2] = t1;
    }
    return $length;
  },
  snapVector: function(normal) {
    var i, t1, t2;
    for (i = 0; i < 3; ++i) {
      t1 = normal.array;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (Math.abs(t1[i] - 1) < 0.0001) {
        t1 = normal.array;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t1[0] = t1[0] * 0;
        if (1 >= t2)
          return H.ioore(t1, 1);
        t1[1] = t1[1] * 0;
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1[2] = t1[2] * 0;
        if (i >= t2)
          return H.ioore(t1, i);
        t1[i] = 1;
        break;
      }
      t1 = normal.array;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (Math.abs(t1[i] - -1) < 0.0001) {
        t1 = normal.array;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t1[0] = t1[0] * 0;
        if (1 >= t2)
          return H.ioore(t1, 1);
        t1[1] = t1[1] * 0;
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1[2] = t1[2] * 0;
        if (i >= t2)
          return H.ioore(t1, i);
        t1[i] = -1;
        break;
      }
    }
  },
  planeEqual: function(p, plane, flipped) {
    if (J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 0), plane[0])), 0.0001) && J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 1), plane[1])), 0.0001) && J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 2), plane[2])), 0.0001) && J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 3), plane[3])), 0.02)) {
      flipped.value = false;
      return true;
    }
    $.get$invplane()[0] = J.$negate$n(plane[0]);
    $.get$invplane()[1] = J.$negate$n(plane[1]);
    $.get$invplane()[2] = J.$negate$n(plane[2]);
    $.get$invplane()[3] = J.$negate$n(plane[3]);
    if (J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 0), $.get$invplane()[0])), 0.0001) && J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 1), $.get$invplane()[1])), 0.0001) && J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 2), $.get$invplane()[2])), 0.0001) && J.$lt$n(J.abs$0$n(J.$sub$n(J.$index$asx(p.get$plane(), 3), $.get$invplane()[3])), 0.02)) {
      flipped.value = true;
      return true;
    }
    return false;
  },
  signbitsForNormal: function(normal) {
    var bits, j;
    for (bits = 0, j = 0; j < 3; ++j) {
      if (j >= normal.length)
        return H.ioore(normal, j);
      if (J.$lt$n(normal[j], 0))
        bits = (bits | C.JSInt_methods._shlPositive$1(1, j)) >>> 0;
    }
    return bits;
  },
  planeFromPoints: function(plane, a, b, c) {
    var t1, t2, x, y, z, len, t3;
    $.get$d1().set$1(b).subtract$1(a);
    $.get$d2().set$1(c).subtract$1(a);
    t1 = $.get$d2();
    t1.cross2$2(t1, $.get$d1());
    t1 = $.get$d2().array;
    t2 = t1.length;
    if (0 >= t2)
      return H.ioore(t1, 0);
    x = t1[0];
    if (1 >= t2)
      return H.ioore(t1, 1);
    y = t1[1];
    if (2 >= t2)
      return H.ioore(t1, 2);
    z = t1[2];
    len = Math.sqrt(H.checkNum(x * x + y * y + z * z));
    if (len === 0)
      return false;
    $.get$d2().scale$1(0, 1 / len);
    t1 = $.get$d2();
    t2 = t1.array;
    t3 = t2.length;
    if (0 >= t3)
      return H.ioore(t2, 0);
    plane[0] = t2[0];
    if (1 >= t3)
      return H.ioore(t2, 1);
    plane[1] = t2[1];
    if (2 >= t3)
      return H.ioore(t2, 2);
    plane[2] = t2[2];
    plane[3] = a.dot$1(t1);
    return true;
  },
  generatePatchCollide: function(width, height, points) {
    var t1, grid, i, j, t2, t3, t4, pc, t5, t6, t7, t8;
    t1 = P.List_List$generate(129, new B.closure(), true, [P.List, Q.Vector]);
    grid = new B.Grid(null, null, null, null, t1);
    grid.width = width;
    grid.height = height;
    grid.wrapWidth = false;
    grid.wrapHeight = false;
    for (i = 0; i < width; ++i)
      for (j = 0; j < height; ++j) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = J.$index$asx(t1[i], j);
        t3 = j * width + i;
        if (t3 >= points.length)
          return H.ioore(points, t3);
        t2.set$1(points[t3]);
      }
    B.setGridWrapWidth(grid);
    B.subdivideGridColumns(grid);
    B.removeDegenerateColumns(grid);
    B.transposeGrid(grid);
    B.setGridWrapWidth(grid);
    B.subdivideGridColumns(grid);
    B.removeDegenerateColumns(grid);
    t2 = P.List_List$generate(2, new B.closure0(), true, Q.Vector);
    t3 = [];
    t3.$builtinTypeInfo = [B.PatchPlane];
    t4 = [];
    t4.$builtinTypeInfo = [B.Facet];
    pc = new B.PatchCollide(t2, null, t3, null, t4);
    t3 = t2.length;
    if (0 >= t3)
      return H.ioore(t2, 0);
    t4 = t2[0];
    if (1 >= t3)
      return H.ioore(t2, 1);
    t3 = t2[1];
    t5 = J.getInterceptor$ax(t4);
    t5.$indexSet(t4, 2, 99999.9);
    t5.$indexSet(t4, 1, 99999.9);
    t5.$indexSet(t4, 0, 99999.9);
    t4 = J.getInterceptor$ax(t3);
    t4.$indexSet(t3, 2, -99999.9);
    t4.$indexSet(t3, 1, -99999.9);
    t4.$indexSet(t3, 0, -99999.9);
    i = 0;
    while (true) {
      t3 = grid.width;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      j = 0;
      while (true) {
        t3 = grid.height;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(j < t3))
          break;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = J.$index$asx(t1[i], j);
        t4 = t2.length;
        if (0 >= t4)
          return H.ioore(t2, 0);
        t5 = t2[0];
        if (1 >= t4)
          return H.ioore(t2, 1);
        t4 = t2[1];
        t6 = J.getInterceptor$asx(t3);
        t7 = J.getInterceptor$asx(t5);
        if (J.$lt$n(t6.$index(t3, 0), t7.$index(t5, 0)))
          t7.$indexSet(t5, 0, t6.$index(t3, 0));
        t8 = J.getInterceptor$asx(t4);
        if (J.$gt$n(t6.$index(t3, 0), t8.$index(t4, 0)))
          t8.$indexSet(t4, 0, t6.$index(t3, 0));
        if (J.$lt$n(t6.$index(t3, 1), t7.$index(t5, 1)))
          t7.$indexSet(t5, 1, t6.$index(t3, 1));
        if (J.$gt$n(t6.$index(t3, 1), t8.$index(t4, 1)))
          t8.$indexSet(t4, 1, t6.$index(t3, 1));
        if (J.$lt$n(t6.$index(t3, 2), t7.$index(t5, 2)))
          t7.$indexSet(t5, 2, t6.$index(t3, 2));
        if (J.$gt$n(t6.$index(t3, 2), t8.$index(t4, 2)))
          t8.$indexSet(t4, 2, t6.$index(t3, 2));
        ++j;
      }
      ++i;
    }
    t1 = $.totalPatchBlocks;
    t4 = grid.height;
    if (typeof t4 !== "number")
      return t4.$sub();
    $.totalPatchBlocks = t1 + (t3 - 1) * (t4 - 1);
    B.patchCollideFromGrid(grid, pc);
    if (0 >= t2.length)
      return H.ioore(t2, 0);
    t4 = t2[0];
    t3 = J.getInterceptor$asx(t4);
    t3.$indexSet(t4, 0, J.$sub$n(t3.$index(t4, 0), 1));
    if (0 >= t2.length)
      return H.ioore(t2, 0);
    t4 = t2[0];
    t3 = J.getInterceptor$asx(t4);
    t3.$indexSet(t4, 1, J.$sub$n(t3.$index(t4, 1), 1));
    if (0 >= t2.length)
      return H.ioore(t2, 0);
    t4 = t2[0];
    t3 = J.getInterceptor$asx(t4);
    t3.$indexSet(t4, 2, J.$sub$n(t3.$index(t4, 2), 1));
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t4 = t2[1];
    t3 = J.getInterceptor$asx(t4);
    t3.$indexSet(t4, 0, J.$add$ns(t3.$index(t4, 0), 1));
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t4 = t2[1];
    t3 = J.getInterceptor$asx(t4);
    t3.$indexSet(t4, 1, J.$add$ns(t3.$index(t4, 1), 1));
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t2 = t2[1];
    t4 = J.getInterceptor$asx(t2);
    t4.$indexSet(t2, 2, J.$add$ns(t4.$index(t2, 2), 1));
    return pc;
  },
  patchCollideFromGrid: function(grid, pc) {
    var gridPlanes, borders, noAdjust, t1, i, p1, p2, p3, t2, i0, j, j0, facet, t3, t4, t5, t6, n;
    gridPlanes = P.List_List$generate(129, new B.patchCollideFromGrid_closure(), true, [P.List, [P.List, P.$int]]);
    borders = H.setRuntimeTypeInfo(Array(4), [P.$int]);
    noAdjust = H.setRuntimeTypeInfo(Array(4), [P.bool]);
    $.numPlanes = 0;
    t1 = grid.points;
    i = 0;
    p1 = null;
    p2 = null;
    p3 = null;
    while (true) {
      t2 = grid.width;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (!(i < t2 - 1))
        break;
      i0 = i + 1;
      j = 0;
      while (true) {
        t2 = grid.height;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (!(j < t2 - 1))
          break;
        if (i >= t1.length)
          return H.ioore(t1, i);
        p1 = J.$index$asx(t1[i], j);
        if (i0 >= t1.length)
          return H.ioore(t1, i0);
        p2 = J.$index$asx(t1[i0], j);
        if (i0 >= t1.length)
          return H.ioore(t1, i0);
        j0 = j + 1;
        p3 = J.$index$asx(t1[i0], j0);
        if (i >= gridPlanes.length)
          return H.ioore(gridPlanes, i);
        J.$indexSet$ax(J.$index$asx(gridPlanes[i], j), 0, B.findPlane(p1, p2, p3));
        if (i0 >= t1.length)
          return H.ioore(t1, i0);
        p1 = J.$index$asx(t1[i0], j0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        p2 = J.$index$asx(t1[i], j0);
        if (i >= t1.length)
          return H.ioore(t1, i);
        p3 = J.$index$asx(t1[i], j);
        if (i >= gridPlanes.length)
          return H.ioore(gridPlanes, i);
        J.$indexSet$ax(J.$index$asx(gridPlanes[i], j), 1, B.findPlane(p1, p2, p3));
        j = j0;
      }
      i = i0;
    }
    t1 = pc.facets;
    i = 0;
    facet = null;
    while (true) {
      t2 = grid.width;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (!(i < t2 - 1))
        break;
      t2 = i > 0;
      t3 = i - 1;
      i0 = i + 1;
      j = 0;
      while (true) {
        t4 = grid.height;
        if (typeof t4 !== "number")
          return t4.$sub();
        if (!(j < t4 - 1))
          break;
        c$1: {
          borders[0] = -1;
          if (j > 0) {
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[i], j - 1), 1);
            borders[0] = t4;
          } else if (grid.wrapHeight === true) {
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[i], t4 - 2), 1);
            borders[0] = t4;
          } else
            t4 = -1;
          if (i >= gridPlanes.length)
            return H.ioore(gridPlanes, i);
          noAdjust[0] = J.$eq(t4, J.$index$asx(J.$index$asx(gridPlanes[i], j), 0));
          if (J.$eq(borders[0], -1) || noAdjust[0] === true)
            borders[0] = B.edgePlaneNum(grid, gridPlanes, i, j, 0);
          borders[2] = -1;
          t4 = grid.height;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (j < t4 - 2) {
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[i], j + 1), 0);
            borders[2] = t4;
          } else if (grid.wrapHeight === true) {
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[i], 0), 0);
            borders[2] = t4;
          } else
            t4 = -1;
          if (i >= gridPlanes.length)
            return H.ioore(gridPlanes, i);
          noAdjust[2] = J.$eq(t4, J.$index$asx(J.$index$asx(gridPlanes[i], j), 1));
          if (J.$eq(borders[2], -1) || noAdjust[2] === true)
            borders[2] = B.edgePlaneNum(grid, gridPlanes, i, j, 2);
          borders[3] = -1;
          if (t2) {
            if (t3 < 0 || t3 >= gridPlanes.length)
              return H.ioore(gridPlanes, t3);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[t3], j), 0);
            borders[3] = t4;
          } else if (grid.wrapWidth === true) {
            t4 = grid.width;
            if (typeof t4 !== "number")
              return t4.$sub();
            t4 -= 2;
            if (t4 < 0 || t4 >= gridPlanes.length)
              return H.ioore(gridPlanes, t4);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[t4], j), 0);
            borders[3] = t4;
          } else
            t4 = -1;
          if (i >= gridPlanes.length)
            return H.ioore(gridPlanes, i);
          noAdjust[3] = J.$eq(t4, J.$index$asx(J.$index$asx(gridPlanes[i], j), 1));
          if (J.$eq(borders[3], -1) || noAdjust[3] === true)
            borders[3] = B.edgePlaneNum(grid, gridPlanes, i, j, 3);
          borders[1] = -1;
          t4 = grid.width;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (i < t4 - 2) {
            if (i0 >= gridPlanes.length)
              return H.ioore(gridPlanes, i0);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[i0], j), 1);
            borders[1] = t4;
          } else if (grid.wrapWidth === true) {
            if (0 >= gridPlanes.length)
              return H.ioore(gridPlanes, 0);
            t4 = J.$index$asx(J.$index$asx(gridPlanes[0], j), 1);
            borders[1] = t4;
          } else
            t4 = -1;
          if (i >= gridPlanes.length)
            return H.ioore(gridPlanes, i);
          noAdjust[1] = J.$eq(t4, J.$index$asx(J.$index$asx(gridPlanes[i], j), 0));
          if (J.$eq(borders[1], -1) || noAdjust[1] === true)
            borders[1] = B.edgePlaneNum(grid, gridPlanes, i, j, 1);
          t4 = Array(26);
          t4.fixed$length = init;
          t4.$builtinTypeInfo = [P.$int];
          t5 = Array(26);
          t5.$builtinTypeInfo = [P.bool];
          t6 = Array(26);
          t6.$builtinTypeInfo = [P.bool];
          facet = new B.Facet(null, null, t4, t5, t6);
          t1.push(facet);
          if (i >= gridPlanes.length)
            return H.ioore(gridPlanes, i);
          t5 = J.$index$asx(J.$index$asx(gridPlanes[i], j), 0);
          if (i >= gridPlanes.length)
            return H.ioore(gridPlanes, i);
          if (J.$eq(t5, J.$index$asx(J.$index$asx(gridPlanes[i], j), 1))) {
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            if (J.$eq(J.$index$asx(J.$index$asx(gridPlanes[i], j), 0), -1))
              break c$1;
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            facet._surfacePlane = J.$index$asx(J.$index$asx(gridPlanes[i], j), 0);
            facet.numBorders = 4;
            t5 = borders[0];
            if (0 >= 26)
              return H.ioore(t4, 0);
            t4[0] = t5;
            t5 = noAdjust[0];
            if (0 >= 26)
              return H.ioore(t6, 0);
            t6[0] = t5;
            t5 = borders[1];
            if (1 >= 26)
              return H.ioore(t4, 1);
            t4[1] = t5;
            t5 = noAdjust[1];
            if (1 >= 26)
              return H.ioore(t6, 1);
            t6[1] = t5;
            t5 = borders[2];
            if (2 >= 26)
              return H.ioore(t4, 2);
            t4[2] = t5;
            t5 = noAdjust[2];
            if (2 >= 26)
              return H.ioore(t6, 2);
            t6[2] = t5;
            t5 = borders[3];
            if (3 >= 26)
              return H.ioore(t4, 3);
            t4[3] = t5;
            t5 = noAdjust[3];
            if (3 >= 26)
              return H.ioore(t6, 3);
            t6[3] = t5;
            B.setBorderInward(facet, grid, gridPlanes, i, j, -1);
            if (B.validateFacet(facet))
              B.addFacetBevels(facet);
            else {
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t1.pop();
            }
          } else {
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            facet._surfacePlane = J.$index$asx(J.$index$asx(gridPlanes[i], j), 0);
            facet.numBorders = 3;
            t5 = borders[0];
            if (0 >= 26)
              return H.ioore(t4, 0);
            t4[0] = t5;
            t5 = noAdjust[0];
            if (0 >= 26)
              return H.ioore(t6, 0);
            t6[0] = t5;
            t5 = borders[1];
            if (1 >= 26)
              return H.ioore(t4, 1);
            t4[1] = t5;
            t5 = noAdjust[1];
            if (1 >= 26)
              return H.ioore(t6, 1);
            t6[1] = t5;
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            t5 = J.$index$asx(J.$index$asx(gridPlanes[i], j), 1);
            if (2 >= 26)
              return H.ioore(t4, 2);
            t4[2] = t5;
            if (J.$eq(t5, -1)) {
              t5 = borders[2];
              t4[2] = t5;
              if (J.$eq(t5, -1))
                t4[2] = B.edgePlaneNum(grid, gridPlanes, i, j, 4);
            }
            B.setBorderInward(facet, grid, gridPlanes, i, j, 0);
            if (B.validateFacet(facet))
              B.addFacetBevels(facet);
            else {
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t1.pop();
            }
            t4 = Array(26);
            t4.fixed$length = init;
            t4.$builtinTypeInfo = [P.$int];
            t5 = Array(26);
            t5.$builtinTypeInfo = [P.bool];
            t6 = Array(26);
            t6.$builtinTypeInfo = [P.bool];
            facet = new B.Facet(null, null, t4, t5, t6);
            t1.push(facet);
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            facet._surfacePlane = J.$index$asx(J.$index$asx(gridPlanes[i], j), 1);
            facet.numBorders = 3;
            t5 = borders[2];
            if (0 >= 26)
              return H.ioore(t4, 0);
            t4[0] = t5;
            t5 = noAdjust[2];
            if (0 >= 26)
              return H.ioore(t6, 0);
            t6[0] = t5;
            t5 = borders[3];
            if (1 >= 26)
              return H.ioore(t4, 1);
            t4[1] = t5;
            t5 = noAdjust[3];
            if (1 >= 26)
              return H.ioore(t6, 1);
            t6[1] = t5;
            if (i >= gridPlanes.length)
              return H.ioore(gridPlanes, i);
            t5 = J.$index$asx(J.$index$asx(gridPlanes[i], j), 0);
            if (2 >= 26)
              return H.ioore(t4, 2);
            t4[2] = t5;
            if (J.$eq(t5, -1)) {
              t5 = borders[0];
              t4[2] = t5;
              if (J.$eq(t5, -1))
                t4[2] = B.edgePlaneNum(grid, gridPlanes, i, j, 5);
            }
            B.setBorderInward(facet, grid, gridPlanes, i, j, 1);
            if (B.validateFacet(facet))
              B.addFacetBevels(facet);
            else {
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t1.pop();
            }
          }
        }
        ++j;
      }
      i = i0;
    }
    t2 = $.numPlanes;
    pc.numPlanes = t2;
    pc.numFacets = t1.length;
    if (typeof t2 !== "number")
      return H.iae(t2);
    pc.planes = H.setRuntimeTypeInfo(Array(t2), [B.PatchPlane]);
    n = 0;
    while (true) {
      t1 = $.numPlanes;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (!(n < t1))
        break;
      t1 = pc.planes;
      t2 = Array(4);
      t2.fixed$length = init;
      t2.$builtinTypeInfo = [P.$double];
      if (n >= t1.length)
        return H.ioore(t1, n);
      t1[n] = new B.PatchPlane(t2, null);
      t1 = pc.planes;
      if (n >= t1.length)
        return H.ioore(t1, n);
      t1 = t1[n].plane;
      t2 = $.get$planes();
      if (n >= t2.length)
        return H.ioore(t2, n);
      t2 = t2[n].get$plane();
      H.IterableMixinWorkaround_setAllList(t1, 0, t2);
      t1 = pc.planes;
      if (n >= t1.length)
        return H.ioore(t1, n);
      t1 = t1[n];
      t2 = $.get$planes();
      if (n >= t2.length)
        return H.ioore(t2, n);
      t1.signbits = t2[n].get$signbits();
      ++n;
    }
  },
  addFacetBevels: function(facet) {
    var flipped, plane, newplane, t1, mins, maxs, vec, vec2, t2, w, t3, t4, j, t5, t6, i, axis, dir, order, t7, t8, l, d, w2, j0, k, t9, t10, t11, t12;
    flipped = new B.Wrapper(false);
    plane = Array(4);
    plane.fixed$length = init;
    plane.$builtinTypeInfo = [P.$double];
    newplane = Array(4);
    newplane.$builtinTypeInfo = [P.$double];
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    mins = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    mins.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    maxs = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    maxs.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    vec = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    vec.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    vec2 = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    vec2.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = $.get$planes();
    t2 = facet._surfacePlane;
    if (t2 >>> 0 !== t2 || t2 >= t1.length)
      return H.ioore(t1, t2);
    B.VectorCopy(t1[t2].get$plane(), plane);
    w = B.BaseWindingForPlane(plane, plane[3]);
    t1 = facet.borderInward;
    t2 = t1.length;
    t3 = facet.borderPlanes;
    t4 = t3.length;
    j = 0;
    while (true) {
      t5 = facet.numBorders;
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (!(j < t5))
        break;
      c$0: {
        if (j >= t4)
          return H.ioore(t3, j);
        if (J.$eq(t3[j], facet._surfacePlane))
          break c$0;
        t5 = $.get$planes();
        t6 = t3[j];
        if (t6 >>> 0 !== t6 || t6 >= t5.length)
          return H.ioore(t5, t6);
        B.VectorCopy(t5[t6].get$plane(), plane);
        if (j >= t2)
          return H.ioore(t1, j);
        if (t1[j] !== true) {
          plane[0] = J.$negate$n(plane[0]);
          plane[1] = J.$negate$n(plane[1]);
          plane[2] = J.$negate$n(plane[2]);
          plane[3] = J.$negate$n(plane[3]);
        }
        w = B.ChopWindingInPlace(w, plane, plane[3], 0.1);
      }
      ++j;
    }
    if (w == null)
      return;
    B.WindingBounds(w, mins, maxs);
    for (t5 = facet.borderNoAdjust, t6 = t5.length, i = null, axis = 0, dir = null, order = 0; axis < 3; ++axis)
      for (dir = -1; dir <= 1; dir += 2, ++order) {
        H.IterableMixinWorkaround_fillRangeList(plane, 0, 3, 0);
        plane[axis] = dir;
        if (dir === 1) {
          t7 = maxs.array;
          if (axis >= t7.length)
            return H.ioore(t7, axis);
          plane[3] = t7[axis];
        } else {
          t7 = mins.array;
          if (axis >= t7.length)
            return H.ioore(t7, axis);
          plane[3] = -t7[axis];
        }
        t7 = $.get$planes();
        t8 = facet._surfacePlane;
        if (t8 >>> 0 !== t8 || t8 >= t7.length)
          return H.ioore(t7, t8);
        if (B.planeEqual(t7[t8], plane, flipped))
          continue;
        i = 0;
        while (true) {
          t7 = facet.numBorders;
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (!(i < t7))
            break;
          t7 = $.get$planes();
          if (i >= t4)
            return H.ioore(t3, i);
          t8 = t3[i];
          if (t8 >>> 0 !== t8 || t8 >= t7.length)
            return H.ioore(t7, t8);
          if (B.planeEqual(t7[t8], plane, flipped))
            break;
          ++i;
        }
        t7 = facet.numBorders;
        if (i === t7) {
          if (typeof t7 !== "number")
            return t7.$gt();
          if (t7 > 26)
            H.printString("ERROR: too many bevels\n");
          t7 = facet.numBorders;
          t8 = B.findPlane2(plane, flipped);
          if (t7 >>> 0 !== t7 || t7 >= t4)
            return H.ioore(t3, t7);
          t3[t7] = t8;
          t8 = facet.numBorders;
          if (t8 >>> 0 !== t8 || t8 >= t6)
            return H.ioore(t5, t8);
          t5[t8] = false;
          t7 = flipped.value;
          if (t8 >= t2)
            return H.ioore(t1, t8);
          t1[t8] = t7;
          facet.numBorders = t8 + 1;
        }
      }
    for (j = 0, l = null, d = null, w2 = null; t7 = w.numpoints, j < t7; j = j0) {
      j0 = j + 1;
      k = C.JSInt_methods.$mod(j0, t7);
      t7 = w.p;
      if (j >= t7.length)
        return H.ioore(t7, j);
      t7 = t7[j];
      t8 = vec.array;
      t9 = J.getInterceptor$asx(t7);
      t10 = t9.$index(t7, 0);
      if (0 >= t8.length)
        return H.ioore(t8, 0);
      t8[0] = t10;
      t10 = vec.array;
      t8 = t9.$index(t7, 1);
      if (1 >= t10.length)
        return H.ioore(t10, 1);
      t10[1] = t8;
      t8 = vec.array;
      t7 = t9.$index(t7, 2);
      if (2 >= t8.length)
        return H.ioore(t8, 2);
      t8[2] = t7;
      t7 = w.p;
      if (k >= t7.length)
        return H.ioore(t7, k);
      t7 = t7[k];
      t8 = vec.array;
      if (0 >= t8.length)
        return H.ioore(t8, 0);
      t9 = t8[0];
      t10 = J.getInterceptor$asx(t7);
      t11 = t10.$index(t7, 0);
      if (typeof t11 !== "number")
        return H.iae(t11);
      t8[0] = t9 - t11;
      t11 = vec.array;
      if (1 >= t11.length)
        return H.ioore(t11, 1);
      t9 = t11[1];
      t8 = t10.$index(t7, 1);
      if (typeof t8 !== "number")
        return H.iae(t8);
      t11[1] = t9 - t8;
      t8 = vec.array;
      if (2 >= t8.length)
        return H.ioore(t8, 2);
      t9 = t8[2];
      t7 = t10.$index(t7, 2);
      if (typeof t7 !== "number")
        return H.iae(t7);
      t8[2] = t9 - t7;
      if (B.VectorNormalize(vec.array) < 0.5)
        continue;
      B.snapVector(vec);
      for (t7 = vec.array, t8 = t7.length, k = 0; t9 = k < 3, t9; ++k) {
        if (k >= t8)
          return H.ioore(t7, k);
        t10 = t7[k];
        if (t10 === -1 || t10 === 1)
          break;
      }
      if (t9)
        continue;
      for (axis = 0; axis < 3; ++axis)
        for (dir = -1; dir <= 1; dir += 2) {
          t7 = vec2.array;
          t8 = t7.length;
          if (0 >= t8)
            return H.ioore(t7, 0);
          t7[0] = t7[0] * 0;
          if (1 >= t8)
            return H.ioore(t7, 1);
          t7[1] = t7[1] * 0;
          if (2 >= t8)
            return H.ioore(t7, 2);
          t7[2] = t7[2] * 0;
          if (axis >= t8)
            return H.ioore(t7, axis);
          t7[axis] = dir;
          t8 = vec.array;
          t9 = t8.length;
          if (1 >= t9)
            return H.ioore(t8, 1);
          t10 = t8[1];
          t11 = t7[2];
          if (2 >= t9)
            return H.ioore(t8, 2);
          t9 = t8[2];
          t12 = t7[1];
          plane[0] = t10 * t11 - t9 * t12;
          t7 = t7[0];
          t8 = t8[0];
          plane[1] = t9 * t7 - t8 * t11;
          plane[2] = t8 * t12 - t10 * t7;
          if (B.VectorNormalize(plane) < 0.5)
            continue;
          t7 = w.p;
          if (j >= t7.length)
            return H.ioore(t7, j);
          plane[3] = B.DotProduct(t7[j].get$array(), plane);
          for (l = 0; l < w.numpoints; ++l) {
            t7 = w.p;
            if (l >= t7.length)
              return H.ioore(t7, l);
            t7 = B.DotProduct(t7[l].get$array(), plane);
            t8 = plane[3];
            if (typeof t8 !== "number")
              return H.iae(t8);
            d = t7 - t8;
            if (d > 0.1)
              break;
          }
          if (l < w.numpoints)
            continue;
          t7 = $.get$planes();
          t8 = facet._surfacePlane;
          if (t8 >>> 0 !== t8 || t8 >= t7.length)
            return H.ioore(t7, t8);
          if (B.planeEqual(t7[t8], plane, flipped))
            continue;
          i = 0;
          while (true) {
            t7 = facet.numBorders;
            if (typeof t7 !== "number")
              return H.iae(t7);
            if (!(i < t7))
              break;
            t7 = $.get$planes();
            if (i >= t4)
              return H.ioore(t3, i);
            t8 = t3[i];
            if (t8 >>> 0 !== t8 || t8 >= t7.length)
              return H.ioore(t7, t8);
            if (B.planeEqual(t7[t8], plane, flipped))
              break;
            ++i;
          }
          t7 = facet.numBorders;
          if (i === t7) {
            if (typeof t7 !== "number")
              return t7.$gt();
            if (t7 > 26)
              H.printString("ERROR: too many bevels\n");
            t7 = facet.numBorders;
            t8 = B.findPlane2(plane, flipped);
            if (t7 >>> 0 !== t7 || t7 >= t4)
              return H.ioore(t3, t7);
            t3[t7] = t8;
            k = 0;
            while (true) {
              t7 = facet.numBorders;
              if (typeof t7 !== "number")
                return H.iae(t7);
              if (!(k < t7))
                break;
              if (t7 >= t4)
                return H.ioore(t3, t7);
              t7 = t3[t7];
              if (k >= t4)
                return H.ioore(t3, k);
              if (J.$eq(t7, t3[k]))
                H.printString("WARNING: bevel plane already used\n");
              ++k;
            }
            if (t7 >= t6)
              return H.ioore(t5, t7);
            t5[t7] = false;
            t8 = flipped.value;
            if (t7 >= t2)
              return H.ioore(t1, t7);
            t1[t7] = t8;
            w2 = B.CopyWinding(w);
            t8 = $.get$planes();
            t7 = facet.numBorders;
            if (t7 >>> 0 !== t7 || t7 >= t4)
              return H.ioore(t3, t7);
            t7 = t3[t7];
            if (t7 >>> 0 !== t7 || t7 >= t8.length)
              return H.ioore(t8, t7);
            B.VectorCopy(t8[t7].get$plane(), newplane);
            t7 = facet.numBorders;
            if (t7 >>> 0 !== t7 || t7 >= t2)
              return H.ioore(t1, t7);
            if (t1[t7] !== true) {
              newplane[0] = J.$negate$n(newplane[0]);
              newplane[1] = J.$negate$n(newplane[1]);
              newplane[2] = J.$negate$n(newplane[2]);
              newplane[3] = J.$negate$n(newplane[3]);
            }
            B.ChopWindingInPlace(w2, newplane, newplane[3], 0.1);
            t7 = facet.numBorders;
            if (typeof t7 !== "number")
              return t7.$add();
            facet.numBorders = t7 + 1;
          }
        }
    }
    t7 = facet.numBorders;
    t8 = facet._surfacePlane;
    if (t7 >>> 0 !== t7 || t7 >= t4)
      return H.ioore(t3, t7);
    t3[t7] = t8;
    if (t7 >= t6)
      return H.ioore(t5, t7);
    t5[t7] = false;
    if (t7 >= t2)
      return H.ioore(t1, t7);
    t1[t7] = true;
    facet.numBorders = t7 + 1;
  },
  CopyWinding: function(w) {
    var r = B.Winding$(4);
    r.numpoints = w.numpoints;
    r.p = P.List_List$generate(w.numpoints, new B.CopyWinding_closure(w), true, Q.Vector);
    return r;
  },
  findPlane2: function(plane, flipped) {
    var i, t1, t2;
    i = 0;
    while (true) {
      t1 = $.numPlanes;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (!(i < t1))
        break;
      t1 = $.get$planes();
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (B.planeEqual(t1[i], plane, flipped))
        return i;
      ++i;
    }
    t2 = $.get$planes();
    if (t1 >= t2.length)
      return H.ioore(t2, t1);
    B.VectorCopy(plane, t2[t1].get$plane());
    t1 = $.get$planes();
    t2 = $.numPlanes;
    if (t2 >>> 0 !== t2 || t2 >= t1.length)
      return H.ioore(t1, t2);
    t1[t2].set$signbits(B.signbitsForNormal(plane));
    t2 = $.numPlanes;
    if (typeof t2 !== "number")
      return t2.$add();
    ++t2;
    $.numPlanes = t2;
    flipped.value = false;
    return t2 - 1;
  },
  validateFacet: function(facet) {
    var plane, bounds, t1, t2, w, t3, t4, j, t5, t6;
    plane = Array(4);
    plane.$builtinTypeInfo = [P.$double];
    bounds = P.List_List$generate(2, new B.validateFacet_closure(), true, Q.Vector);
    if (J.$eq(facet._surfacePlane, -1))
      return false;
    t1 = $.get$planes();
    t2 = facet._surfacePlane;
    if (t2 >>> 0 !== t2 || t2 >= t1.length)
      return H.ioore(t1, t2);
    B.VectorCopy(t1[t2].get$plane(), plane);
    w = B.BaseWindingForPlane(plane, plane[3]);
    t1 = facet.borderInward;
    t2 = t1.length;
    t3 = facet.borderPlanes;
    t4 = t3.length;
    j = 0;
    while (true) {
      t5 = facet.numBorders;
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (!(j < t5))
        break;
      if (j >= t4)
        return H.ioore(t3, j);
      if (J.$eq(t3[j], -1))
        return false;
      t5 = $.get$planes();
      t6 = t3[j];
      if (t6 >>> 0 !== t6 || t6 >= t5.length)
        return H.ioore(t5, t6);
      B.VectorCopy(t5[t6].get$plane(), plane);
      if (j >= t2)
        return H.ioore(t1, j);
      if (t1[j] !== true) {
        plane[0] = J.$negate$n(plane[0]);
        plane[1] = J.$negate$n(plane[1]);
        plane[2] = J.$negate$n(plane[2]);
        plane[3] = J.$negate$n(plane[3]);
      }
      w = B.ChopWindingInPlace(w, plane, plane[3], 0.1);
      ++j;
    }
    if (w == null)
      return false;
    t1 = bounds.length;
    if (0 >= t1)
      return H.ioore(bounds, 0);
    t2 = bounds[0];
    if (1 >= t1)
      return H.ioore(bounds, 1);
    B.WindingBounds(w, t2, bounds[1]);
    for (j = 0; j < 3; ++j) {
      if (1 >= bounds.length)
        return H.ioore(bounds, 1);
      t1 = J.$index$asx(bounds[1], j);
      if (0 >= bounds.length)
        return H.ioore(bounds, 0);
      if (J.$gt$n(J.$sub$n(t1, J.$index$asx(bounds[0], j)), 65535))
        return false;
      if (0 >= bounds.length)
        return H.ioore(bounds, 0);
      if (J.$ge$n(J.$index$asx(bounds[0], j), 65535))
        return false;
      if (1 >= bounds.length)
        return H.ioore(bounds, 1);
      if (J.$le$n(J.$index$asx(bounds[1], j), -65535))
        return false;
    }
    return true;
  },
  WindingBounds: function(w, mins, maxs) {
    var t1, t2, i, j, t3, v;
    t1 = J.getInterceptor$ax(mins);
    t1.$indexSet(mins, 2, 65535);
    t1.$indexSet(mins, 1, 65535);
    t1.$indexSet(mins, 0, 65535);
    t2 = J.getInterceptor$ax(maxs);
    t2.$indexSet(maxs, 2, -65535);
    t2.$indexSet(maxs, 1, -65535);
    t2.$indexSet(maxs, 0, -65535);
    for (i = 0; i < w.numpoints; ++i)
      for (j = 0; j < 3; ++j) {
        t3 = w.p;
        if (i >= t3.length)
          return H.ioore(t3, i);
        v = J.$index$asx(t3[i], j);
        t3 = J.getInterceptor$n(v);
        if (t3.$lt(v, t1.$index(mins, j)))
          t1.$indexSet(mins, j, v);
        if (t3.$gt(v, t2.$index(maxs, j)))
          t2.$indexSet(maxs, j, v);
      }
  },
  ChopWindingInPlace: function(inout, normal, dist, epsilon) {
    var dists, sides, counts, t1, mid, dot, i, t2, t3, f, j, p2, p1, t4, t5;
    dists = Array(68);
    dists.$builtinTypeInfo = [P.$double];
    sides = Array(68);
    sides.$builtinTypeInfo = [P.$int];
    counts = Array(3);
    counts.$builtinTypeInfo = [P.$int];
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    mid = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    mid.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    counts[2] = 0;
    counts[1] = 0;
    counts[0] = 0;
    for (t1 = -epsilon, dot = null, i = 0; t2 = inout.numpoints, i < t2; ++i) {
      t2 = inout.p;
      if (i >= t2.length)
        return H.ioore(t2, i);
      dot = B.DotProduct(t2[i].get$array(), normal);
      if (typeof dist !== "number")
        return H.iae(dist);
      dot -= dist;
      if (i >= 68)
        return H.ioore(dists, i);
      dists[i] = dot;
      if (dot > epsilon) {
        sides[i] = 0;
        t2 = 0;
      } else if (dot < t1) {
        sides[i] = 1;
        t2 = 1;
      } else {
        sides[i] = 2;
        t2 = 2;
      }
      t3 = counts[t2];
      if (typeof t3 !== "number")
        return t3.$add();
      counts[t2] = t3 + 1;
    }
    t1 = sides[0];
    if (i >= 68)
      return H.ioore(sides, i);
    sides[i] = t1;
    dists[i] = dists[0];
    if (counts[0] === 0)
      return;
    if (counts[1] === 0)
      return inout;
    f = B.Winding$(t2 + 4);
    for (t1 = J.getInterceptor$n(dist), i = 0, j = null, p2 = null; i < inout.numpoints; ++i) {
      t2 = inout.p;
      if (i >= t2.length)
        return H.ioore(t2, i);
      p1 = t2[i];
      if (i >= 68)
        return H.ioore(sides, i);
      t2 = sides[i];
      if (t2 === 2) {
        t2 = f.p;
        t3 = f.numpoints;
        if (t3 >= t2.length)
          return H.ioore(t2, t3);
        t2[t3].set$1(p1);
        ++f.numpoints;
        continue;
      }
      if (t2 === 0) {
        t2 = f.p;
        t3 = f.numpoints;
        if (t3 >= t2.length)
          return H.ioore(t2, t3);
        t2[t3].set$1(p1);
        ++f.numpoints;
      }
      t2 = i + 1;
      if (t2 >= 68)
        return H.ioore(sides, t2);
      t3 = sides[t2];
      if (t3 !== 2) {
        t4 = sides[i];
        t4 = t3 == null ? t4 == null : t3 === t4;
        t3 = t4;
      } else
        t3 = true;
      if (t3)
        continue;
      t3 = inout.p;
      t4 = C.JSInt_methods.$mod(t2, inout.numpoints);
      if (t4 >= t3.length)
        return H.ioore(t3, t4);
      p2 = t3[t4];
      t4 = dists[i];
      t2 = dists[t2];
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      dot = t4 / (t4 - t2);
      for (t2 = J.getInterceptor$asx(p1), t3 = J.getInterceptor$asx(p2), j = 0; j < 3; ++j)
        if (J.$eq(normal[j], 1)) {
          t4 = mid.array;
          if (j >= t4.length)
            return H.ioore(t4, j);
          t4[j] = dist;
        } else if (J.$eq(normal[j], -1)) {
          t4 = t1.$negate(dist);
          t5 = mid.array;
          if (j >= t5.length)
            return H.ioore(t5, j);
          t5[j] = t4;
        } else {
          t4 = t2.$index(p1, j);
          t5 = J.$sub$n(t3.$index(p2, j), t2.$index(p1, j));
          if (typeof t5 !== "number")
            return H.iae(t5);
          t5 = J.$add$ns(t4, dot * t5);
          t4 = mid.array;
          if (j >= t4.length)
            return H.ioore(t4, j);
          t4[j] = t5;
        }
      t2 = f.p;
      t3 = f.numpoints;
      if (t3 >= t2.length)
        return H.ioore(t2, t3);
      t2[t3].set$1(mid);
      ++f.numpoints;
    }
    return f;
  },
  BaseWindingForPlane: function(normal, dist) {
    var vup, i, x, max, v, t1, org, vright, w;
    vup = Q.Vector$(0, 0, 0);
    for (i = 0, x = -1, max = -65535; i < 3; ++i) {
      v = J.abs$0$n(normal[i]);
      if (J.$gt$n(v, max)) {
        max = v;
        x = i;
      }
    }
    switch (x) {
      case 0:
      case 1:
        t1 = vup.array;
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = 1;
        break;
      case 2:
        t1 = vup.array;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1[0] = 1;
        break;
    }
    B.VectorMA(vup, -B.DotProduct(vup.array, normal), normal, vup);
    vup.normalize$0(0);
    org = Q.Vector$fromList(normal);
    vright = Q.Vector$(0, 0, 0).cross2$2(vup, org);
    org.scale$1(0, dist);
    vup.scale$1(0, 65535);
    vright.scale$1(0, 65535);
    w = B.Winding$(4);
    t1 = w.p;
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    t1[0].set$1(org).subtract$1(vright).add$1(0, vup);
    t1 = w.p;
    if (1 >= t1.length)
      return H.ioore(t1, 1);
    t1[1].set$1(org).add$1(0, vright).add$1(0, vup);
    t1 = w.p;
    if (2 >= t1.length)
      return H.ioore(t1, 2);
    t1[2].set$1(org).add$1(0, vright).subtract$1(vup);
    t1 = w.p;
    if (3 >= t1.length)
      return H.ioore(t1, 3);
    t1[3].set$1(org).subtract$1(vright).subtract$1(vup);
    w.numpoints = 4;
    return w;
  },
  setBorderInward: function(facet, grid, gridPlanes, i, j, which) {
    var points, t1, t2, t3, numPoints, t4, k, t5, front, $back, l, side;
    points = P.List_List$generate(4, new B.setBorderInward_closure(), true, Q.Vector);
    switch (which) {
      case -1:
        t1 = grid.points;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = J.$index$asx(t1[i], j);
        if (0 >= points.length)
          return H.ioore(points, 0);
        points[0] = t2;
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t3 = J.$index$asx(t1[t2], j);
        if (1 >= points.length)
          return H.ioore(points, 1);
        points[1] = t3;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t3 = j + 1;
        t2 = J.$index$asx(t1[t2], t3);
        if (2 >= points.length)
          return H.ioore(points, 2);
        points[2] = t2;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = J.$index$asx(t1[i], t3);
        if (3 >= points.length)
          return H.ioore(points, 3);
        points[3] = t3;
        numPoints = 4;
        break;
      case 0:
        t1 = grid.points;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = J.$index$asx(t1[i], j);
        if (0 >= points.length)
          return H.ioore(points, 0);
        points[0] = t2;
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t3 = J.$index$asx(t1[t2], j);
        if (1 >= points.length)
          return H.ioore(points, 1);
        points[1] = t3;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t2 = J.$index$asx(t1[t2], j + 1);
        if (2 >= points.length)
          return H.ioore(points, 2);
        points[2] = t2;
        numPoints = 3;
        break;
      case 1:
        t1 = grid.points;
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t3 = j + 1;
        t2 = J.$index$asx(t1[t2], t3);
        if (0 >= points.length)
          return H.ioore(points, 0);
        points[0] = t2;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = J.$index$asx(t1[i], t3);
        if (1 >= points.length)
          return H.ioore(points, 1);
        points[1] = t3;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = J.$index$asx(t1[i], j);
        if (2 >= points.length)
          return H.ioore(points, 2);
        points[2] = t1;
        numPoints = 3;
        break;
      default:
        H.printString("setBorderInward: bad parameter");
        numPoints = 0;
        break;
    }
    t1 = facet.borderInward;
    t2 = t1.length;
    t3 = facet.borderPlanes;
    t4 = t3.length;
    k = 0;
    while (true) {
      t5 = facet.numBorders;
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (!(k < t5))
        break;
      for (front = 0, $back = 0, l = 0; l < numPoints; ++l) {
        if (l >= points.length)
          return H.ioore(points, l);
        t5 = points[l];
        if (k >= t4)
          return H.ioore(t3, k);
        side = B.pointOnPlaneSide(t5, t3[k]);
        if (side === 0)
          ++front;
        if (side === 1)
          ++$back;
      }
      if (front > 0 && $back === 0) {
        if (k >= t2)
          return H.ioore(t1, k);
        t1[k] = true;
      } else if ($back > 0 && front === 0) {
        if (k >= t2)
          return H.ioore(t1, k);
        t1[k] = false;
      } else if (front === 0 && $back === 0) {
        if (k >= t4)
          return H.ioore(t3, k);
        t3[k] = -1;
      } else {
        H.printString("WARNING: CM_SetBorderInward: mixed plane sides\n");
        if (k >= t2)
          return H.ioore(t1, k);
        t1[k] = false;
      }
      ++k;
    }
  },
  pointOnPlaneSide: function(p, planeNum) {
    var t1, plane, t2, d;
    if (J.$eq(planeNum, -1))
      return 2;
    t1 = $.get$planes();
    if (planeNum >>> 0 !== planeNum || planeNum >= t1.length)
      return H.ioore(t1, planeNum);
    plane = t1[planeNum].get$plane();
    t1 = B.DotProduct(p.get$array(), plane);
    t2 = J.$index$asx(plane, 3);
    if (typeof t2 !== "number")
      return H.iae(t2);
    d = t1 - t2;
    if (d > 0.1)
      return 0;
    if (d < -0.1)
      return 1;
    return 2;
  },
  edgePlaneNum: function(grid, gridPlanes, i, j, k) {
    var t1, up, p1, t2, p2, p, t3;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    up = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    up.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    switch (k) {
      case 0:
        t1 = grid.points;
        if (i >= t1.length)
          return H.ioore(t1, i);
        p1 = J.$index$asx(t1[i], j);
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        p2 = J.$index$asx(t1[t2], j);
        p = B.gridPlane(gridPlanes, i, j, 0);
        t2 = $.get$planes();
        if (p >>> 0 !== p || p >= t2.length)
          return H.ioore(t2, p);
        B.VectorMA(p1, 4, t2[p].get$plane(), up);
        return B.findPlane(p1, p2, up);
      case 2:
        t1 = grid.points;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = j + 1;
        p1 = J.$index$asx(t1[i], t2);
        t3 = i + 1;
        if (t3 >= t1.length)
          return H.ioore(t1, t3);
        p2 = J.$index$asx(t1[t3], t2);
        p = B.gridPlane(gridPlanes, i, j, 1);
        t2 = $.get$planes();
        if (p >>> 0 !== p || p >= t2.length)
          return H.ioore(t2, p);
        B.VectorMA(p1, 4, t2[p].get$plane(), up);
        return B.findPlane(p2, p1, up);
      case 3:
        t1 = grid.points;
        if (i >= t1.length)
          return H.ioore(t1, i);
        p1 = J.$index$asx(t1[i], j);
        if (i >= t1.length)
          return H.ioore(t1, i);
        p2 = J.$index$asx(t1[i], j + 1);
        p = B.gridPlane(gridPlanes, i, j, 1);
        t1 = $.get$planes();
        if (p >>> 0 !== p || p >= t1.length)
          return H.ioore(t1, p);
        B.VectorMA(p1, 4, t1[p].get$plane(), up);
        return B.findPlane(p2, p1, up);
      case 1:
        t1 = grid.points;
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        p1 = J.$index$asx(t1[t2], j);
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        p2 = J.$index$asx(t1[t2], j + 1);
        p = B.gridPlane(gridPlanes, i, j, 0);
        t2 = $.get$planes();
        if (p >>> 0 !== p || p >= t2.length)
          return H.ioore(t2, p);
        B.VectorMA(p1, 4, t2[p].get$plane(), up);
        return B.findPlane(p1, p2, up);
      case 4:
        t1 = grid.points;
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        p1 = J.$index$asx(t1[t2], j + 1);
        if (i >= t1.length)
          return H.ioore(t1, i);
        p2 = J.$index$asx(t1[i], j);
        p = B.gridPlane(gridPlanes, i, j, 0);
        t1 = $.get$planes();
        if (p >>> 0 !== p || p >= t1.length)
          return H.ioore(t1, p);
        B.VectorMA(p1, 4, t1[p].get$plane(), up);
        return B.findPlane(p1, p2, up);
      case 5:
        t1 = grid.points;
        if (i >= t1.length)
          return H.ioore(t1, i);
        p1 = J.$index$asx(t1[i], j);
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        p2 = J.$index$asx(t1[t2], j + 1);
        p = B.gridPlane(gridPlanes, i, j, 1);
        t2 = $.get$planes();
        if (p >>> 0 !== p || p >= t2.length)
          return H.ioore(t2, p);
        B.VectorMA(p1, 4, t2[p].get$plane(), up);
        return B.findPlane(p1, p2, up);
    }
    H.printString("edgePlaneNum: bad k");
    return -1;
  },
  gridPlane: function(gridPlanes, i, j, tri) {
    var p, t1;
    if (i >= gridPlanes.length)
      return H.ioore(gridPlanes, i);
    p = J.$index$asx(J.$index$asx(gridPlanes[i], j), tri);
    if (!J.$eq(p, -1))
      return p;
    if (i >= gridPlanes.length)
      return H.ioore(gridPlanes, i);
    t1 = J.$index$asx(gridPlanes[i], j);
    p = J.$index$asx(t1, tri > 0 ? 0 : 1);
    if (!J.$eq(p, -1))
      return p;
    P.print("WARNING: CM_GridPlane unresolvable\n");
    return -1;
  },
  findPlane: function(p1, p2, p3) {
    var plane, i, d, t1, t2;
    plane = Array(4);
    plane.$builtinTypeInfo = [P.$double];
    if (!B.planeFromPoints(plane, p1, p2, p3))
      return -1;
    i = 0;
    d = null;
    while (true) {
      t1 = $.numPlanes;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (!(i < t1))
        break;
      c$0: {
        t1 = $.get$planes();
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (B.DotProduct(plane, t1[i].get$plane()) < 0)
          break c$0;
        t1 = p1.get$array();
        t2 = $.get$planes();
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = B.DotProduct(t1, t2[i].get$plane());
        t1 = $.get$planes();
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = J.$index$asx(t1[i].get$plane(), 3);
        if (typeof t1 !== "number")
          return H.iae(t1);
        d = t2 - t1;
        if (d < -0.1 || d > 0.1)
          break c$0;
        t1 = p2.get$array();
        t2 = $.get$planes();
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = B.DotProduct(t1, t2[i].get$plane());
        t1 = $.get$planes();
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = J.$index$asx(t1[i].get$plane(), 3);
        if (typeof t1 !== "number")
          return H.iae(t1);
        d = t2 - t1;
        if (d < -0.1 || d > 0.1)
          break c$0;
        t1 = p3.get$array();
        t2 = $.get$planes();
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = B.DotProduct(t1, t2[i].get$plane());
        t1 = $.get$planes();
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = J.$index$asx(t1[i].get$plane(), 3);
        if (typeof t1 !== "number")
          return H.iae(t1);
        d = t2 - t1;
        if (d < -0.1 || d > 0.1)
          break c$0;
        return i;
      }
      ++i;
    }
    t2 = $.get$planes();
    if (t1 >= t2.length)
      return H.ioore(t2, t1);
    B.VectorCopy(plane, t2[t1].get$plane());
    t1 = $.get$planes();
    t2 = $.numPlanes;
    if (t2 >>> 0 !== t2 || t2 >= t1.length)
      return H.ioore(t1, t2);
    t1[t2].set$signbits(B.signbitsForNormal(plane));
    t2 = $.numPlanes;
    if (typeof t2 !== "number")
      return t2.$add();
    ++t2;
    $.numPlanes = t2;
    return t2 - 1;
  },
  transposeGrid: function(grid) {
    var temp, t1, t2, i, t3, j, j0, t4, t5, tempWrap;
    temp = Q.Vector$(0, 0, 0);
    t1 = grid.width;
    t2 = grid.height;
    if (typeof t1 !== "number")
      return t1.$gt();
    if (typeof t2 !== "number")
      return H.iae(t2);
    if (t1 > t2) {
      t2 = grid.points;
      i = 0;
      while (true) {
        t3 = grid.height;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        j = i + 1;
        j0 = j;
        while (true) {
          t1 = grid.width;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(j0 < t1))
            break;
          t1 = grid.height;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t3 = t2[i];
          t4 = t2.length;
          if (j0 < t1) {
            if (i >= t4)
              return H.ioore(t2, i);
            t1 = J.$index$asx(t3, j0);
            t3 = temp.array;
            t4 = J.getInterceptor$asx(t1);
            t5 = t4.$index(t1, 0);
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t3[0] = t5;
            t5 = temp.array;
            t3 = t4.$index(t1, 1);
            if (1 >= t5.length)
              return H.ioore(t5, 1);
            t5[1] = t3;
            t3 = temp.array;
            t1 = t4.$index(t1, 2);
            if (2 >= t3.length)
              return H.ioore(t3, 2);
            t3[2] = t1;
            if (i >= t2.length)
              return H.ioore(t2, i);
            t1 = J.$index$asx(t2[i], j0);
            if (j0 >= t2.length)
              return H.ioore(t2, j0);
            t1.set$1(J.$index$asx(t2[j0], i));
            if (j0 >= t2.length)
              return H.ioore(t2, j0);
            J.$index$asx(t2[j0], i).set$1(temp);
          } else {
            if (i >= t4)
              return H.ioore(t2, i);
            t1 = J.$index$asx(t3, j0);
            if (j0 >= t2.length)
              return H.ioore(t2, j0);
            t1.set$1(J.$index$asx(t2[j0], i));
          }
          ++j0;
        }
        i = j;
      }
      t2 = t3;
    } else {
      t1 = grid.points;
      i = 0;
      while (true) {
        t3 = grid.width;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        j = i + 1;
        j0 = j;
        while (true) {
          t2 = grid.height;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j0 < t2))
            break;
          t2 = grid.width;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = t1.length;
          t4 = t1[j0];
          if (j0 < t2) {
            if (j0 >= t3)
              return H.ioore(t1, j0);
            t2 = J.$index$asx(t4, i);
            t3 = temp.array;
            t4 = J.getInterceptor$asx(t2);
            t5 = t4.$index(t2, 0);
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t3[0] = t5;
            t5 = temp.array;
            t3 = t4.$index(t2, 1);
            if (1 >= t5.length)
              return H.ioore(t5, 1);
            t5[1] = t3;
            t3 = temp.array;
            t2 = t4.$index(t2, 2);
            if (2 >= t3.length)
              return H.ioore(t3, 2);
            t3[2] = t2;
            if (j0 >= t1.length)
              return H.ioore(t1, j0);
            t2 = J.$index$asx(t1[j0], i);
            if (i >= t1.length)
              return H.ioore(t1, i);
            t2.set$1(J.$index$asx(t1[i], j0));
            if (i >= t1.length)
              return H.ioore(t1, i);
            J.$index$asx(t1[i], j0).set$1(temp);
          } else {
            if (j0 >= t3)
              return H.ioore(t1, j0);
            t2 = J.$index$asx(t4, i);
            if (i >= t1.length)
              return H.ioore(t1, i);
            t2.set$1(J.$index$asx(t1[i], j0));
          }
          ++j0;
        }
        i = j;
      }
      t1 = t3;
    }
    grid.width = t2;
    grid.height = t1;
    tempWrap = grid.wrapWidth;
    grid.wrapWidth = grid.wrapHeight;
    grid.wrapHeight = tempWrap;
  },
  comparePoints: function(a, b) {
    var t1, t2, d, t3;
    t1 = J.getInterceptor$asx(a);
    t2 = J.getInterceptor$asx(b);
    d = J.$sub$n(t1.$index(a, 0), t2.$index(b, 0));
    t3 = J.getInterceptor$n(d);
    if (t3.$lt(d, -0.1) || t3.$gt(d, 0.1))
      return false;
    d = J.$sub$n(t1.$index(a, 1), t2.$index(b, 1));
    t3 = J.getInterceptor$n(d);
    if (t3.$lt(d, -0.1) || t3.$gt(d, 0.1))
      return false;
    d = J.$sub$n(t1.$index(a, 2), t2.$index(b, 2));
    t1 = J.getInterceptor$n(d);
    if (t1.$lt(d, -0.1) || t1.$gt(d, 0.1))
      return false;
    return true;
  },
  removeDegenerateColumns: function(grid) {
    var t1, i, k, t2, j, t3, k0;
    t1 = grid.points;
    i = 0;
    k = null;
    while (true) {
      t2 = grid.width;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (!(i < t2 - 1))
        break;
      c$0: {
        t2 = i + 1;
        j = 0;
        while (true) {
          t3 = grid.height;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(j < t3))
            break;
          if (i < 0 || i >= t1.length)
            return H.ioore(t1, i);
          t3 = J.$index$asx(t1[i], j);
          if (t2 < 0 || t2 >= t1.length)
            return H.ioore(t1, t2);
          if (!B.comparePoints(t3, J.$index$asx(t1[t2], j)))
            break;
          ++j;
        }
        if (j !== grid.height)
          break c$0;
        k0 = i + 2;
        j = 0;
        while (true) {
          t2 = grid.height;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          k = k0;
          while (true) {
            t2 = grid.width;
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(k < t2))
              break;
            t2 = k - 1;
            if (t2 < 0 || t2 >= t1.length)
              return H.ioore(t1, t2);
            t2 = J.$index$asx(t1[t2], j);
            if (k < 0 || k >= t1.length)
              return H.ioore(t1, k);
            t2.set$1(J.$index$asx(t1[k], j));
            ++k;
          }
          ++j;
        }
        t2 = grid.width;
        if (typeof t2 !== "number")
          return t2.$sub();
        grid.width = t2 - 1;
        --i;
      }
      ++i;
    }
  },
  needsSubdivision: function(a, b, c) {
    var t1, cmid, lmid, delta, t2, t3, i, t4, t5, t6, x, y, z;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    cmid = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    cmid.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    lmid = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    lmid.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    delta = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    delta.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = 0;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = 0;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    for (t1 = J.getInterceptor$asx(a), t2 = J.getInterceptor$asx(c), t3 = J.getInterceptor$asx(b), i = 0; i < 3; ++i) {
      t4 = J.$add$ns(t1.$index(a, i), t2.$index(c, i));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = lmid.array;
      if (i >= t5.length)
        return H.ioore(t5, i);
      t5[i] = 0.5 * t4;
      t4 = J.$add$ns(t1.$index(a, i), t3.$index(b, i));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = J.$add$ns(t3.$index(b, i), t2.$index(c, i));
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = cmid.array;
      if (i >= t6.length)
        return H.ioore(t6, i);
      t6[i] = 0.5 * (0.5 * t4 + 0.5 * t5);
    }
    t1 = delta.array;
    t2 = cmid.$index(0, 0);
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    t1[0] = t2;
    t2 = delta.array;
    t1 = cmid.$index(0, 1);
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t2[1] = t1;
    t1 = delta.array;
    t2 = cmid.$index(0, 2);
    if (2 >= t1.length)
      return H.ioore(t1, 2);
    t1[2] = t2;
    t2 = delta.array;
    if (0 >= t2.length)
      return H.ioore(t2, 0);
    t2[0] = t2[0] - lmid.$index(0, 0);
    t2 = delta.array;
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t2[1] = t2[1] - lmid.$index(0, 1);
    t2 = delta.array;
    if (2 >= t2.length)
      return H.ioore(t2, 2);
    t2[2] = t2[2] - lmid.$index(0, 2);
    t2 = delta.array;
    t1 = t2.length;
    if (0 >= t1)
      return H.ioore(t2, 0);
    x = t2[0];
    if (1 >= t1)
      return H.ioore(t2, 1);
    y = t2[1];
    if (2 >= t1)
      return H.ioore(t2, 2);
    z = t2[2];
    return Math.sqrt(x * x + y * y + z * z) >= 16;
  },
  subdivideGridColumns: function(grid) {
    var t1, i, k, t2, i0, k0, j, t3, prev, mid, next, t4;
    t1 = grid.points;
    i = 0;
    k = null;
    while (true) {
      t2 = grid.width;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (!(i < t2 - 2))
        break;
      c$0: {
        i0 = i + 1;
        k0 = i + 2;
        j = 0;
        while (true) {
          t2 = grid.height;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t2 = J.$index$asx(t1[i], j);
          if (i0 >= t1.length)
            return H.ioore(t1, i0);
          t3 = J.$index$asx(t1[i0], j);
          if (k0 >= t1.length)
            return H.ioore(t1, k0);
          if (B.needsSubdivision(t2, t3, J.$index$asx(t1[k0], j)))
            break;
          ++j;
        }
        if (j === grid.height) {
          j = 0;
          while (true) {
            t2 = grid.height;
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(j < t2))
              break;
            k = k0;
            while (true) {
              t2 = grid.width;
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(k < t2))
                break;
              t2 = k - 1;
              if (t2 >= t1.length)
                return H.ioore(t1, t2);
              t2 = J.$index$asx(t1[t2], j);
              if (k >= t1.length)
                return H.ioore(t1, k);
              t2.set$1(J.$index$asx(t1[k], j));
              ++k;
            }
            ++j;
          }
          t2 = grid.width;
          if (typeof t2 !== "number")
            return t2.$sub();
          grid.width = t2 - 1;
          i = i0;
          break c$0;
        }
        t2 = i + 3;
        j = 0;
        while (true) {
          t3 = grid.height;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(j < t3))
            break;
          if (i >= t1.length)
            return H.ioore(t1, i);
          prev = Q.Vector$fromVector(J.$index$asx(t1[i], j));
          if (i0 >= t1.length)
            return H.ioore(t1, i0);
          mid = Q.Vector$fromVector(J.$index$asx(t1[i0], j));
          if (k0 >= t1.length)
            return H.ioore(t1, k0);
          next = Q.Vector$fromVector(J.$index$asx(t1[k0], j));
          t3 = grid.width;
          if (typeof t3 !== "number")
            return t3.$sub();
          k = t3 - 1;
          for (; k > i0; --k) {
            t3 = k + 2;
            if (t3 >= t1.length)
              return H.ioore(t1, t3);
            t3 = J.$index$asx(t1[t3], j);
            if (k >= t1.length)
              return H.ioore(t1, k);
            t3.set$1(J.$index$asx(t1[k], j));
          }
          if (i0 >= t1.length)
            return H.ioore(t1, i0);
          t3 = J.$index$asx(t1[i0], j);
          if (k0 >= t1.length)
            return H.ioore(t1, k0);
          t4 = J.$index$asx(t1[k0], j);
          if (t2 >= t1.length)
            return H.ioore(t1, t2);
          B.subdivide(prev, mid, next, t3, t4, J.$index$asx(t1[t2], j));
          ++j;
        }
        t2 = grid.width;
        if (typeof t2 !== "number")
          return t2.$add();
        grid.width = t2 + 2;
      }
    }
  },
  subdivide: function(a, b, c, out1, out2, out3) {
    var t1, t2, t3, i, t4, t5;
    for (t1 = J.getInterceptor$ax(out1), t2 = J.getInterceptor$ax(out3), t3 = J.getInterceptor$ax(out2), i = 0; i < 3; ++i) {
      t4 = a.array;
      if (i >= t4.length)
        return H.ioore(t4, i);
      t4 = t4[i];
      t5 = b.array;
      if (i >= t5.length)
        return H.ioore(t5, i);
      t1.$indexSet(out1, i, 0.5 * (t4 + t5[i]));
      t5 = b.array;
      if (i >= t5.length)
        return H.ioore(t5, i);
      t5 = t5[i];
      t4 = c.array;
      if (i >= t4.length)
        return H.ioore(t4, i);
      t2.$indexSet(out3, i, 0.5 * (t5 + t4[i]));
      t4 = J.$add$ns(t1.$index(out1, i), t2.$index(out3, i));
      if (typeof t4 !== "number")
        return H.iae(t4);
      t3.$indexSet(out2, i, 0.5 * t4);
    }
  },
  setGridWrapWidth: function(grid) {
    var t1, h, d, t2, j, t3;
    t1 = grid.points;
    h = 0;
    d = null;
    while (true) {
      t2 = grid.height;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(h < t2))
        break;
      for (j = 0; j < 3; ++j) {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = J.$index$asx(J.$index$asx(t1[0], h), j);
        t3 = grid.width;
        if (typeof t3 !== "number")
          return t3.$sub();
        --t3;
        if (t3 < 0 || t3 >= t1.length)
          return H.ioore(t1, t3);
        d = J.$sub$n(t2, J.$index$asx(J.$index$asx(t1[t3], h), j));
        t2 = J.getInterceptor$n(d);
        if (t2.$lt(d, -0.1) || t2.$gt(d, 0.1))
          break;
      }
      if (j !== 3)
        break;
      ++h;
    }
    grid.wrapWidth = h === grid.height;
  },
  getCurvePoint3: function(c0, c1, c2, dist) {
    var b, v0, v1, v2, t1, t2, t3, t4;
    b = 1 - dist;
    v0 = Q.Vector$fromList(c0.array);
    v1 = Q.Vector$fromList(c1.array);
    v2 = Q.Vector$fromList(c2.array);
    t1 = b * b;
    t2 = v0.array;
    t3 = t2.length;
    if (0 >= t3)
      return H.ioore(t2, 0);
    t2[0] = t2[0] * t1;
    if (1 >= t3)
      return H.ioore(t2, 1);
    t2[1] = t2[1] * t1;
    if (2 >= t3)
      return H.ioore(t2, 2);
    t2[2] = t2[2] * t1;
    t1 = 2 * b * dist;
    t3 = v1.array;
    t4 = t3.length;
    if (0 >= t4)
      return H.ioore(t3, 0);
    t3[0] = t3[0] * t1;
    if (1 >= t4)
      return H.ioore(t3, 1);
    t3[1] = t3[1] * t1;
    if (2 >= t4)
      return H.ioore(t3, 2);
    t3[2] = t3[2] * t1;
    t2[0] = t2[0] + t3[0];
    t2[1] = t2[1] + t3[1];
    t2[2] = t2[2] + t3[2];
    t3 = dist * dist;
    t1 = v2.array;
    t4 = t1.length;
    if (0 >= t4)
      return H.ioore(t1, 0);
    t1[0] = t1[0] * t3;
    if (1 >= t4)
      return H.ioore(t1, 1);
    t1[1] = t1[1] * t3;
    if (2 >= t4)
      return H.ioore(t1, 2);
    t1[2] = t1[2] * t3;
    t2[0] = t2[0] + t1[0];
    t2[1] = t2[1] + t1[1];
    t2[2] = t2[2] + t1[2];
    return v0;
  },
  getCurvePoint2: function(c0, c1, c2, dist) {
    var t1, t2, t3, c30, c31, c32;
    t1 = c0.array;
    t2 = t1.length;
    if (0 >= t2)
      return H.ioore(t1, 0);
    t3 = t1[0];
    if (1 >= t2)
      return H.ioore(t1, 1);
    t1 = t1[1];
    t2 = Array(4);
    t2.$builtinTypeInfo = [P.$double];
    c30 = new Q.Vector(null, null, t2);
    t2 = new Float32Array(3);
    c30.array = t2;
    if (0 >= 3)
      return H.ioore(t2, 0);
    t2[0] = t3;
    if (1 >= 3)
      return H.ioore(t2, 1);
    t2[1] = t1;
    if (2 >= 3)
      return H.ioore(t2, 2);
    t2[2] = 0;
    t2 = c1.array;
    t1 = t2.length;
    if (0 >= t1)
      return H.ioore(t2, 0);
    t3 = t2[0];
    if (1 >= t1)
      return H.ioore(t2, 1);
    t2 = t2[1];
    t1 = Array(4);
    t1.$builtinTypeInfo = [P.$double];
    c31 = new Q.Vector(null, null, t1);
    t1 = new Float32Array(3);
    c31.array = t1;
    if (0 >= 3)
      return H.ioore(t1, 0);
    t1[0] = t3;
    if (1 >= 3)
      return H.ioore(t1, 1);
    t1[1] = t2;
    if (2 >= 3)
      return H.ioore(t1, 2);
    t1[2] = 0;
    t1 = c2.array;
    t2 = t1.length;
    if (0 >= t2)
      return H.ioore(t1, 0);
    t3 = t1[0];
    if (1 >= t2)
      return H.ioore(t1, 1);
    t1 = t1[1];
    t2 = Array(4);
    t2.$builtinTypeInfo = [P.$double];
    c32 = new Q.Vector(null, null, t2);
    t2 = new Float32Array(3);
    c32.array = t2;
    if (0 >= 3)
      return H.ioore(t2, 0);
    t2[0] = t3;
    if (1 >= 3)
      return H.ioore(t2, 1);
    t2[1] = t1;
    if (2 >= 3)
      return H.ioore(t2, 2);
    t2[2] = 0;
    return B.getCurvePoint3(c30, c31, c32, dist);
  },
  tessellate: function(face, vertexes, indexes, level) {
    var off, L1, t1, t2, py, t3, px, rowOff, t4, t5, c0, t6, c1, c2, c3, c4, c5, c6, c7, c8, indexOff, i, a, t7, t8, pos, lmCoord, texCoord, t9, color, vert, pc0, pc1, pc2, tc0, tc1, tc2, lc0, lc1, lc2, cc0, cc1, cc2, j, b, row, row0, col;
    off = face.firstVert;
    L1 = level + 1;
    face.firstVert = vertexes.length;
    face.firstIndex = indexes.length;
    face.numVerts = 0;
    face.numIndexes = 0;
    t1 = level * level * 6;
    t2 = L1 * L1;
    py = 0;
    while (true) {
      t3 = face.patch_size;
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      if (!(py < t3[1] - 2))
        break;
      px = 0;
      while (true) {
        t3 = face.patch_size;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t3 = t3[0];
        if (!(px < t3 - 2))
          break;
        rowOff = py * t3;
        t4 = off + rowOff + px;
        t5 = vertexes.length;
        if (t4 >= t5)
          return H.ioore(vertexes, t4);
        c0 = vertexes[t4];
        t6 = t4 + 1;
        if (t6 >= t5)
          return H.ioore(vertexes, t6);
        c1 = vertexes[t6];
        t4 += 2;
        if (t4 >= t5)
          return H.ioore(vertexes, t4);
        c2 = vertexes[t4];
        rowOff += t3;
        t4 = off + rowOff + px;
        if (t4 >= t5)
          return H.ioore(vertexes, t4);
        c3 = vertexes[t4];
        t6 = t4 + 1;
        if (t6 >= t5)
          return H.ioore(vertexes, t6);
        c4 = vertexes[t6];
        t4 += 2;
        if (t4 >= t5)
          return H.ioore(vertexes, t4);
        c5 = vertexes[t4];
        t3 = off + (rowOff + t3) + px;
        if (t3 >= t5)
          return H.ioore(vertexes, t3);
        c6 = vertexes[t3];
        t4 = t3 + 1;
        if (t4 >= t5)
          return H.ioore(vertexes, t4);
        c7 = vertexes[t4];
        t3 += 2;
        if (t3 >= t5)
          return H.ioore(vertexes, t3);
        c8 = vertexes[t3];
        indexOff = face.numVerts;
        face.numVerts = indexOff + t2;
        for (i = 0; i < L1; ++i) {
          a = i / level;
          t3 = c0.xyz;
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t5 = c3.xyz;
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t7 = c6.xyz;
          t8 = Array(4);
          t8.$builtinTypeInfo = [P.$double];
          pos = B.getCurvePoint3(new Q.Vector(t3, null, t4), new Q.Vector(t5, null, t6), new Q.Vector(t7, null, t8), a);
          t3 = c0.lightmap;
          t4 = t3.length;
          if (0 >= t4)
            return H.ioore(t3, 0);
          t5 = t3[0];
          if (1 >= t4)
            return H.ioore(t3, 1);
          t3 = t3[1];
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t4);
          t6 = new Float32Array(3);
          t4.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t5;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t3;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = 0;
          t6 = c3.lightmap;
          t3 = t6.length;
          if (0 >= t3)
            return H.ioore(t6, 0);
          t5 = t6[0];
          if (1 >= t3)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t3 = Array(4);
          t3.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t3);
          t7 = new Float32Array(3);
          t3.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t5;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t6;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c6.lightmap;
          t6 = t7.length;
          if (0 >= t6)
            return H.ioore(t7, 0);
          t5 = t7[0];
          if (1 >= t6)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t8 = new Float32Array(3);
          t6.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t5;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          lmCoord = B.getCurvePoint2(t4, t3, t6, a);
          t6 = c0.st;
          t3 = t6.length;
          if (0 >= t3)
            return H.ioore(t6, 0);
          t4 = t6[0];
          if (1 >= t3)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t3 = Array(4);
          t3.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t3);
          t5 = new Float32Array(3);
          t3.array = t5;
          if (0 >= 3)
            return H.ioore(t5, 0);
          t5[0] = t4;
          if (1 >= 3)
            return H.ioore(t5, 1);
          t5[1] = t6;
          if (2 >= 3)
            return H.ioore(t5, 2);
          t5[2] = 0;
          t5 = c3.st;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t4 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t5 = t5[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t7 = new Float32Array(3);
          t6.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t4;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t5;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c6.st;
          t5 = t7.length;
          if (0 >= t5)
            return H.ioore(t7, 0);
          t4 = t7[0];
          if (1 >= t5)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t8 = new Float32Array(3);
          t5.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t4;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          texCoord = B.getCurvePoint2(t3, t6, t5, a);
          t5 = c0.color;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t3 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t8 = t5[1];
          if (2 >= t6)
            return H.ioore(t5, 2);
          t5 = t5[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t6);
          t6 = new Float32Array(3);
          t4.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t3;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t8;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = t5;
          t5 = c3.color;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t8 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t3 = t5[1];
          if (2 >= t6)
            return H.ioore(t5, 2);
          t5 = t5[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t7 = new Float32Array(3);
          t6.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t8;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t3;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = t5;
          t5 = c6.color;
          t7 = t5.length;
          if (0 >= t7)
            return H.ioore(t5, 0);
          t3 = t5[0];
          if (1 >= t7)
            return H.ioore(t5, 1);
          t8 = t5[1];
          if (2 >= t7)
            return H.ioore(t5, 2);
          t5 = t5[2];
          t7 = Array(4);
          t7.$builtinTypeInfo = [P.$double];
          t7 = new Q.Vector(null, null, t7);
          t9 = new Float32Array(3);
          t7.array = t9;
          if (0 >= 3)
            return H.ioore(t9, 0);
          t9[0] = t3;
          if (1 >= 3)
            return H.ioore(t9, 1);
          t9[1] = t8;
          if (2 >= 3)
            return H.ioore(t9, 2);
          t9[2] = t5;
          color = B.getCurvePoint3(t4, t6, t7, a);
          t7 = Array(4);
          t7.$builtinTypeInfo = [P.$double];
          t3 = new Float32Array(3);
          new Q.Vector(null, null, t7).array = t3;
          if (0 >= 3)
            return H.ioore(t3, 0);
          t3[0] = 0;
          if (1 >= 3)
            return H.ioore(t3, 1);
          t3[1] = 0;
          if (2 >= 3)
            return H.ioore(t3, 2);
          t3[2] = 1;
          vert = new B.Vertex(null, null, null, null, null);
          vert.xyz = pos.array;
          vert.st = texCoord.array;
          vert.lightmap = lmCoord.array;
          vert.normal = t3;
          vert.color = color.array;
          vertexes.push(vert);
        }
        for (i = 1; i < L1; ++i) {
          a = i / level;
          t3 = c0.xyz;
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t5 = c1.xyz;
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t7 = c2.xyz;
          t8 = Array(4);
          t8.$builtinTypeInfo = [P.$double];
          pc0 = B.getCurvePoint3(new Q.Vector(t3, null, t4), new Q.Vector(t5, null, t6), new Q.Vector(t7, null, t8), a);
          t3 = c3.xyz;
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t5 = c4.xyz;
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t7 = c5.xyz;
          t8 = Array(4);
          t8.$builtinTypeInfo = [P.$double];
          pc1 = B.getCurvePoint3(new Q.Vector(t3, null, t4), new Q.Vector(t5, null, t6), new Q.Vector(t7, null, t8), a);
          t3 = c6.xyz;
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t5 = c7.xyz;
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t7 = c8.xyz;
          t8 = Array(4);
          t8.$builtinTypeInfo = [P.$double];
          pc2 = B.getCurvePoint3(new Q.Vector(t3, null, t4), new Q.Vector(t5, null, t6), new Q.Vector(t7, null, t8), a);
          t3 = c0.st;
          t4 = t3.length;
          if (0 >= t4)
            return H.ioore(t3, 0);
          t5 = t3[0];
          if (1 >= t4)
            return H.ioore(t3, 1);
          t3 = t3[1];
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t4);
          t6 = new Float32Array(3);
          t4.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t5;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t3;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = 0;
          t6 = c1.st;
          t3 = t6.length;
          if (0 >= t3)
            return H.ioore(t6, 0);
          t5 = t6[0];
          if (1 >= t3)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t3 = Array(4);
          t3.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t3);
          t7 = new Float32Array(3);
          t3.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t5;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t6;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c2.st;
          t6 = t7.length;
          if (0 >= t6)
            return H.ioore(t7, 0);
          t5 = t7[0];
          if (1 >= t6)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t8 = new Float32Array(3);
          t6.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t5;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          tc0 = B.getCurvePoint3(t4, t3, t6, a);
          t6 = c3.st;
          t3 = t6.length;
          if (0 >= t3)
            return H.ioore(t6, 0);
          t4 = t6[0];
          if (1 >= t3)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t3 = Array(4);
          t3.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t3);
          t5 = new Float32Array(3);
          t3.array = t5;
          if (0 >= 3)
            return H.ioore(t5, 0);
          t5[0] = t4;
          if (1 >= 3)
            return H.ioore(t5, 1);
          t5[1] = t6;
          if (2 >= 3)
            return H.ioore(t5, 2);
          t5[2] = 0;
          t5 = c4.st;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t4 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t5 = t5[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t7 = new Float32Array(3);
          t6.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t4;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t5;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c5.st;
          t5 = t7.length;
          if (0 >= t5)
            return H.ioore(t7, 0);
          t4 = t7[0];
          if (1 >= t5)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t8 = new Float32Array(3);
          t5.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t4;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          tc1 = B.getCurvePoint3(t3, t6, t5, a);
          t5 = c6.st;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t3 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t5 = t5[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t6);
          t6 = new Float32Array(3);
          t4.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t3;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t5;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = 0;
          t6 = c7.st;
          t5 = t6.length;
          if (0 >= t5)
            return H.ioore(t6, 0);
          t3 = t6[0];
          if (1 >= t5)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t7 = new Float32Array(3);
          t5.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t3;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t6;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c8.st;
          t6 = t7.length;
          if (0 >= t6)
            return H.ioore(t7, 0);
          t3 = t7[0];
          if (1 >= t6)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t8 = new Float32Array(3);
          t6.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t3;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          tc2 = B.getCurvePoint3(t4, t5, t6, a);
          t6 = c0.lightmap;
          t5 = t6.length;
          if (0 >= t5)
            return H.ioore(t6, 0);
          t4 = t6[0];
          if (1 >= t5)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t5);
          t5 = new Float32Array(3);
          t3.array = t5;
          if (0 >= 3)
            return H.ioore(t5, 0);
          t5[0] = t4;
          if (1 >= 3)
            return H.ioore(t5, 1);
          t5[1] = t6;
          if (2 >= 3)
            return H.ioore(t5, 2);
          t5[2] = 0;
          t5 = c1.lightmap;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t4 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t5 = t5[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t7 = new Float32Array(3);
          t6.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t4;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t5;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c2.lightmap;
          t5 = t7.length;
          if (0 >= t5)
            return H.ioore(t7, 0);
          t4 = t7[0];
          if (1 >= t5)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t8 = new Float32Array(3);
          t5.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t4;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          lc0 = B.getCurvePoint3(t3, t6, t5, a);
          t5 = c3.lightmap;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t3 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t5 = t5[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t6);
          t6 = new Float32Array(3);
          t4.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t3;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t5;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = 0;
          t6 = c4.lightmap;
          t5 = t6.length;
          if (0 >= t5)
            return H.ioore(t6, 0);
          t3 = t6[0];
          if (1 >= t5)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t7 = new Float32Array(3);
          t5.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t3;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t6;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c5.lightmap;
          t6 = t7.length;
          if (0 >= t6)
            return H.ioore(t7, 0);
          t3 = t7[0];
          if (1 >= t6)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t8 = new Float32Array(3);
          t6.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t3;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          lc1 = B.getCurvePoint3(t4, t5, t6, a);
          t6 = c6.lightmap;
          t5 = t6.length;
          if (0 >= t5)
            return H.ioore(t6, 0);
          t4 = t6[0];
          if (1 >= t5)
            return H.ioore(t6, 1);
          t6 = t6[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t5);
          t5 = new Float32Array(3);
          t3.array = t5;
          if (0 >= 3)
            return H.ioore(t5, 0);
          t5[0] = t4;
          if (1 >= 3)
            return H.ioore(t5, 1);
          t5[1] = t6;
          if (2 >= 3)
            return H.ioore(t5, 2);
          t5[2] = 0;
          t5 = c7.lightmap;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t4 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t5 = t5[1];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t7 = new Float32Array(3);
          t6.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t4;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t5;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = 0;
          t7 = c8.lightmap;
          t5 = t7.length;
          if (0 >= t5)
            return H.ioore(t7, 0);
          t4 = t7[0];
          if (1 >= t5)
            return H.ioore(t7, 1);
          t7 = t7[1];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t8 = new Float32Array(3);
          t5.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t4;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t7;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = 0;
          lc2 = B.getCurvePoint3(t3, t6, t5, a);
          t5 = c0.color;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t3 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t8 = t5[1];
          if (2 >= t6)
            return H.ioore(t5, 2);
          t5 = t5[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t6);
          t6 = new Float32Array(3);
          t4.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t3;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t8;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = t5;
          t5 = c1.color;
          t6 = t5.length;
          if (0 >= t6)
            return H.ioore(t5, 0);
          t8 = t5[0];
          if (1 >= t6)
            return H.ioore(t5, 1);
          t3 = t5[1];
          if (2 >= t6)
            return H.ioore(t5, 2);
          t5 = t5[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t7 = new Float32Array(3);
          t6.array = t7;
          if (0 >= 3)
            return H.ioore(t7, 0);
          t7[0] = t8;
          if (1 >= 3)
            return H.ioore(t7, 1);
          t7[1] = t3;
          if (2 >= 3)
            return H.ioore(t7, 2);
          t7[2] = t5;
          t5 = c2.color;
          t7 = t5.length;
          if (0 >= t7)
            return H.ioore(t5, 0);
          t3 = t5[0];
          if (1 >= t7)
            return H.ioore(t5, 1);
          t8 = t5[1];
          if (2 >= t7)
            return H.ioore(t5, 2);
          t5 = t5[2];
          t7 = Array(4);
          t7.$builtinTypeInfo = [P.$double];
          t7 = new Q.Vector(null, null, t7);
          t9 = new Float32Array(3);
          t7.array = t9;
          if (0 >= 3)
            return H.ioore(t9, 0);
          t9[0] = t3;
          if (1 >= 3)
            return H.ioore(t9, 1);
          t9[1] = t8;
          if (2 >= 3)
            return H.ioore(t9, 2);
          t9[2] = t5;
          cc0 = B.getCurvePoint3(t4, t6, t7, a);
          t7 = c3.color;
          t6 = t7.length;
          if (0 >= t6)
            return H.ioore(t7, 0);
          t4 = t7[0];
          if (1 >= t6)
            return H.ioore(t7, 1);
          t5 = t7[1];
          if (2 >= t6)
            return H.ioore(t7, 2);
          t7 = t7[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(null, null, t6);
          t6 = new Float32Array(3);
          t3.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t4;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t5;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = t7;
          t7 = c4.color;
          t6 = t7.length;
          if (0 >= t6)
            return H.ioore(t7, 0);
          t5 = t7[0];
          if (1 >= t6)
            return H.ioore(t7, 1);
          t4 = t7[1];
          if (2 >= t6)
            return H.ioore(t7, 2);
          t7 = t7[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t8 = new Float32Array(3);
          t6.array = t8;
          if (0 >= 3)
            return H.ioore(t8, 0);
          t8[0] = t5;
          if (1 >= 3)
            return H.ioore(t8, 1);
          t8[1] = t4;
          if (2 >= 3)
            return H.ioore(t8, 2);
          t8[2] = t7;
          t7 = c5.color;
          t8 = t7.length;
          if (0 >= t8)
            return H.ioore(t7, 0);
          t4 = t7[0];
          if (1 >= t8)
            return H.ioore(t7, 1);
          t5 = t7[1];
          if (2 >= t8)
            return H.ioore(t7, 2);
          t7 = t7[2];
          t8 = Array(4);
          t8.$builtinTypeInfo = [P.$double];
          t8 = new Q.Vector(null, null, t8);
          t9 = new Float32Array(3);
          t8.array = t9;
          if (0 >= 3)
            return H.ioore(t9, 0);
          t9[0] = t4;
          if (1 >= 3)
            return H.ioore(t9, 1);
          t9[1] = t5;
          if (2 >= 3)
            return H.ioore(t9, 2);
          t9[2] = t7;
          cc1 = B.getCurvePoint3(t3, t6, t8, a);
          t8 = c6.color;
          t6 = t8.length;
          if (0 >= t6)
            return H.ioore(t8, 0);
          t3 = t8[0];
          if (1 >= t6)
            return H.ioore(t8, 1);
          t7 = t8[1];
          if (2 >= t6)
            return H.ioore(t8, 2);
          t8 = t8[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t4 = new Q.Vector(null, null, t6);
          t5 = new Float32Array(3);
          t4.array = t5;
          if (0 >= 3)
            return H.ioore(t5, 0);
          t5[0] = t3;
          if (1 >= 3)
            return H.ioore(t5, 1);
          t5[1] = t7;
          if (2 >= 3)
            return H.ioore(t5, 2);
          t5[2] = t8;
          t8 = c7.color;
          t5 = t8.length;
          if (0 >= t5)
            return H.ioore(t8, 0);
          t7 = t8[0];
          if (1 >= t5)
            return H.ioore(t8, 1);
          t3 = t8[1];
          if (2 >= t5)
            return H.ioore(t8, 2);
          t8 = t8[2];
          t5 = Array(4);
          t5.$builtinTypeInfo = [P.$double];
          t5 = new Q.Vector(null, null, t5);
          t6 = new Float32Array(3);
          t5.array = t6;
          if (0 >= 3)
            return H.ioore(t6, 0);
          t6[0] = t7;
          if (1 >= 3)
            return H.ioore(t6, 1);
          t6[1] = t3;
          if (2 >= 3)
            return H.ioore(t6, 2);
          t6[2] = t8;
          t8 = c8.color;
          t6 = t8.length;
          if (0 >= t6)
            return H.ioore(t8, 0);
          t3 = t8[0];
          if (1 >= t6)
            return H.ioore(t8, 1);
          t7 = t8[1];
          if (2 >= t6)
            return H.ioore(t8, 2);
          t8 = t8[2];
          t6 = Array(4);
          t6.$builtinTypeInfo = [P.$double];
          t6 = new Q.Vector(null, null, t6);
          t9 = new Float32Array(3);
          t6.array = t9;
          if (0 >= 3)
            return H.ioore(t9, 0);
          t9[0] = t3;
          if (1 >= 3)
            return H.ioore(t9, 1);
          t9[1] = t7;
          if (2 >= 3)
            return H.ioore(t9, 2);
          t9[2] = t8;
          cc2 = B.getCurvePoint3(t4, t5, t6, a);
          for (j = 0; j < L1; ++j) {
            b = j / level;
            pos = B.getCurvePoint3(pc0, pc1, pc2, b);
            texCoord = B.getCurvePoint2(tc0, tc1, tc2, b);
            lmCoord = B.getCurvePoint2(lc0, lc1, lc2, b);
            color = B.getCurvePoint3(cc0, cc1, cc2, a);
            t3 = Array(4);
            t3.$builtinTypeInfo = [P.$double];
            t4 = new Float32Array(3);
            new Q.Vector(null, null, t3).array = t4;
            if (0 >= 3)
              return H.ioore(t4, 0);
            t4[0] = 0;
            if (1 >= 3)
              return H.ioore(t4, 1);
            t4[1] = 0;
            if (2 >= 3)
              return H.ioore(t4, 2);
            t4[2] = 1;
            vert = new B.Vertex(null, null, null, null, null);
            vert.xyz = pos.array;
            vert.st = texCoord.array;
            vert.lightmap = lmCoord.array;
            vert.normal = t4;
            vert.color = color.array;
            vertexes.push(vert);
          }
        }
        face.numIndexes += t1;
        for (row = 0; row < level; row = row0)
          for (row0 = row + 1, t3 = indexOff + row0 * L1, t4 = indexOff + row * L1, col = 0; col < level;) {
            t5 = t3 + col;
            indexes.push(t5);
            indexes.push(t4 + col);
            ++col;
            t6 = t4 + col;
            indexes.push(t6);
            indexes.push(t5);
            indexes.push(t6);
            indexes.push(t3 + col);
          }
        px += 2;
      }
      py += 2;
    }
  },
  BSPParser: {
    "^": "Object;header,bb,bytes",
    getLump$1: function(type) {
      var t1, t2, t3, offset, $length;
      t1 = this.header;
      t2 = 2 + type * 2;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      offset = t1[t2];
      ++t2;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      $length = t1[t2];
      P.print("getLump: " + type + " " + offset + " " + $length);
      t2 = new B.BinaryReader(offset, $length, null, 0);
      t2.dv = J.asByteData$2$x(this.bb, offset, $length);
      return t2;
    },
    getSurfaces$0: function() {
      var br, surfaces, t1, i, t2;
      br = this.getLump$1(13);
      surfaces = H.setRuntimeTypeInfo(Array(C.JSInt_methods._tdivFast$1(br.length, 104)), [B.Surface]);
      t1 = surfaces.length;
      P.print("surfaces.length " + C.JSInt_methods.toString$0(t1));
      for (i = 0; i < t1; ++i) {
        t2 = new B.Surface(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        t2.Surface$1(br);
        surfaces[i] = t2;
      }
      return surfaces;
    },
    getDrawVerts$0: function() {
      var br, $length, vertexes, i, t1;
      br = this.getLump$1(10);
      $length = C.JSInt_methods._tdivFast$1(br.length, 44);
      vertexes = H.setRuntimeTypeInfo([], [B.Vertex]);
      for (i = 0; i < $length; ++i) {
        t1 = new B.Vertex(null, null, null, null, null);
        t1.Vertex$1(br);
        vertexes.push(t1);
      }
      return vertexes;
    },
    getDrawIndexes$0: function() {
      var br, $length, drawIndexes, i, t1;
      br = this.getLump$1(11);
      $length = C.JSInt_methods._tdivFast$1(br.length, 4);
      drawIndexes = H.setRuntimeTypeInfo([], [P.$int]);
      for (i = 0; i < $length; ++i) {
        t1 = br.pos += 4;
        drawIndexes.push(br.dv.getUint32(t1 - 4, true));
      }
      return drawIndexes;
    },
    getShaders$0: function() {
      var br, t1, shaders, t2, i, t3, t4, data, $name;
      br = this.getLump$1(1);
      t1 = br.length;
      shaders = H.setRuntimeTypeInfo(Array(C.JSInt_methods._tdivFast$1(t1, 72)), [B.Shader]);
      t2 = shaders.length;
      P.print("shaders.length " + C.JSInt_methods.toString$0(t2));
      P.print(t1);
      P.print(72);
      for (i = 0; i < t2; ++i) {
        t1 = br.dv;
        t3 = t1.buffer;
        t1 = t1.byteOffset;
        t4 = br.pos;
        if (typeof t1 !== "number")
          return t1.$add();
        t4 = t1 + t4;
        t3.toString;
        H._checkViewArguments(t3, t4, 64);
        data = new Uint8Array(t3, t4, 64);
        br.pos += 64;
        $name = P.String_String$fromCharCodes(data, 0, null);
        if (C.JSString_methods.indexOf$1($name, "\u0000") >= 0)
          $name = C.JSString_methods.substring$2($name, 0, C.JSString_methods.indexOf$1($name, "\u0000"));
        t1 = br.pos += 4;
        t1 = br.dv.getUint32(t1 - 4, true);
        t3 = br.pos += 4;
        shaders[i] = new B.Shader($name, t1, br.dv.getUint32(t3 - 4, true));
      }
      return shaders;
    },
    getClipMap$0: function() {
      var cm, t1, surface;
      cm = new B.ClipMap(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0);
      cm.shaders = this.getShaders$0();
      t1 = this.getSurfaces$0();
      cm.surfaces = t1;
      cm.surfacesUntessellated = P.List_List$generate(t1.length, new B.BSPParser_getClipMap_closure(cm), true, B.Surface);
      cm.drawVerts = this.getDrawVerts$0();
      cm.drawIndexes = this.getDrawIndexes$0();
      for (t1 = cm.surfaces, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
        surface = t1.__internal$_current;
        if (surface.get$surfaceType() === $.Surface_patch)
          B.tessellate(surface, cm.drawVerts, cm.drawIndexes, 20);
      }
      cm.nodes = B.BSPNode_parse(this.getLump$1(3));
      cm.planes = B.Plane_parse(this.getLump$1(2));
      cm.leafs = B.Leaf_parse(this.getLump$1(4));
      t1 = this.getLump$1(5);
      cm.leafSurfaces = t1.readSignedInt$1(C.JSInt_methods._tdivFast$1(t1.length, 4));
      t1 = this.getLump$1(6);
      cm.leafBrushes = t1.readSignedInt$1(C.JSInt_methods._tdivFast$1(t1.length, 4));
      cm.brushes = B.Brush_parse(this.getLump$1(8));
      cm.brushSides = B.Brushside_parse(this.getLump$1(9));
      cm.models = B.Model_parse(this.getLump$1(7));
      return cm;
    },
    BSPParser$1: function(bb) {
      this.header = J.asInt32List$2$x(bb, 0, 36);
      this.bb = bb;
    }
  },
  BSPParser_getClipMap_closure: {
    "^": "Closure:11;cm_0",
    call$1: function(idx) {
      var t1, t2;
      t1 = this.cm_0.surfaces;
      if (idx >= t1.length)
        return H.ioore(t1, idx);
      t2 = new B.Surface(null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t2.Surface$copy$1(t1[idx]);
      return t2;
    }
  },
  BinaryReader: {
    "^": "Object;offset,length>,dv,pos",
    readFloat$1: function(i) {
      var t1, buf, j, t2;
      t1 = H._checkLength(i);
      buf = new Float32Array(t1);
      for (j = 0; j < t1; ++j) {
        t2 = this.pos += 4;
        buf[j] = this.dv.getFloat32(t2 - 4, true);
      }
      return buf;
    },
    readBytes$1: function(i) {
      var t1, t2, t3, data;
      t1 = this.dv;
      t2 = t1.buffer;
      t1 = t1.byteOffset;
      t3 = this.pos;
      if (typeof t1 !== "number")
        return t1.$add();
      t2.toString;
      data = H.NativeUint8List_NativeUint8List$view(t2, t1 + t3, i);
      this.pos += i;
      return data;
    },
    readOneInt$0: function() {
      var t1 = this.pos += 4;
      return this.dv.getUint32(t1 - 4, true);
    },
    readInt$1: function(i) {
      var t1, buf, j, t2;
      t1 = H._checkLength(i);
      buf = new Uint32Array(t1);
      for (j = 0; j < t1; ++j) {
        t2 = this.pos += 4;
        buf[j] = this.dv.getUint32(t2 - 4, true);
      }
      return buf;
    },
    readOneSignedInt$0: function() {
      var t1 = this.pos += 4;
      return this.dv.getInt32(t1 - 4, true);
    },
    readSignedInt$1: function(i) {
      var t1, buf, j, t2;
      t1 = H._checkLength(i);
      buf = new Int32Array(t1);
      for (j = 0; j < t1; ++j) {
        t2 = this.pos += 4;
        buf[j] = this.dv.getInt32(t2 - 4, true);
      }
      return buf;
    }
  },
  Brush: {
    "^": "Object;firstSide,numSides,shaderNum<",
    static: {Brush_parse: function(br) {
        var brushes, t1, i, t2, t3;
        brushes = H.setRuntimeTypeInfo(Array(C.JSInt_methods._tdivFast$1(br.length, 12)), [B.Brush]);
        for (t1 = brushes.length, i = 0; i < t1; ++i) {
          t2 = new B.Brush(null, null, null);
          t3 = br.pos += 4;
          t2.firstSide = br.dv.getInt32(t3 - 4, true);
          t3 = br.pos += 4;
          t2.numSides = br.dv.getInt32(t3 - 4, true);
          t3 = br.pos += 4;
          t2.shaderNum = br.dv.getInt32(t3 - 4, true);
          brushes[i] = t2;
        }
        return brushes;
      }}
  },
  Brushside: {
    "^": "Object;planeNum,shaderNum<",
    static: {Brushside_parse: function(br) {
        var count, brushSides, t1, i, t2, t3;
        count = C.JSInt_methods._tdivFast$1(br.length, 8);
        brushSides = H.setRuntimeTypeInfo(Array(count), [B.Brushside]);
        for (t1 = brushSides.length, i = 0; i < count; ++i) {
          t2 = new B.Brushside(null, null);
          t3 = br.pos += 4;
          t2.planeNum = br.dv.getInt32(t3 - 4, true);
          t3 = br.pos += 4;
          t2.shaderNum = br.dv.getInt32(t3 - 4, true);
          if (i >= t1)
            return H.ioore(brushSides, i);
          brushSides[i] = t2;
        }
        return brushSides;
      }}
  },
  BSPNode: {
    "^": "Object;planeNum,children,mins,maxs",
    static: {BSPNode_parse: function(br) {
        var count, nodes, t1, i, t2, t3;
        count = C.JSInt_methods._tdivFast$1(br.length, 36);
        nodes = H.setRuntimeTypeInfo(Array(count), [B.BSPNode]);
        for (t1 = nodes.length, i = 0; i < count; ++i) {
          t2 = new B.BSPNode(null, null, null, null);
          t3 = br.pos += 4;
          t2.planeNum = br.dv.getInt32(t3 - 4, true);
          t2.children = br.readSignedInt$1(2);
          t2.mins = br.readSignedInt$1(3);
          t2.maxs = br.readSignedInt$1(3);
          if (i >= t1)
            return H.ioore(nodes, i);
          nodes[i] = t2;
        }
        return nodes;
      }}
  },
  ClipMap: {
    "^": "Object;entities,shaders,planes,nodes,leafs,leafSurfaces,leafBrushes,models,brushes,brushSides,drawVerts,drawIndexes,fogs,surfaces,surfacesUntessellated,lightmaps,lightGrid,visibility,checkcount"
  },
  Wrapper: {
    "^": "Object;value"
  },
  vectorList_closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return Q.Vector$(0, 0, 0);
    }
  },
  Leaf: {
    "^": "Object;cluster,area,mins,maxs,firstLeafSurface,numLeafSurfaces,firstLeafBrush,numLeafBrushes",
    Leaf$1: function(br) {
      this.cluster = br.readOneSignedInt$0();
      this.area = br.readOneSignedInt$0();
      this.mins = br.readSignedInt$1(3);
      this.maxs = br.readSignedInt$1(3);
      this.firstLeafSurface = br.readOneSignedInt$0();
      this.numLeafSurfaces = br.readOneSignedInt$0();
      this.firstLeafBrush = br.readOneSignedInt$0();
      this.numLeafBrushes = br.readOneSignedInt$0();
    },
    static: {Leaf_parse: function(br) {
        var count, leafs, t1, i, t2;
        count = C.JSInt_methods._tdivFast$1(br.length, 48);
        leafs = H.setRuntimeTypeInfo(Array(count), [B.Leaf]);
        for (t1 = leafs.length, i = 0; i < count; ++i) {
          t2 = new B.Leaf(null, null, null, null, null, null, null, null);
          t2.Leaf$1(br);
          if (i >= t1)
            return H.ioore(leafs, i);
          leafs[i] = t2;
        }
        return leafs;
      }}
  },
  Model: {
    "^": "Object;mins,maxs,face,numFaces,brush,numBrushes",
    Model$1: function(br) {
      this.mins = new Q.Vector(br.readFloat$1(3), null, H.setRuntimeTypeInfo(Array(4), [P.$double]));
      this.maxs = new Q.Vector(br.readFloat$1(3), null, H.setRuntimeTypeInfo(Array(4), [P.$double]));
      this.face = br.readOneSignedInt$0();
      this.numFaces = br.readOneSignedInt$0();
      this.brush = br.readOneSignedInt$0();
      this.numBrushes = br.readOneSignedInt$0();
    },
    static: {Model_parse: function(br) {
        var models, t1, i, t2;
        models = H.setRuntimeTypeInfo(Array(C.JSInt_methods._tdivFast$1(br.length, 40)), [B.Model]);
        for (t1 = models.length, i = 0; i < t1; ++i) {
          t2 = new B.Model(null, null, null, null, null, null);
          t2.Model$1(br);
          models[i] = t2;
        }
        return models;
      }}
  },
  closure1: {
    "^": "Closure:8;",
    call$1: function(idx) {
      var t1 = Array(4);
      t1.fixed$length = init;
      return new B.PatchPlane(H.setRuntimeTypeInfo(t1, [P.$double]), null);
    }
  },
  Grid: {
    "^": "Object;width,height,wrapWidth,wrapHeight,points",
    toString$0: function(_) {
      var sb, t1, i, t2, j, str;
      sb = P.StringBuffer$("");
      sb.write$1(0, "width: " + H.S(this.width) + ", height: " + H.S(this.height) + ", " + H.S(this.wrapWidth) + ", " + H.S(this.wrapHeight) + "\n");
      t1 = this.points;
      i = 0;
      while (true) {
        t2 = this.width;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        j = 0;
        while (true) {
          t2 = this.height;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(j < t2))
            break;
          if (i >= t1.length)
            return H.ioore(t1, i);
          str = J.$index$asx(t1[i], j);
          t2 = sb._contents += typeof str === "string" ? str : H.S(str);
          sb._contents = t2 + ",";
          ++j;
        }
        sb._contents += "\n";
        ++i;
      }
      t1 = sb._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  },
  closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return P.List_List$generate(129, new B._closure(), true, Q.Vector);
    }
  },
  _closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return Q.Vector$(0, 0, 0);
    }
  },
  Winding: {
    "^": "Object;numpoints,p",
    Winding$1: function(maxpts) {
      this.p = P.List_List$generate(maxpts, new B.Winding_closure(), true, Q.Vector);
    },
    static: {Winding$: function(maxpts) {
        var t1 = new B.Winding(0, null);
        t1.Winding$1(maxpts);
        return t1;
      }}
  },
  Winding_closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return Q.Vector$(0, 0, 0);
    }
  },
  PatchPlane: {
    "^": "Object;plane<,signbits@"
  },
  Facet: {
    "^": "Object;_surfacePlane,numBorders,borderPlanes,borderInward,borderNoAdjust"
  },
  PatchCollide: {
    "^": "Object;bounds,numPlanes,planes,numFacets,facets"
  },
  closure0: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return Q.Vector$(0, 0, 0);
    }
  },
  Patch: {
    "^": "Object;checkcount,surfaceFlags,contents,pc"
  },
  patchCollideFromGrid_closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return P.List_List$generate(129, new B.patchCollideFromGrid__closure(), true, [P.List, P.$int]);
    }
  },
  patchCollideFromGrid__closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      var t1 = Array(2);
      t1.fixed$length = init;
      return H.setRuntimeTypeInfo(t1, [P.$int]);
    }
  },
  CopyWinding_closure: {
    "^": "Closure:11;w_0",
    call$1: function(idx) {
      var t1 = this.w_0.p;
      if (idx >= t1.length)
        return H.ioore(t1, idx);
      return Q.Vector$fromVector(t1[idx]);
    }
  },
  validateFacet_closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return Q.Vector$(0, 0, 0);
    }
  },
  setBorderInward_closure: {
    "^": "Closure:8;",
    call$1: function(idx) {
      return Q.Vector$(0, 0, 0);
    }
  },
  Plane: {
    "^": "Object;normal,dist,type,signbits@",
    setTypeAndSignbits$0: function() {
      var t1, t2;
      t1 = this.normal.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      if (t1[0] === 1)
        t2 = 0;
      else {
        if (1 >= t2)
          return H.ioore(t1, 1);
        if (t1[1] === 1)
          t2 = 1;
        else {
          if (2 >= t2)
            return H.ioore(t1, 2);
          t2 = t1[2] === 1 ? 2 : 3;
        }
      }
      this.type = t2;
      this.signbits = B.signbitsForNormal(t1);
    },
    Plane$2: function(normal, dist) {
      if (this.normal == null)
        this.normal = Q.Vector$(0, 0, 0);
      if (this.dist == null)
        this.dist = 0;
      this.setTypeAndSignbits$0();
    },
    static: {Plane$: function(normal, dist) {
        var t1 = new B.Plane(normal, dist, null, null);
        t1.Plane$2(normal, dist);
        return t1;
      }, Plane_parse: function(br) {
        var count, planes, t1, i, t2, t3, t4;
        count = C.JSInt_methods._tdivFast$1(br.length, 16);
        planes = H.setRuntimeTypeInfo(Array(count), [B.Plane]);
        for (t1 = planes.length, i = 0; i < count; ++i) {
          t2 = new B.Plane(null, null, null, null);
          t3 = br.readFloat$1(3);
          t4 = Array(4);
          t4.$builtinTypeInfo = [P.$double];
          t3 = new Q.Vector(t3, null, t4);
          t2.normal = t3;
          t4 = br.pos += 4;
          t2.dist = br.dv.getFloat32(t4 - 4, true);
          t3 = t3.array;
          t4 = t3.length;
          if (0 >= t4)
            return H.ioore(t3, 0);
          if (t3[0] === 1)
            t4 = 0;
          else {
            if (1 >= t4)
              return H.ioore(t3, 1);
            if (t3[1] === 1)
              t4 = 1;
            else {
              if (2 >= t4)
                return H.ioore(t3, 2);
              t4 = t3[2] === 1 ? 2 : 3;
            }
          }
          t2.type = t4;
          t2.signbits = B.signbitsForNormal(t3);
          if (i >= t1)
            return H.ioore(planes, i);
          planes[i] = t2;
        }
        return planes;
      }}
  },
  Shader: {
    "^": "Object;shader,surfaceFlags,contentFlags",
    static: {"^": "Shader_size"}
  },
  Surface: {
    "^": "Object;shaderNum<,fogNum,surfaceType<,firstVert,numVerts,firstIndex,numIndexes<,lightmapNum,lm_start,lm_size,lightmapOrigin,lightmapVecs,patch_size,patchRef<",
    Surface$copy$1: function(s) {
      this.shaderNum = s.shaderNum;
      this.fogNum = s.fogNum;
      this.surfaceType = s.surfaceType;
      this.firstVert = s.firstVert;
      this.numVerts = s.numVerts;
      this.firstIndex = s.firstIndex;
      this.numIndexes = s.numIndexes;
      this.lightmapNum = s.lightmapNum;
      this.lm_start = s.lm_start;
      this.lm_size = s.lm_size;
      this.lightmapOrigin = s.lightmapOrigin;
      this.lightmapVecs = s.lightmapVecs;
      this.patch_size = s.patch_size;
    },
    Surface$1: function(br) {
      this.shaderNum = br.readOneInt$0();
      this.fogNum = br.readOneInt$0();
      this.surfaceType = br.readOneInt$0();
      this.firstVert = br.readOneInt$0();
      this.numVerts = br.readOneInt$0();
      this.firstIndex = br.readOneInt$0();
      this.numIndexes = br.readOneInt$0();
      this.lightmapNum = br.readOneInt$0();
      this.lm_start = br.readInt$1(2);
      this.lm_size = br.readInt$1(2);
      this.lightmapOrigin = br.readFloat$1(3);
      this.lightmapVecs = br.readFloat$1(9);
      this.patch_size = br.readInt$1(2);
    },
    static: {"^": "Surface_polygon,Surface_patch,Surface_mesh,Surface_billboard,Surface_size"}
  },
  Vertex: {
    "^": "Object;xyz<,st,lightmap,normal,color",
    Vertex$1: function(br) {
      var c, t1, t2, t3, t4;
      this.xyz = br.readFloat$1(3);
      this.st = br.readFloat$1(2);
      this.lightmap = br.readFloat$1(2);
      this.normal = br.readFloat$1(3);
      this.color = new Float32Array(H._checkLength(3));
      c = br.readBytes$1(4);
      t1 = this.color;
      t2 = c.length;
      if (0 >= t2)
        return H.ioore(c, 0);
      t3 = c[0];
      t4 = t1.length;
      if (0 >= t4)
        return H.ioore(t1, 0);
      t1[0] = t3 / 255;
      if (1 >= t2)
        return H.ioore(c, 1);
      t3 = c[1];
      if (1 >= t4)
        return H.ioore(t1, 1);
      t1[1] = t3 / 255;
      if (2 >= t2)
        return H.ioore(c, 2);
      t2 = c[2];
      if (2 >= t4)
        return H.ioore(t1, 2);
      t1[2] = t2 / 255;
    },
    static: {"^": "Vertex_size"}
  }
}],
["chronosal", "package:chronosal/chronosal.dart", , E, {
  "^": "",
  ChronosAL: {
    "^": "Object;context,gainNode,sounds",
    loadSound$2: function(url, alias) {
      var hr, t1;
      hr = new XMLHttpRequest();
      hr.responseType = "arraybuffer";
      C.HttpRequest_methods.open$2(hr, "GET", url);
      t1 = H.setRuntimeTypeInfo(new W._EventStream(hr, "loadend", false), [null]);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new E.ChronosAL_loadSound_closure(this, alias, hr)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      hr.send("");
    },
    playSound$1: function(alias) {
      var t1, source;
      t1 = this.sounds;
      if (t1.$index(0, alias) == null)
        return;
      source = this.context.createBufferSource();
      source.buffer = t1.$index(0, alias);
      source.connect(this.gainNode, 0, 0);
      if (!!source.start)
        source.start(0);
      else
        source.noteOn(0);
    },
    ChronosAL$1: function(volume) {
      var t1 = new (window.AudioContext || window.webkitAudioContext)();
      this.context = t1;
      t1 = J.createGain$0$x(t1);
      this.gainNode = t1;
      t1.gain.value = volume;
      t1.connect(this.context.destination, 0, 0);
    }
  },
  ChronosAL_loadSound_closure: {
    "^": "Closure:8;this_0,alias_1,hr_2",
    call$1: function(e) {
      var audioData, t1;
      audioData = H.interceptedTypeCast(W._convertNativeToDart_XHR_Response(this.hr_2.response), "$isByteBuffer");
      t1 = this.this_0;
      J.decodeAudioData$1$x(t1.context, audioData).then$1(new E.ChronosAL_loadSound__closure(t1, this.alias_1));
    }
  },
  ChronosAL_loadSound__closure: {
    "^": "Closure:12;this_3,alias_4",
    call$1: function(audioBuffer) {
      this.this_3.sounds.$indexSet(0, this.alias_4, audioBuffer);
    }
  }
}],
["chronosgl", "package:chronosgl/chronosgl.dart", , B, {
  "^": "",
  setUpCapture: function() {
    var t1 = H.setRuntimeTypeInfo(new W._EventStream(document, "keydown", false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.setUpCapture_closure()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    t1 = H.setRuntimeTypeInfo(new W._EventStream(document, "keyup", false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.setUpCapture_closure0()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    if (!$.skipDefaultMouseMoveListener) {
      t1 = H.setRuntimeTypeInfo(new W._EventStream(document, "mousemove", false), [null]);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.setUpCapture_closure1()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    }
    t1 = H.setRuntimeTypeInfo(new W._EventStream(document, "mousedown", false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.setUpCapture_closure2()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    t1 = H.setRuntimeTypeInfo(new W._EventStream(document, "contextmenu", false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.setUpCapture_closure3()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    t1 = H.setRuntimeTypeInfo(new W._EventStream(document, "mouseup", false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.setUpCapture_closure4()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
  },
  checkLineBox: function(B1, B2, L1, L2, Hit) {
    var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, d;
    t1 = L2.array;
    t2 = t1.length;
    if (0 >= t2)
      return H.ioore(t1, 0);
    t3 = t1[0];
    t4 = B1.array;
    t5 = t4.length;
    if (0 >= t5)
      return H.ioore(t4, 0);
    t6 = t4[0];
    if (t3 < t6) {
      t7 = L1.array;
      if (0 >= t7.length)
        return H.ioore(t7, 0);
      t7 = t7[0] < t6;
    } else
      t7 = false;
    if (t7)
      return -1;
    t7 = B2.array;
    t8 = t7.length;
    if (0 >= t8)
      return H.ioore(t7, 0);
    t9 = t7[0];
    if (t3 > t9) {
      t10 = L1.array;
      if (0 >= t10.length)
        return H.ioore(t10, 0);
      t10 = t10[0] > t9;
    } else
      t10 = false;
    if (t10)
      return -2;
    if (1 >= t2)
      return H.ioore(t1, 1);
    t10 = t1[1];
    if (1 >= t5)
      return H.ioore(t4, 1);
    t11 = t4[1];
    if (t10 < t11) {
      t12 = L1.array;
      if (1 >= t12.length)
        return H.ioore(t12, 1);
      t12 = t12[1] < t11;
    } else
      t12 = false;
    if (t12)
      return -3;
    if (1 >= t8)
      return H.ioore(t7, 1);
    t12 = t7[1];
    if (t10 > t12) {
      t10 = L1.array;
      if (1 >= t10.length)
        return H.ioore(t10, 1);
      t10 = t10[1] > t12;
    } else
      t10 = false;
    if (t10)
      return -4;
    if (2 >= t2)
      return H.ioore(t1, 2);
    t1 = t1[2];
    if (2 >= t5)
      return H.ioore(t4, 2);
    t4 = t4[2];
    if (t1 < t4) {
      t2 = L1.array;
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      t2 = t2[2] < t4;
    } else
      t2 = false;
    if (t2)
      return -5;
    if (2 >= t8)
      return H.ioore(t7, 2);
    t2 = t7[2];
    if (t1 > t2) {
      t1 = L1.array;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1 = t1[2] > t2;
    } else
      t1 = false;
    if (t1)
      return -6;
    t1 = L1.array;
    t5 = t1.length;
    if (0 >= t5)
      return H.ioore(t1, 0);
    t7 = t1[0];
    if (t7 > t6)
      if (t7 < t9) {
        if (1 >= t5)
          return H.ioore(t1, 1);
        t8 = t1[1];
        if (t8 > t11)
          if (t8 < t12) {
            if (2 >= t5)
              return H.ioore(t1, 2);
            t1 = t1[2];
            t1 = t1 > t4 && t1 < t2;
          } else
            t1 = false;
        else
          t1 = false;
      } else
        t1 = false;
    else
      t1 = false;
    if (t1) {
      t1 = Hit.array;
      t2 = L1.$index(0, 0);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = t2;
      t2 = Hit.array;
      t1 = L1.$index(0, 1);
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      t2[1] = t1;
      t1 = Hit.array;
      t2 = L1.$index(0, 2);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2] = t2;
      H.printString("this sucks");
      return 1;
    }
    $.currentDist = 100000;
    $.currentSide = 0;
    if (B.getIntersection(t7 - t6, t3 - t6, L1, L2, Hit) && B.inBox(Hit, B1, B2, 1)) {
      d = L1.dist$1(Hit);
      if (d < $.currentDist) {
        $.currentDist = d;
        $.currentSide = 1;
        t1 = $.get$currentHit();
        t2 = t1.array;
        t3 = Hit.$index(0, 0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = t3;
        t3 = t1.array;
        t2 = Hit.$index(0, 1);
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t3[1] = t2;
        t1 = t1.array;
        t2 = Hit.$index(0, 2);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    }
    t1 = L1.array;
    if (1 >= t1.length)
      return H.ioore(t1, 1);
    t1 = t1[1];
    t2 = B1.array;
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t2 = t2[1];
    t3 = L2.array;
    if (1 >= t3.length)
      return H.ioore(t3, 1);
    if (B.getIntersection(t1 - t2, t3[1] - t2, L1, L2, Hit) && B.inBox(Hit, B1, B2, 2)) {
      d = L1.dist$1(Hit);
      if (d < $.currentDist) {
        $.currentDist = d;
        $.currentSide = 2;
        t1 = $.get$currentHit();
        t2 = t1.array;
        t3 = Hit.$index(0, 0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = t3;
        t3 = t1.array;
        t2 = Hit.$index(0, 1);
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t3[1] = t2;
        t1 = t1.array;
        t2 = Hit.$index(0, 2);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    }
    t1 = L1.array;
    if (2 >= t1.length)
      return H.ioore(t1, 2);
    t1 = t1[2];
    t2 = B1.array;
    if (2 >= t2.length)
      return H.ioore(t2, 2);
    t2 = t2[2];
    t3 = L2.array;
    if (2 >= t3.length)
      return H.ioore(t3, 2);
    if (B.getIntersection(t1 - t2, t3[2] - t2, L1, L2, Hit) && B.inBox(Hit, B1, B2, 3)) {
      d = L1.dist$1(Hit);
      if (d < $.currentDist) {
        $.currentDist = d;
        $.currentSide = 3;
        t1 = $.get$currentHit();
        t2 = t1.array;
        t3 = Hit.$index(0, 0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = t3;
        t3 = t1.array;
        t2 = Hit.$index(0, 1);
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t3[1] = t2;
        t1 = t1.array;
        t2 = Hit.$index(0, 2);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    }
    t1 = L1.array;
    if (0 >= t1.length)
      return H.ioore(t1, 0);
    t1 = t1[0];
    t2 = B2.array;
    if (0 >= t2.length)
      return H.ioore(t2, 0);
    t2 = t2[0];
    t3 = L2.array;
    if (0 >= t3.length)
      return H.ioore(t3, 0);
    if (B.getIntersection(t1 - t2, t3[0] - t2, L1, L2, Hit) && B.inBox(Hit, B1, B2, 1)) {
      d = L1.dist$1(Hit);
      if (d < $.currentDist) {
        $.currentDist = d;
        $.currentSide = 4;
        t1 = $.get$currentHit();
        t2 = t1.array;
        t3 = Hit.$index(0, 0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = t3;
        t3 = t1.array;
        t2 = Hit.$index(0, 1);
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t3[1] = t2;
        t1 = t1.array;
        t2 = Hit.$index(0, 2);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    }
    t1 = L1.array;
    if (1 >= t1.length)
      return H.ioore(t1, 1);
    t1 = t1[1];
    t2 = B2.array;
    if (1 >= t2.length)
      return H.ioore(t2, 1);
    t2 = t2[1];
    t3 = L2.array;
    if (1 >= t3.length)
      return H.ioore(t3, 1);
    if (B.getIntersection(t1 - t2, t3[1] - t2, L1, L2, Hit) && B.inBox(Hit, B1, B2, 2)) {
      d = L1.dist$1(Hit);
      if (d < $.currentDist) {
        $.currentDist = d;
        $.currentSide = 5;
        t1 = $.get$currentHit();
        t2 = t1.array;
        t3 = Hit.$index(0, 0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = t3;
        t3 = t1.array;
        t2 = Hit.$index(0, 1);
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t3[1] = t2;
        t1 = t1.array;
        t2 = Hit.$index(0, 2);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    }
    t1 = L1.array;
    if (2 >= t1.length)
      return H.ioore(t1, 2);
    t1 = t1[2];
    t2 = B2.array;
    if (2 >= t2.length)
      return H.ioore(t2, 2);
    t2 = t2[2];
    t3 = L2.array;
    if (2 >= t3.length)
      return H.ioore(t3, 2);
    if (B.getIntersection(t1 - t2, t3[2] - t2, L1, L2, Hit) && B.inBox(Hit, B1, B2, 3)) {
      d = L1.dist$1(Hit);
      if (d < $.currentDist) {
        $.currentDist = d;
        $.currentSide = 6;
        t1 = $.get$currentHit();
        t2 = t1.array;
        t3 = Hit.$index(0, 0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = t3;
        t3 = t1.array;
        t2 = Hit.$index(0, 1);
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        t3[1] = t2;
        t1 = t1.array;
        t2 = Hit.$index(0, 2);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t2;
      }
    }
    if ($.currentSide > 0) {
      t1 = $.get$currentHit();
      t2 = Hit.array;
      t3 = t1.$index(0, 0);
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2[0] = t3;
      t3 = Hit.array;
      t2 = t1.$index(0, 1);
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      t3[1] = t2;
      t2 = Hit.array;
      t1 = t1.$index(0, 2);
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      t2[2] = t1;
    }
    return $.currentSide;
  },
  getIntersection: function(fDst1, fDst2, P1, P2, Hit) {
    if (fDst1 * fDst2 >= 0)
      return false;
    if (fDst1 === fDst2)
      return false;
    $.get$temp().set$1(P2);
    $.get$temp().subtract$1(P1);
    $.get$temp().scale$1(0, -fDst1 / (fDst2 - fDst1));
    Hit.set$1($.get$temp());
    Hit.add$1(0, P1);
    return true;
  },
  inBox: function(Hit, B1, B2, axis) {
    var t1, t2, t3, t4, t5, t6, t7;
    if (axis === 1) {
      t1 = Hit.array;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t2 = t1[2];
      t3 = B1.array;
      if (2 >= t3.length)
        return H.ioore(t3, 2);
      if (t2 > t3[2]) {
        t4 = B2.array;
        if (2 >= t4.length)
          return H.ioore(t4, 2);
        if (t2 < t4[2]) {
          t1 = t1[1];
          t1 = t1 > t3[1] && t1 < t4[1];
        } else
          t1 = false;
      } else
        t1 = false;
    } else
      t1 = false;
    if (t1)
      return true;
    if (axis === 2) {
      t1 = Hit.array;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t2 = t1[2];
      t3 = B1.array;
      if (2 >= t3.length)
        return H.ioore(t3, 2);
      if (t2 > t3[2]) {
        t4 = B2.array;
        if (2 >= t4.length)
          return H.ioore(t4, 2);
        if (t2 < t4[2]) {
          t1 = t1[0];
          t1 = t1 > t3[0] && t1 < t4[0];
        } else
          t1 = false;
      } else
        t1 = false;
    } else
      t1 = false;
    if (t1)
      return true;
    if (axis === 3) {
      t1 = Hit.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = B1.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      if (t3 > t4[0]) {
        t6 = B2.array;
        t7 = t6.length;
        if (0 >= t7)
          return H.ioore(t6, 0);
        if (t3 < t6[0]) {
          if (1 >= t2)
            return H.ioore(t1, 1);
          t1 = t1[1];
          if (1 >= t5)
            return H.ioore(t4, 1);
          if (t1 > t4[1]) {
            if (1 >= t7)
              return H.ioore(t6, 1);
            t1 = t1 < t6[1];
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
    } else
      t1 = false;
    if (t1)
      return true;
    return false;
  },
  createTexturedShader: function() {
    var shaderObject = new B.ShaderObject("Textured", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "", "", "", "");
    shaderObject.vertexPositionAttribute = "aVertexPosition";
    shaderObject.textureCoordinatesAttribute = "aTextureCoord";
    shaderObject.modelViewMatrixUniform = "uMVMatrix";
    shaderObject.perpectiveMatrixUniform = "uPMatrix";
    shaderObject.textureSamplerUniform = "uSampler";
    shaderObject.fragmentShaderBody = "gl_FragColor = texture2D(uSampler, vaTextureCoord);";
    return B.generateShader(shaderObject);
  },
  generateShader: function(shaderObject) {
    var vs, t1, fs;
    vs = "    precision mediump float;\r\n\r\n    attribute vec3 " + H.S(shaderObject.vertexPositionAttribute) + ";\r\n    \r\n    uniform mat4 " + H.S(shaderObject.modelViewMatrixUniform) + ";\r\n    uniform mat4 " + H.S(shaderObject.perpectiveMatrixUniform) + ";\r\n    ";
    t1 = shaderObject.textureCoordinatesAttribute;
    if (t1 != null)
      vs += "        attribute vec2 " + H.S(t1) + ";\r\n        varying vec2 v" + H.S(shaderObject.textureCoordinatesAttribute) + ";\r\n        ";
    t1 = shaderObject.colorsAttribute;
    if (t1 != null)
      vs += "        attribute vec3 " + H.S(t1) + ";\r\n        varying vec3 v" + H.S(shaderObject.colorsAttribute) + ";\r\n        ";
    vs = vs + (shaderObject.vertexShaderHeader + "\n") + "void main(void) {\n" + ("gl_Position = " + H.S(shaderObject.perpectiveMatrixUniform) + " * " + H.S(shaderObject.modelViewMatrixUniform) + " * vec4(" + H.S(shaderObject.vertexPositionAttribute) + ", 1.0);\n");
    t1 = shaderObject.textureCoordinatesAttribute;
    if (t1 != null)
      vs += "v" + H.S(t1) + " = " + H.S(shaderObject.textureCoordinatesAttribute) + ";\n";
    t1 = shaderObject.colorsAttribute;
    if (t1 != null)
      vs += "v" + H.S(t1) + " = " + H.S(shaderObject.colorsAttribute) + ";\n";
    shaderObject.vertexShader = vs + shaderObject.vertexShaderBody + "}\n";
    t1 = shaderObject.textureCoordinatesAttribute;
    fs = t1 != null ? "precision mediump float;\n" + ("varying vec2 v" + H.S(t1) + ";\n") : "precision mediump float;\n";
    t1 = shaderObject.colorsAttribute;
    if (t1 != null)
      fs += "varying vec3 v" + H.S(t1) + ";\n";
    t1 = shaderObject.textureSamplerUniform;
    if (t1 != null)
      fs += "uniform sampler2D " + H.S(t1) + ";\n";
    shaderObject.fragmentShader = fs + (shaderObject.fragmentShaderHeader + "\n") + "void main(void) {\n" + shaderObject.fragmentShaderBody + "\n}\n";
    return shaderObject;
  },
  createCylinder: function(radius, height, radialSubdivisions, texture) {
    var halfHeight, vertices, uvs, vertIndices, t1, i, u, t2, xpos, zpos, p, t3, t4;
    halfHeight = height / 2;
    vertices = H.setRuntimeTypeInfo([], [P.$double]);
    uvs = H.setRuntimeTypeInfo([], [P.$double]);
    vertIndices = H.setRuntimeTypeInfo([], [P.$int]);
    C.JSArray_methods.addAll$1(vertices, [0, halfHeight, 0]);
    C.JSArray_methods.addAll$1(uvs, [0, 0]);
    t1 = -halfHeight;
    C.JSArray_methods.addAll$1(vertices, [0, t1, 0]);
    C.JSArray_methods.addAll$1(uvs, [1, 1]);
    for (i = 0; i < radialSubdivisions; ++i) {
      u = i / radialSubdivisions;
      t2 = u * 3.141592653589793 * 2;
      xpos = radius * Math.sin(t2);
      zpos = radius * Math.cos(t2);
      C.JSArray_methods.addAll$1(vertices, [xpos, halfHeight, zpos]);
      C.JSArray_methods.addAll$1(uvs, [u, u]);
      C.JSArray_methods.addAll$1(vertices, [xpos, t1, zpos]);
      C.JSArray_methods.addAll$1(uvs, [1, u]);
      if (i > 0) {
        p = i * 2 + 2;
        t2 = p - 2;
        C.JSArray_methods.addAll$1(vertIndices, [0, t2, p]);
        t3 = p - 1;
        t4 = p + 1;
        C.JSArray_methods.addAll$1(vertIndices, [1, t3, t4]);
        C.JSArray_methods.addAll$1(vertIndices, [t2, p, t4]);
        C.JSArray_methods.addAll$1(vertIndices, [t3, t4, t2]);
      }
    }
    p = radialSubdivisions * 2 + 2;
    t1 = p - 2;
    C.JSArray_methods.addAll$1(vertIndices, [0, t1, 2]);
    t2 = p - 1;
    C.JSArray_methods.addAll$1(vertIndices, [1, t2, 3]);
    C.JSArray_methods.addAll$1(vertIndices, [t1, 2, 3]);
    C.JSArray_methods.addAll$1(vertIndices, [t2, 3, t1]);
    return new B.MeshData(vertices, null, null, null, uvs, vertIndices, texture, null, false);
  },
  Animatable: {
    "^": "Object;"
  },
  ChronosGL: {
    "^": "Object;elementIndexUintExt,gl,programs,animatables,programBasic,_canvas,_aspect,_textureCache,_camera,_utils,fxFramebuffer,fxWall,fxProgram,fxMatrix,_pMatrix,near,far,_lastWidth,_lastHeight,_lastTime",
    createProgram$2: function(_, so, register) {
      var t1, pn;
      t1 = so.name;
      pn = B.ShaderProgram$(this, so, t1);
      if (register)
        this.programs.$indexSet(0, t1, pn);
      return pn;
    },
    createProgram$1: function($receiver, so) {
      return this.createProgram$2($receiver, so, true);
    },
    animate$2: function(_, timeNow, elapsed) {
      var t1, t2;
      for (t1 = this.animatables, t1 = t1.get$values(t1), t2 = t1._iterable, t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, t2.get$iterator(t2), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();)
        J.animate$1$x(t1.__internal$_current, elapsed);
      for (t1 = this.programs, t1 = t1.get$values(t1), t2 = t1._iterable, t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, t2.get$iterator(t2), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();)
        J.animate$1$x(t1.__internal$_current, elapsed);
      t1 = this.fxProgram;
      if (t1 != null)
        t1.animate$1(0, elapsed);
    },
    draw$0: function() {
      var t1, t2, t3, t4, t5, $top, right, rl, tb, fn, t6, result;
      t1 = this.fxFramebuffer;
      if (t1 != null)
        J.bindFramebuffer$2$x(this.gl, 36160, t1.framebuffer);
      t1 = this._lastWidth;
      t2 = this._canvas;
      t2.toString;
      if (t1 === C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t2.clientWidth))) {
        t1 = this._lastHeight;
        t2 = this._canvas;
        t2.toString;
        t2 = t1 !== C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t2.clientHeight));
        t1 = t2;
      } else
        t1 = true;
      if (t1) {
        t1 = this._canvas;
        t1.toString;
        J.set$width$x(t1, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.clientWidth)));
        t1 = this._canvas;
        t1.toString;
        J.set$height$x(t1, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.clientHeight)));
        t1 = this.gl;
        t2 = this._canvas;
        t2.toString;
        t2 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t2.clientWidth));
        t3 = this._canvas;
        t3.toString;
        J.viewport$4$x(t1, 0, 0, t2, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t3.clientHeight)));
        t3 = this._pMatrix;
        t2 = this._canvas;
        t2.toString;
        t2 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t2.clientWidth));
        t1 = this._canvas;
        t1.toString;
        t1 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.clientHeight));
        t4 = this.near;
        t5 = this.far;
        $top = t4 * Math.tan(H.checkNum(0.4363323129985824));
        right = $top * (t2 / t1);
        t1 = -right;
        t2 = -$top;
        rl = right - t1;
        tb = $top - t2;
        fn = t5 - t4;
        t3.clear$0(0);
        t3 = t3.array;
        t6 = t4 * 2;
        t3[0] = t6 / rl;
        t3[5] = t6 / tb;
        t3[8] = (right + t1) / rl;
        t3[9] = ($top + t2) / tb;
        t3[10] = -(t5 + t4) / fn;
        t3[11] = -1;
        t3[14] = -(t5 * t4 * 2) / fn;
        t4 = this._canvas;
        t4.toString;
        this._lastWidth = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t4.clientWidth));
        t4 = this._canvas;
        t4.toString;
        this._lastHeight = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t4.clientHeight));
      }
      J.clear$1$ax(this.gl, 16640);
      for (t1 = this.programs, t1 = t1.get$values(t1), t2 = t1._iterable, t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, t2.get$iterator(t2), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]), t2 = this._pMatrix; t1.moveNext$0();)
        t1.__internal$_current.draw$1(t2);
      t1 = this.fxFramebuffer;
      if (t1 != null) {
        result = J.checkFramebufferStatus$1$x(t1.gl, 36160) === 36053;
        if (!result)
          P.print("FRAMEBUFFER_INCOMPLETE");
        t1 = result;
      } else
        t1 = false;
      if (t1) {
        J.bindFramebuffer$2$x(this.gl, 36160, null);
        J.clear$1$ax(this.gl, 16640);
        t1 = this.fxMatrix;
        this.fxProgram.draw$2(t1, t1);
      }
    },
    run$1: [function(timeNow) {
      var elapsed, t1, t2;
      if (timeNow == null)
        timeNow = 0;
      if (J.$eq(this._lastTime, 0))
        this._lastTime = timeNow;
      elapsed = J.$sub$n(timeNow, this._lastTime);
      this._lastTime = timeNow;
      if (J.get$isNaN$n(elapsed)) {
        P.print("isNaN(elapsed)");
        elapsed = 0;
      }
      this.animate$2(0, timeNow, elapsed);
      this.draw$0();
      t1 = window;
      t2 = this.get$run();
      C.Window_methods._ensureRequestAnimationFrame$0(t1);
      C.Window_methods._requestAnimationFrame$1(t1, W._wrapZone(t2));
    }, function() {
      return this.run$1(null);
    }, "run$0", "call$1", "call$0", "get$run", 0, 2, 13, 14],
    ChronosGL$7$far$fxShader$near$transparent$useElementIndexUint$useFramebuffer: function(canvasID, far, fxShader, near, transparent, useElementIndexUint, useFramebuffer) {
      var t1, t2, t3, t4;
      t1 = document.querySelector(canvasID);
      this._canvas = t1;
      t1 = J.get$onDragStart$x(t1);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.ChronosGL_closure()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = this._canvas;
      t1.toString;
      J.set$width$x(t1, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.clientWidth)));
      t1 = this._canvas;
      t1.toString;
      J.set$height$x(t1, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.clientHeight)));
      t1 = this._canvas;
      t1.toString;
      t1 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t1.clientWidth));
      t2 = this._canvas;
      t2.toString;
      this._aspect = t1 / C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t2.clientHeight));
      t2 = J.getContext$1$x(this._canvas, "experimental-webgl");
      this.gl = t2;
      if (t2 == null)
        throw H.wrapException(P.Exception_Exception("calling canvas.getContext(\"experimental-webgl\") failed, make sure you run on a computer that supports WebGL, test here: http://get.webgl.org/"));
      $.ChronosGL_globalGL = t2;
      if (useElementIndexUint) {
        t1 = J.getExtension$1$x(t2, "OES_element_index_uint");
        this.elementIndexUintExt = t1;
        if (t1 == null)
          throw H.wrapException("Error: OES_element_index_uint is not supported");
        $.ChronosGL_useElementIndexUint = true;
      }
      J.clearColor$4$x(this.gl, 0, 0, 0, 1);
      t1 = this.gl;
      if (transparent) {
        J.enable$1$x(t1, 3042);
        J.blendFunc$2$x(this.gl, 770, 774);
      } else
        J.enable$1$x(t1, 2929);
      this.programBasic = this.createProgram$1(0, B.createTexturedShader());
      t1 = new B.TextureCache(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, B.TextureWrapper), this, null);
      t1.gl = this.gl;
      this._textureCache = t1;
      t1 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t1.identity$0();
      t2 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t2.identity$0();
      this._camera = new B.Camera(t1, false, t2, Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t2 = new B.Utils(this, null, null);
      t1 = this.gl;
      t2.gl = t1;
      t2.textureCache = this._textureCache;
      this._utils = t2;
      if (useFramebuffer) {
        t2 = J.get$width$x(this._canvas);
        t3 = J.get$height$x(this._canvas);
        t4 = new B.ChronosFramebuffer(t1, t2, t3, null, null, null, null, null);
        t4.ChronosFramebuffer$3(t1, t2, t3);
        this.fxFramebuffer = t4;
        t4 = this._utils.getWall$2(t4.colorTexture, 1);
        this.fxWall = t4;
        t4.texture2 = this.fxFramebuffer.depthTexture;
        t1 = B.ShaderProgram$(this, fxShader, "fx");
        this.fxProgram = t1;
        t1.objects.push(this.fxWall);
      }
      B.setUpCapture();
    },
    static: {"^": "ChronosGL_globalGL,ChronosGL_useElementIndexUint", ChronosGL$: function(canvasID, far, fxShader, near, transparent, useElementIndexUint, useFramebuffer) {
        var t1, t2, t3, t4;
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, B.ShaderProgram);
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, B.Animatable);
        t3 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t3.identity$0();
        t4 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t4.identity$0();
        t4 = new B.ChronosGL(null, null, t1, t2, null, null, null, null, null, null, null, null, null, t3, t4, near, far, 0, 0, 0);
        t4.ChronosGL$7$far$fxShader$near$transparent$useElementIndexUint$useFramebuffer(canvasID, far, fxShader, near, transparent, useElementIndexUint, useFramebuffer);
        return t4;
      }}
  },
  ChronosGL_closure: {
    "^": "Closure:15;",
    call$1: function($event) {
      J.preventDefault$0$x($event);
    }
  },
  Camera: {
    "^": "Spatial;tempMatrix,alternativeTranslate,matrix,_pos,_back,_up,_right",
    getMVMatrix$2: function(mvMatrix, translate) {
      var t1, t2, i, t3, t4;
      for (t1 = this.tempMatrix, t2 = this.matrix.array, i = 0; i < 16; ++i) {
        t3 = t2[i];
        t4 = i < 12 ? 1 : -1;
        t1.array[i] = t3 * t4;
      }
      t3 = mvMatrix.array;
      t1 = t1.array;
      t3[0] = t1[0];
      t3[1] = t1[1];
      t3[2] = t1[2];
      t3[3] = t1[3];
      t3[4] = t1[4];
      t3[5] = t1[5];
      t3[6] = t1[6];
      t3[7] = t1[7];
      t3[8] = t1[8];
      t3[9] = t1[9];
      t3[10] = t1[10];
      t3[11] = t1[11];
      t3[12] = 0;
      t3[13] = 0;
      t3[14] = 0;
      t3[15] = 1;
      if (translate)
        if (this.alternativeTranslate) {
          t3[12] = t2[12];
          t3[13] = t2[13];
          t3[14] = t2[14];
          t3[15] = t2[15];
        } else {
          t2 = t1[12];
          t4 = t1[13];
          t1 = t1[14];
          t3[12] = t3[0] * t2 + t3[4] * t4 + t3[8] * t1 + t3[12];
          t3[13] = t3[1] * t2 + t3[5] * t4 + t3[9] * t1 + t3[13];
          t3[14] = t3[2] * t2 + t3[6] * t4 + t3[10] * t1 + t3[14];
          t3[15] = t3[3] * t2 + t3[7] * t4 + t3[11] * t1 + t3[15];
        }
    }
  },
  ChronosFramebuffer: {
    "^": "Object;gl,width,height,framebuffer,renderbuffer,colorTexture,depthTexture,depthTextureExt",
    initTexture$1: function(depth) {
      var texture, t1, t2, t3;
      texture = J.createTexture$0$x(this.gl);
      J.bindTexture$2$x(this.gl, 3553, texture);
      J.texParameteri$3$x(this.gl, 3553, 10240, 9728);
      J.texParameteri$3$x(this.gl, 3553, 10241, 9728);
      J.texParameteri$3$x(this.gl, 3553, 10242, 33071);
      J.texParameteri$3$x(this.gl, 3553, 10243, 33071);
      t1 = this.gl;
      t2 = this.width;
      t3 = this.height;
      if (depth)
        J.texImage2DTyped$9$x(t1, 3553, 0, 6402, t2, t3, 0, 6402, 5123, null);
      else
        J.texImage2DTyped$9$x(t1, 3553, 0, 6407, t2, t3, 0, 6407, 5121, null);
      return texture;
    },
    initTexture$0: function() {
      return this.initTexture$1(false);
    },
    ChronosFramebuffer$3: function(gl, width, height) {
      var t1 = J.getExtension$1$x(this.gl, "WEBKIT_WEBGL_depth_texture");
      this.depthTextureExt = t1;
      if (t1 == null)
        throw H.wrapException("Error");
      this.framebuffer = J.createFramebuffer$0$x(this.gl);
      this.colorTexture = this.initTexture$0();
      this.depthTexture = this.initTexture$1(true);
      J.bindFramebuffer$2$x(this.gl, 36160, this.framebuffer);
      J.framebufferTexture2D$5$x(this.gl, 36160, 36064, 3553, this.colorTexture, 0);
      J.framebufferTexture2D$5$x(this.gl, 36160, 36096, 3553, this.depthTexture, 0);
      J.bindTexture$2$x(this.gl, 3553, null);
      J.bindFramebuffer$2$x(this.gl, 36160, null);
    }
  },
  setUpCapture_closure: {
    "^": "Closure:16;",
    call$1: function(e) {
      $.get$currentlyPressedKeys().$indexSet(0, J.get$keyCode$x(e), true);
    }
  },
  setUpCapture_closure0: {
    "^": "Closure:16;",
    call$1: function(e) {
      $.get$currentlyPressedKeys().$indexSet(0, J.get$keyCode$x(e), null);
    }
  },
  setUpCapture_closure1: {
    "^": "Closure:15;",
    call$1: function(e) {
      var t1, t2;
      t1 = J.getInterceptor$x(e);
      t1.preventDefault$0(e);
      $.clientX = t1.get$client(e).x;
      t1 = window.innerHeight;
      t2 = H.setRuntimeTypeInfo(new P.Point(e.clientX, e.clientY), [null]).y;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      $.clientY = t1 - t2;
      t2 = H.setRuntimeTypeInfo(new P.Point(e.clientX, e.clientY), [null]).x;
      t1 = window.innerWidth;
      if (typeof t1 !== "number")
        return t1.$tdiv();
      t1 = C.JSInt_methods._tdivFast$1(t1, 2);
      if (typeof t2 !== "number")
        return t2.$sub();
      $.mouseX = t2 - t1;
      t1 = H.setRuntimeTypeInfo(new P.Point(e.clientX, e.clientY), [null]).y;
      t2 = window.innerHeight;
      if (typeof t2 !== "number")
        return t2.$tdiv();
      t2 = C.JSInt_methods._tdivFast$1(t2, 2);
      if (typeof t1 !== "number")
        return t1.$sub();
      $.mouseY = -(t1 - t2);
    }
  },
  setUpCapture_closure2: {
    "^": "Closure:15;",
    call$1: function(e) {
      var t1 = J.getInterceptor$x(e);
      t1.preventDefault$0(e);
      if (t1.get$which(e) === 3 || t1.get$button(e) === 2)
        $.get$currentlyPressedMouseButtons().$indexSet(0, "right", true);
      else
        $.get$currentlyPressedMouseButtons().$indexSet(0, "left", true);
    }
  },
  setUpCapture_closure3: {
    "^": "Closure:15;",
    call$1: function(e) {
      J.preventDefault$0$x(e);
    }
  },
  setUpCapture_closure4: {
    "^": "Closure:15;",
    call$1: function(e) {
      var t1 = J.getInterceptor$x(e);
      t1.preventDefault$0(e);
      if (t1.get$which(e) === 3 || t1.get$button(e) === 2)
        $.get$currentlyPressedMouseButtons().$indexSet(0, "right", null);
      else
        $.get$currentlyPressedMouseButtons().$indexSet(0, "left", null);
    }
  },
  Mesh: {
    "^": "Node;gl,debug,blend,blend_sFactor,blend_dFactor,drawPoints,texture<,texture2,verticesBuffer,colorsBuffer,textureCoordBuffer,normalsBuffer,binormalsBuffer,vertexIndexBuffer,numItems,name,type,enabled,invert,children,mvMatrix,tempMatrix,animateCallback,matrix,_pos,_back,_up,_right",
    draw2$1: function(program) {
      var t1, t2, t3, t4;
      t1 = this.debug;
      if (t1) {
        P.print("Mesh: " + this.name);
        P.print(program.shaderObject.textureSamplerUniform);
        P.print(this.drawPoints);
        P.print(this.numItems);
        P.print(this.mvMatrix.array);
        P.print("-----");
      }
      t2 = this.blend;
      if (t2) {
        J.enable$1$x(this.gl, 3042);
        J.blendFunc$2$x(this.gl, this.blend_sFactor, this.blend_dFactor);
      }
      J.bindBuffer$2$x(this.gl, 34962, this.verticesBuffer);
      J.vertexAttribPointer$6$x(this.gl, program.vertexPositionAttribute, 3, 5126, false, 0, 0);
      t3 = program.shaderObject;
      if (t3.colorsAttribute != null) {
        J.bindBuffer$2$x(this.gl, 34962, this.colorsBuffer);
        J.vertexAttribPointer$6$x(this.gl, program.colorsAttribute, 3, 5126, false, 0, 0);
      }
      if (t3.textureCoordinatesAttribute != null) {
        J.bindBuffer$2$x(this.gl, 34962, this.textureCoordBuffer);
        J.vertexAttribPointer$6$x(this.gl, program.textureCoordAttribute, 2, 5126, false, 0, 0);
      }
      t3.normalAttribute;
      t3.binormalAttribute;
      if (t3.textureSamplerUniform != null) {
        J.activeTexture$1$x(this.gl, 33984);
        J.bindTexture$2$x(this.gl, 3553, this.texture);
        J.uniform1i$2$x(this.gl, program.samplerUniform, 0);
      }
      t3.texture2SamplerUniform;
      t3.transformationMatrixUniform;
      J.uniformMatrix4fv$3$x(this.gl, program.mvMatrixUniform, false, this.mvMatrix.array);
      if (this.drawPoints)
        J.drawArrays$3$x(this.gl, 0, 0, this.numItems);
      else {
        t3 = this.vertexIndexBuffer;
        t4 = this.gl;
        if (t3 == null)
          J.drawArrays$3$x(t4, 4, 0, this.numItems);
        else {
          J.bindBuffer$2$x(t4, 34963, t3);
          t3 = this.gl;
          t4 = this.numItems;
          J.drawElements$4$x(t3, 4, t4, $.ChronosGL_useElementIndexUint ? 5125 : 5123, 0);
        }
      }
      if (t1)
        P.print(J.getProgramInfoLog$1$x(this.gl, program.program));
      if (t2)
        J.disable$1$x(this.gl, 3042);
    },
    Mesh$2: function(meshData, drawPoints) {
      var t1, t2, t3;
      if (!meshData.isOptimized)
        meshData.optimize$0();
      this.texture = meshData.texture;
      this.texture2 = meshData.texture2;
      t1 = $.ChronosGL_globalGL;
      this.gl = t1;
      t1 = J.createBuffer$0$x(t1);
      this.verticesBuffer = t1;
      J.bindBuffer$2$x(this.gl, 34962, t1);
      J.bufferDataTyped$3$x(this.gl, 34962, H.interceptedTypeCast(meshData.vertices, "$isFloat32List"), 35044);
      if (meshData.colors != null) {
        t1 = J.createBuffer$0$x(this.gl);
        this.colorsBuffer = t1;
        J.bindBuffer$2$x(this.gl, 34962, t1);
        J.bufferDataTyped$3$x(this.gl, 34962, meshData.colors, 35044);
      }
      if (meshData.textureCoords != null) {
        t1 = J.createBuffer$0$x(this.gl);
        this.textureCoordBuffer = t1;
        J.bindBuffer$2$x(this.gl, 34962, t1);
        J.bufferDataTyped$3$x(this.gl, 34962, H.interceptedTypeCast(meshData.textureCoords, "$isFloat32List"), 35044);
      }
      if (meshData.normals != null) {
        t1 = J.createBuffer$0$x(this.gl);
        this.normalsBuffer = t1;
        J.bindBuffer$2$x(this.gl, 34962, t1);
        J.bufferDataTyped$3$x(this.gl, 34962, meshData.normals, 35044);
      }
      if (meshData.binormals != null) {
        t1 = J.createBuffer$0$x(this.gl);
        this.binormalsBuffer = t1;
        J.bindBuffer$2$x(this.gl, 34962, t1);
        J.bufferDataTyped$3$x(this.gl, 34962, meshData.binormals, 35044);
      }
      this.numItems = meshData.vertexIndices.length;
      t1 = J.createBuffer$0$x(this.gl);
      this.vertexIndexBuffer = t1;
      J.bindBuffer$2$x(this.gl, 34963, t1);
      t1 = $.ChronosGL_useElementIndexUint;
      t2 = meshData.vertexIndices;
      t3 = this.gl;
      if (t1)
        J.bufferDataTyped$3$x(t3, 34963, H.interceptedTypeCast(t2, "$isUint32List"), 35044);
      else
        J.bufferDataTyped$3$x(t3, 34963, H.interceptedTypeCast(t2, "$isUint16List"), 35044);
    },
    static: {Mesh$: function(meshData, drawPoints) {
        var t1, t2, t3, t4;
        t1 = H.setRuntimeTypeInfo([], [B.Node]);
        t2 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t2.identity$0();
        t3 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t3.identity$0();
        t4 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t4.identity$0();
        t4 = new B.Mesh(null, false, false, 770, 1, drawPoints, null, null, null, null, null, null, null, null, null, "", "", true, false, t1, t2, t3, null, t4, Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t4.Mesh$2(meshData, drawPoints);
        return t4;
      }}
  },
  MeshData: {
    "^": "Object;vertices,colors,normals,binormals,textureCoords,vertexIndices,texture<,texture2,isOptimized",
    optimize$0: function() {
      var t1, t2;
      t1 = this.vertices;
      if (!J.getInterceptor(t1).$isFloat32List)
        this.vertices = new Float32Array(H._ensureNativeList(t1));
      t1 = this.colors;
      if (t1 != null && !J.getInterceptor(t1).$isFloat32List)
        this.colors = new Float32Array(H._ensureNativeList(t1));
      t1 = this.textureCoords;
      if (t1 != null && !J.getInterceptor(t1).$isFloat32List)
        this.textureCoords = new Float32Array(H._ensureNativeList(t1));
      t1 = this.normals;
      if (t1 != null && !J.getInterceptor(t1).$isFloat32List)
        this.normals = new Float32Array(H._ensureNativeList(t1));
      t1 = this.binormals;
      if (t1 != null && !J.getInterceptor(t1).$isFloat32List)
        this.binormals = new Float32Array(H._ensureNativeList(t1));
      if (!J.getInterceptor(this.vertexIndices).$isTypedData) {
        t1 = $.ChronosGL_useElementIndexUint;
        t2 = this.vertexIndices;
        this.vertexIndices = t1 ? new Uint32Array(H._ensureNativeList(t2)) : new Uint16Array(H._ensureNativeList(t2));
      }
      this.isOptimized = true;
    }
  },
  Node: {
    "^": "Spatial;enabled>",
    animate$1: function(_, elapsed) {
    },
    draw2$1: function(program) {
    },
    draw$2: function(program, parentMVMatrix) {
      var t1, t2, t3, t4, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3;
      t1 = this.mvMatrix;
      t1.setElements$1(parentMVMatrix);
      t2 = this.tempMatrix;
      t3 = this.matrix;
      t2.setElements$1(t3);
      if (this.invert) {
        t2.invert$0();
        t4 = t2.array;
        t3 = t3.array;
        t4[12] = t3[12];
        t4[13] = t3[13];
        t4[14] = t3[14];
      }
      t3 = t1.array;
      a00 = t3[0];
      a01 = t3[1];
      a02 = t3[2];
      a03 = t3[3];
      a10 = t3[4];
      a11 = t3[5];
      a12 = t3[6];
      a13 = t3[7];
      a20 = t3[8];
      a21 = t3[9];
      a22 = t3[10];
      a23 = t3[11];
      a30 = t3[12];
      a31 = t3[13];
      a32 = t3[14];
      a33 = t3[15];
      t2 = t2.array;
      b0 = t2[0];
      b1 = t2[1];
      b2 = t2[2];
      b3 = t2[3];
      t3[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      t3[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      t3[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      t3[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = t2[4];
      b1 = t2[5];
      b2 = t2[6];
      b3 = t2[7];
      t3[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      t3[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      t3[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      t3[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = t2[8];
      b1 = t2[9];
      b2 = t2[10];
      b3 = t2[11];
      t3[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      t3[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      t3[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      t3[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = t2[12];
      b1 = t2[13];
      b2 = t2[14];
      b3 = t2[15];
      t3[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      t3[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      t3[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      t3[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      this.draw2$1(program);
      for (t2 = this.children, t2 = new H.ListIterator(t2, t2.length, 0, null); t2.moveNext$0();)
        t2.__internal$_current.draw$2(program, t1);
    }
  },
  ShaderObject: {
    "^": "Object;name,vertexShader,fragmentShader,vertexPositionAttribute,colorsAttribute,textureCoordinatesAttribute,normalAttribute,binormalAttribute,transformationMatrixUniform,modelViewMatrixUniform,perpectiveMatrixUniform,textureSamplerUniform,texture2SamplerUniform,cameraNear,cameraFar,size,timeUniform,vertexShaderHeader,vertexShaderBody,fragmentShaderHeader,fragmentShaderBody"
  },
  ShaderProgram: {
    "^": "Object;chronosGL,shaderObject,name,gl,program,vertexPositionAttribute,colorsAttribute,textureCoordAttribute,normalAttribute,binormalAttribute,pMatrixUniform,mvMatrixUniform,samplerUniform,sampler2Uniform,transformationMatrixUniform,cameraNear,cameraFar,size,timeUniform,debug,mvMatrix,followCameraObjects,objects,timeNow",
    animate$1: function(_, elapsed) {
      var t1, node, t2;
      this.timeNow += elapsed;
      for (t1 = this.objects, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
        node = t1.__internal$_current;
        t2 = J.getInterceptor$x(node);
        if (t2.get$enabled(node) === true)
          t2.animate$1(node, elapsed);
      }
    },
    hasEnabledObjects$0: function() {
      for (var t1 = this.objects, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        if (J.get$enabled$x(t1.__internal$_current) === true)
          return true;
      for (t1 = this.followCameraObjects, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();)
        if (J.get$enabled$x(t1.__internal$_current) === true)
          return true;
      return false;
    },
    draw$2: function(pMatrix, overrideMvMatrix) {
      var t1, t2, camera, t3, t4, t5, t6;
      if (!this.hasEnabledObjects$0())
        return;
      if (this.debug)
        P.print("name: " + this.name);
      J.useProgram$1$x(this.gl, this.program);
      J.enableVertexAttribArray$1$x(this.gl, this.vertexPositionAttribute);
      t1 = this.shaderObject;
      if (t1.colorsAttribute != null)
        J.enableVertexAttribArray$1$x(this.gl, this.colorsAttribute);
      if (t1.textureCoordinatesAttribute != null)
        J.enableVertexAttribArray$1$x(this.gl, this.textureCoordAttribute);
      t1.normalAttribute;
      t1.binormalAttribute;
      J.uniformMatrix4fv$3$x(this.gl, this.pMatrixUniform, false, pMatrix.get$array());
      t1.timeUniform;
      t2 = this.chronosGL;
      camera = t2._camera;
      t3 = this.mvMatrix;
      camera.getMVMatrix$2(t3, false);
      if (t1.cameraNear != null)
        J.uniform1f$2$x(this.gl, this.cameraNear, t2.near);
      if (t1.cameraFar != null)
        J.uniform1f$2$x(this.gl, this.cameraFar, t2.far);
      if (t1.size != null) {
        t4 = this.gl;
        t5 = this.size;
        t6 = t2._canvas;
        t6.toString;
        t6 = C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t6.clientWidth));
        t2 = t2._canvas;
        t2.toString;
        J.uniform2f$3$x(t4, t5, t6, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(t2.clientHeight)));
      }
      this.drawObjects$1(this.followCameraObjects);
      camera.getMVMatrix$2(t3, true);
      if (overrideMvMatrix != null)
        t3.setElements$1(overrideMvMatrix);
      this.drawObjects$1(this.objects);
      J.disableVertexAttribArray$1$x(this.gl, this.vertexPositionAttribute);
      if (t1.colorsAttribute != null)
        J.disableVertexAttribArray$1$x(this.gl, this.colorsAttribute);
      if (t1.textureCoordinatesAttribute != null)
        J.disableVertexAttribArray$1$x(this.gl, this.textureCoordAttribute);
      t1.normalAttribute;
      t1.binormalAttribute;
    },
    draw$1: function(pMatrix) {
      return this.draw$2(pMatrix, null);
    },
    drawObjects$1: function(objects) {
      var t1, t2, node;
      for (t1 = new H.ListIterator(objects, objects.length, 0, null), t2 = this.mvMatrix; t1.moveNext$0();) {
        node = t1.__internal$_current;
        if (J.get$enabled$x(node) === true)
          node.draw$2(this, t2);
      }
    },
    ShaderProgram$3: function(chronosGL, shaderObject, $name) {
      var t1, su, t2, t3, t4, program;
      t1 = this.chronosGL.gl;
      this.gl = t1;
      su = new B.ShaderUtils(t1);
      t2 = this.shaderObject;
      t3 = t2.vertexShader;
      t4 = t2.fragmentShader;
      program = J.createProgram$0$x(t1);
      t1.attachShader(program, su.getShader$2(35633, t3));
      J.attachShader$2$x(su.gl, program, su.getShader$2(35632, t4));
      J.linkProgram$1$x(su.gl, program);
      if (J.getProgramParameter$2$x(su.gl, program, 35714) !== true)
        H.throwExpression(J.getProgramInfoLog$1$x(su.gl, program));
      this.program = program;
      this.vertexPositionAttribute = J.getAttribLocation$2$x(this.gl, program, t2.vertexPositionAttribute);
      t1 = t2.colorsAttribute;
      if (t1 != null)
        this.colorsAttribute = J.getAttribLocation$2$x(this.gl, this.program, t1);
      t1 = t2.textureCoordinatesAttribute;
      if (t1 != null)
        this.textureCoordAttribute = J.getAttribLocation$2$x(this.gl, this.program, t1);
      t2.normalAttribute;
      t2.binormalAttribute;
      t1 = t2.perpectiveMatrixUniform;
      this.pMatrixUniform = J.getUniformLocation$2$x(this.gl, this.program, t1);
      t1 = t2.modelViewMatrixUniform;
      this.mvMatrixUniform = J.getUniformLocation$2$x(this.gl, this.program, t1);
      t1 = t2.textureSamplerUniform;
      if (t1 != null)
        this.samplerUniform = J.getUniformLocation$2$x(this.gl, this.program, t1);
      t2.texture2SamplerUniform;
      t1 = t2.cameraNear;
      if (t1 != null)
        this.cameraNear = J.getUniformLocation$2$x(this.gl, this.program, t1);
      t1 = t2.cameraFar;
      if (t1 != null)
        this.cameraFar = J.getUniformLocation$2$x(this.gl, this.program, t1);
      t1 = t2.size;
      if (t1 != null)
        this.size = J.getUniformLocation$2$x(this.gl, this.program, t1);
      t2.transformationMatrixUniform;
      t2.timeUniform;
    },
    static: {ShaderProgram$: function(chronosGL, shaderObject, $name) {
        var t1 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
        t1.identity$0();
        t1 = new B.ShaderProgram(chronosGL, shaderObject, $name, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, t1, H.setRuntimeTypeInfo([], [B.Node]), H.setRuntimeTypeInfo([], [B.Node]), 0);
        t1.ShaderProgram$3(chronosGL, shaderObject, $name);
        return t1;
      }}
  },
  ShaderUtils: {
    "^": "Object;gl",
    getShader$2: function(type, text) {
      var shader, result;
      shader = J.createShader$1$x(this.gl, type);
      J.shaderSource$2$x(this.gl, shader, text);
      J.compileShader$1$x(this.gl, shader);
      result = J.getShaderParameter$2$x(this.gl, shader, 35713);
      if (result != null && result === false)
        throw H.wrapException(J.getShaderInfoLog$1$x(this.gl, shader));
      return shader;
    }
  },
  Spatial: {
    "^": "Object;",
    getPos$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this._pos;
      t2 = $.Matrix4_POSX;
      t3 = this.matrix.array;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      t4 = t1.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t4[0] = t2;
      t2 = $.Matrix4_POSY;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t4[1] = t2;
      t2 = $.Matrix4_POSZ;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t4[2] = t2;
      return t1;
    },
    getBack$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this._back;
      t2 = $.Matrix4_BACKX;
      t3 = this.matrix.array;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      t4 = t1.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t4[0] = t2;
      t2 = $.Matrix4_BACKY;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t4[1] = t2;
      t2 = $.Matrix4_BACKZ;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t4[2] = t2;
      return t1;
    },
    getUp$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this._up;
      t2 = $.Matrix4_UPX;
      t3 = this.matrix.array;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      t4 = t1.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t4[0] = t2;
      t2 = $.Matrix4_UPY;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t4[1] = t2;
      t2 = $.Matrix4_UPZ;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t4[2] = t2;
      return t1;
    },
    getRight$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this._right;
      t2 = $.Matrix4_RIGHTX;
      t3 = this.matrix.array;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      t4 = t1.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t4[0] = t2;
      t2 = $.Matrix4_RIGHTY;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t4[1] = t2;
      t2 = $.Matrix4_RIGHTZ;
      if (t2 >= 16)
        return H.ioore(t3, t2);
      t2 = t3[t2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t4[2] = t2;
      return t1;
    },
    setPos$3: function(x, y, z) {
      var t1, t2;
      t1 = $.Matrix4_POSX;
      t2 = this.matrix.array;
      if (t1 >= 16)
        return H.ioore(t2, t1);
      t2[t1] = x;
      t1 = $.Matrix4_POSY;
      if (t1 >= 16)
        return H.ioore(t2, t1);
      t2[t1] = y;
      t1 = $.Matrix4_POSZ;
      if (t1 >= 16)
        return H.ioore(t2, t1);
      t2[t1] = z;
    },
    moveBackward$1: function(amount) {
      var t1, t2, t3, t4;
      t1 = $.Matrix4_POSX;
      t2 = this.matrix.array;
      if (t1 >= 16)
        return H.ioore(t2, t1);
      t3 = t2[t1];
      t4 = $.Matrix4_BACKX;
      if (t4 >= 16)
        return H.ioore(t2, t4);
      t2[t1] = t3 + t2[t4] * amount;
      t4 = $.Matrix4_POSY;
      if (t4 >= 16)
        return H.ioore(t2, t4);
      t3 = t2[t4];
      t1 = $.Matrix4_BACKY;
      if (t1 >= 16)
        return H.ioore(t2, t1);
      t2[t4] = t3 + t2[t1] * amount;
      t1 = $.Matrix4_POSZ;
      if (t1 >= 16)
        return H.ioore(t2, t1);
      t3 = t2[t1];
      t4 = $.Matrix4_BACKZ;
      if (t4 >= 16)
        return H.ioore(t2, t4);
      t2[t1] = t3 + t2[t4] * amount;
    }
  },
  TextureCache: {
    "^": "Object;textureCache,chronosGL,gl",
    loadAllThenExecute$1: function(callBackFunc) {
      var futures, t1, t2, url, textureWrapper;
      futures = H.setRuntimeTypeInfo([], [[P.Future, W.Event]]);
      for (t1 = this.textureCache, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)])._map, t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null), t2._cell = t1._first; t2.moveNext$0();) {
        url = t2._collection$_current;
        textureWrapper = this.textureCache.$index(0, url);
        if (J.get$loaded$x(textureWrapper) === true)
          continue;
        t1 = J.get$onLoad$x(textureWrapper.get$image());
        futures.push(t1.get$first(t1));
        J.set$src$x(textureWrapper.image, url);
      }
      P.Future_wait(futures, false).then$1(new B.TextureCache_loadAllThenExecute_closure(this, callBackFunc));
    }
  },
  TextureCache_loadAllThenExecute_closure: {
    "^": "Closure:17;this_0,callBackFunc_1",
    call$1: function(list) {
      var t1, t2, t3, url, textureWrapper, line;
      for (t1 = this.this_0, t2 = t1.textureCache, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)])._map, t3 = new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), t3._cell = t2._first; t3.moveNext$0();) {
        url = t3._collection$_current;
        textureWrapper = t1.textureCache.$index(0, url);
        if (J.get$loaded$x(textureWrapper) === true)
          continue;
        J.pixelStorei$2$x(t1.gl, 37440, 1);
        J.bindTexture$2$x(t1.gl, 3553, textureWrapper.get$texture());
        J.texImage2DImage$6$x(t1.gl, 3553, 0, 6408, 6408, 5121, textureWrapper.image);
        J.texParameteri$3$x(t1.gl, 3553, 10240, 9729);
        J.texParameteri$3$x(t1.gl, 3553, 10241, 9729);
        if (textureWrapper.clamp) {
          J.texParameteri$3$x(t1.gl, 3553, 10242, 33071);
          J.texParameteri$3$x(t1.gl, 3553, 10243, 33071);
        }
        J.bindTexture$2$x(t1.gl, 3553, null);
        textureWrapper.loaded = true;
        line = "loaded: " + H.S(url);
        H.printString(line);
      }
      this.callBackFunc_1.call$0();
    }
  },
  TextureWrapper: {
    "^": "Object;texture<,image<,loaded>,clamp",
    TextureWrapper$2: function(gl, clamp) {
      this.texture = J.createTexture$0$x(gl);
      this.clamp = clamp == null ? false : clamp;
    },
    static: {TextureWrapper$: function(gl, clamp) {
        var e, t1;
        e = document.createElement("img", null);
        t1 = new B.TextureWrapper(null, e, false, false);
        t1.TextureWrapper$2(gl, clamp);
        return t1;
      }}
  },
  Utils: {
    "^": "Object;chronosGL,gl,textureCache",
    getWall$2: function(texture, size) {
      var t1 = -1 * size;
      return B.Mesh$(new B.MeshData([t1, t1, 0, size, t1, 0, size, size, 0, t1, size, 0], null, null, null, [0, 0, 1, 0, 1, 1, 0, 1], [0, 1, 2, 0, 2, 3], texture, null, false), false);
    },
    loadFile$2: function(url, binary) {
      var c, hr, t1;
      c = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null])), [null]);
      hr = new XMLHttpRequest();
      C.HttpRequest_methods.open$2(hr, "GET", url);
      if (binary)
        hr.responseType = "arraybuffer";
      t1 = H.setRuntimeTypeInfo(new W._EventStream(hr, "loadend", false), [null]);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new B.Utils_loadFile_closure(c, hr)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      hr.send();
      return c.future;
    }
  },
  Utils_loadFile_closure: {
    "^": "Closure:8;c_0,hr_1",
    call$1: function(e) {
      this.c_0.complete$1(0, W._convertNativeToDart_XHR_Response(this.hr_1.response));
    }
  }
}],
["chronosmath", "package:chronosgl/chronosmath.dart", , Q, {
  "^": "",
  Matrix4: {
    "^": "Object;array<,newBack,newUp,newRight",
    $index: function(_, index) {
      var t1 = this.array;
      if (index >>> 0 !== index || index >= 16)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this.array;
      if (index >>> 0 !== index || index >= 16)
        return H.ioore(t1, index);
      t1[index] = value;
    },
    clear$0: function(_) {
      var t1, i;
      for (t1 = this.array, i = 0; i < 16; ++i)
        t1[i] = 0;
    },
    identity$0: function() {
      var t1, i;
      for (t1 = this.array, i = 0; i < 16; ++i)
        t1[i] = C.JSInt_methods.$mod(i, 5) === 0 ? 1 : 0;
      return this;
    },
    invert$0: function() {
      var t1, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, d, invDet, t2, t3;
      t1 = this.array;
      a00 = t1[0];
      a01 = t1[1];
      a02 = t1[2];
      a03 = t1[3];
      a10 = t1[4];
      a11 = t1[5];
      a12 = t1[6];
      a13 = t1[7];
      a20 = t1[8];
      a21 = t1[9];
      a22 = t1[10];
      a23 = t1[11];
      a30 = t1[12];
      a31 = t1[13];
      a32 = t1[14];
      a33 = t1[15];
      b00 = a00 * a11 - a01 * a10;
      b01 = a00 * a12 - a02 * a10;
      b02 = a00 * a13 - a03 * a10;
      b03 = a01 * a12 - a02 * a11;
      b04 = a01 * a13 - a03 * a11;
      b05 = a02 * a13 - a03 * a12;
      b06 = a20 * a31 - a21 * a30;
      b07 = a20 * a32 - a22 * a30;
      b08 = a20 * a33 - a23 * a30;
      b09 = a21 * a32 - a22 * a31;
      b10 = a21 * a33 - a23 * a31;
      b11 = a22 * a33 - a23 * a32;
      d = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (d === 0)
        return false;
      invDet = 1 / d;
      t1[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      t1[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      t1[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      t1[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      t2 = -a10;
      t1[4] = (t2 * b11 + a12 * b08 - a13 * b07) * invDet;
      t1[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      t3 = -a30;
      t1[6] = (t3 * b05 + a32 * b02 - a33 * b01) * invDet;
      t1[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      t1[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      t1[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      t1[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      t1[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      t1[12] = (t2 * b09 + a11 * b07 - a12 * b06) * invDet;
      t1[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      t1[14] = (t3 * b03 + a31 * b01 - a32 * b00) * invDet;
      t1[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
      return true;
    },
    rotate$2: function(_, angle, axis) {
      var t1, t2, x, y, z, len, s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, t3, b02, b10, b11, b12, b20, b21, b22;
      t1 = axis.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      x = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      y = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      z = t1[2];
      len = Math.sqrt(H.checkNum(x * x + y * y + z * z));
      if (len === 0)
        return;
      if (len !== 1) {
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
      }
      s = Math.sin(H.checkNum(angle));
      c = Math.cos(H.checkNum(angle));
      t = 1 - c;
      t1 = this.array;
      a00 = t1[0];
      a01 = t1[1];
      a02 = t1[2];
      a03 = t1[3];
      a10 = t1[4];
      a11 = t1[5];
      a12 = t1[6];
      a13 = t1[7];
      a20 = t1[8];
      a21 = t1[9];
      a22 = t1[10];
      a23 = t1[11];
      b00 = x * x * t + c;
      t2 = z * s;
      b01 = y * x * t + t2;
      t3 = y * s;
      b02 = z * x * t - t3;
      b10 = x * y * t - t2;
      b11 = y * y * t + c;
      t2 = x * s;
      b12 = z * y * t + t2;
      b20 = x * z * t + t3;
      b21 = y * z * t - t2;
      b22 = z * z * t + c;
      t1[0] = a00 * b00 + a10 * b01 + a20 * b02;
      t1[1] = a01 * b00 + a11 * b01 + a21 * b02;
      t1[2] = a02 * b00 + a12 * b01 + a22 * b02;
      t1[3] = a03 * b00 + a13 * b01 + a23 * b02;
      t1[4] = a00 * b10 + a10 * b11 + a20 * b12;
      t1[5] = a01 * b10 + a11 * b11 + a21 * b12;
      t1[6] = a02 * b10 + a12 * b11 + a22 * b12;
      t1[7] = a03 * b10 + a13 * b11 + a23 * b12;
      t1[8] = a00 * b20 + a10 * b21 + a20 * b22;
      t1[9] = a01 * b20 + a11 * b21 + a21 * b22;
      t1[10] = a02 * b20 + a12 * b21 + a22 * b22;
      t1[11] = a03 * b20 + a13 * b21 + a23 * b22;
    },
    rotateX$1: function(angle) {
      var s, c, t1, a10, a11, a12, a13, a20, a21, a22, a23, t2;
      s = Math.sin(H.checkNum(angle));
      c = Math.cos(H.checkNum(angle));
      t1 = this.array;
      a10 = t1[4];
      a11 = t1[5];
      a12 = t1[6];
      a13 = t1[7];
      a20 = t1[8];
      a21 = t1[9];
      a22 = t1[10];
      a23 = t1[11];
      t1[4] = a10 * c + a20 * s;
      t1[5] = a11 * c + a21 * s;
      t1[6] = a12 * c + a22 * s;
      t1[7] = a13 * c + a23 * s;
      t2 = -s;
      t1[8] = a10 * t2 + a20 * c;
      t1[9] = a11 * t2 + a21 * c;
      t1[10] = a12 * t2 + a22 * c;
      t1[11] = a13 * t2 + a23 * c;
    },
    rotateY$1: function(angle) {
      var s, c, t1, a00, a01, a02, a03, a20, a21, a22, a23, t2;
      s = Math.sin(H.checkNum(angle));
      c = Math.cos(H.checkNum(angle));
      t1 = this.array;
      a00 = t1[0];
      a01 = t1[1];
      a02 = t1[2];
      a03 = t1[3];
      a20 = t1[8];
      a21 = t1[9];
      a22 = t1[10];
      a23 = t1[11];
      t2 = -s;
      t1[0] = a00 * c + a20 * t2;
      t1[1] = a01 * c + a21 * t2;
      t1[2] = a02 * c + a22 * t2;
      t1[3] = a03 * c + a23 * t2;
      t1[8] = a00 * s + a20 * c;
      t1[9] = a01 * s + a21 * c;
      t1[10] = a02 * s + a22 * c;
      t1[11] = a03 * s + a23 * c;
    },
    rotateZ$1: function(angle) {
      var s, c, t1, a00, a01, a02, a03, a10, a11, a12, a13, t2;
      s = Math.sin(H.checkNum(angle));
      c = Math.cos(H.checkNum(angle));
      t1 = this.array;
      a00 = t1[0];
      a01 = t1[1];
      a02 = t1[2];
      a03 = t1[3];
      a10 = t1[4];
      a11 = t1[5];
      a12 = t1[6];
      a13 = t1[7];
      t1[0] = a00 * c + a10 * s;
      t1[1] = a01 * c + a11 * s;
      t1[2] = a02 * c + a12 * s;
      t1[3] = a03 * c + a13 * s;
      t2 = -s;
      t1[4] = a00 * t2 + a10 * c;
      t1[5] = a01 * t2 + a11 * c;
      t1[6] = a02 * t2 + a12 * c;
      t1[7] = a03 * t2 + a13 * c;
    },
    setElements$1: function(other) {
      var t1, t2, i;
      for (t1 = this.array, t2 = other.array, i = 0; i < 16; ++i)
        t1[i] = t2[i];
    },
    lookAt_alt$3: function(eye, target, up) {
      var t1, t2, t3, t4, t5, t6, x, y, z, len, t7;
      t1 = this.newBack;
      t2 = eye.array;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      t4 = t2[0];
      t5 = target.array;
      t6 = t5.length;
      if (0 >= t6)
        return H.ioore(t5, 0);
      x = t4 - t5[0];
      if (1 >= t3)
        return H.ioore(t2, 1);
      t4 = t2[1];
      if (1 >= t6)
        return H.ioore(t5, 1);
      y = t4 - t5[1];
      if (2 >= t3)
        return H.ioore(t2, 2);
      t2 = t2[2];
      if (2 >= t6)
        return H.ioore(t5, 2);
      z = t2 - t5[2];
      len = Math.sqrt(H.checkNum(x * x + y * y + z * z));
      t2 = t1.array;
      if (len === 0) {
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        t2[0] = 0;
        if (1 >= t3)
          return H.ioore(t2, 1);
        t2[1] = 0;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t2[2] = 0;
      } else {
        len = 1 / len;
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        t2[0] = x * len;
        if (1 >= t3)
          return H.ioore(t2, 1);
        t2[1] = y * len;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t2[2] = z * len;
      }
      t2 = this.newRight;
      t2.cross2$2(up, t1);
      t2.normalize$0(0);
      t3 = this.newUp;
      t3.cross2$2(t1, t2);
      t4 = this.array;
      t2 = t2.array;
      t5 = t2.length;
      if (0 >= t5)
        return H.ioore(t2, 0);
      t4[0] = t2[0];
      t3 = t3.array;
      t6 = t3.length;
      if (0 >= t6)
        return H.ioore(t3, 0);
      t4[1] = t3[0];
      t1 = t1.array;
      t7 = t1.length;
      if (0 >= t7)
        return H.ioore(t1, 0);
      t4[2] = t1[0];
      t4[3] = 0;
      if (1 >= t5)
        return H.ioore(t2, 1);
      t4[4] = t2[1];
      if (1 >= t6)
        return H.ioore(t3, 1);
      t4[5] = t3[1];
      if (1 >= t7)
        return H.ioore(t1, 1);
      t4[6] = t1[1];
      t4[7] = 0;
      if (2 >= t5)
        return H.ioore(t2, 2);
      t4[8] = t2[2];
      if (2 >= t6)
        return H.ioore(t3, 2);
      t4[9] = t3[2];
      if (2 >= t7)
        return H.ioore(t1, 2);
      t4[10] = t1[2];
      t4[11] = 0;
      t4[15] = 1;
    },
    toString$0: function(_) {
      return C.JSString_methods.$add("", C.NativeFloat32List_methods.toString$0(this.array));
    },
    scale$1: function(_, factor) {
      var t1 = this.array;
      t1[0] = t1[0] * factor;
      t1[1] = t1[1] * factor;
      t1[2] = t1[2] * factor;
      t1[3] = t1[3] * factor;
      t1[4] = t1[4] * factor;
      t1[5] = t1[5] * factor;
      t1[6] = t1[6] * factor;
      t1[7] = t1[7] * factor;
      t1[8] = t1[8] * factor;
      t1[9] = t1[9] * factor;
      t1[10] = t1[10] * factor;
      t1[11] = t1[11] * factor;
    },
    static: {"^": "Matrix4_RIGHTX,Matrix4_RIGHTY,Matrix4_RIGHTZ,Matrix4_UPX,Matrix4_UPY,Matrix4_UPZ,Matrix4_BACKX,Matrix4_BACKY,Matrix4_BACKZ,Matrix4_POSX,Matrix4_POSY,Matrix4_POSZ"}
  },
  Vector: {
    "^": "Object;array<,m,_v",
    get$x: function(_) {
      var t1 = this.array;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$y: function(_) {
      var t1 = this.array;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    $index: function(_, index) {
      var t1 = this.array;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1 = this.array;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
    },
    set$1: function(v) {
      var t1, t2, t3;
      t1 = this.array;
      t2 = J.getInterceptor$asx(v);
      t3 = t2.$index(v, 0);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = t3;
      t3 = this.array;
      t1 = t2.$index(v, 1);
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      t3[1] = t1;
      t1 = this.array;
      t2 = t2.$index(v, 2);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2] = t2;
      return this;
    },
    add$1: function(_, v) {
      var t1, t2, t3, t4, t5;
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = v.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t1[0] = t3 + t4[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t1[1] = t3 + t4[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t2 = t1[2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t1[2] = t2 + t4[2];
      return this;
    },
    subtract$1: function(v) {
      var t1, t2, t3, t4;
      t1 = this.array;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = t1[0];
      t3 = J.getInterceptor$asx(v);
      t4 = t3.$index(v, 0);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t1[0] = t2 - t4;
      t4 = this.array;
      if (1 >= t4.length)
        return H.ioore(t4, 1);
      t2 = t4[1];
      t1 = t3.$index(v, 1);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t4[1] = t2 - t1;
      t1 = this.array;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t2 = t1[2];
      t3 = t3.$index(v, 2);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1[2] = t2 - t3;
      return this;
    },
    scale$1: function(_, val) {
      var t1, t2, t3;
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (typeof val !== "number")
        return H.iae(val);
      t1[0] = t3 * val;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = t1[1] * val;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = t1[2] * val;
      return this;
    },
    addScaledVector$2: function(v, val) {
      var t1, t2, t3, t4, t5;
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = v.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t1[0] = t3 + t4[0] * val;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t1[1] = t3 + t4[1] * val;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t2 = t1[2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      t1[2] = t2 + t4[2] * val;
      return this;
    },
    normalize$0: function(_) {
      var t1, t2, x, y, z, len;
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      x = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      y = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      z = t1[2];
      len = Math.sqrt(H.checkNum(x * x + y * y + z * z));
      if (len === 0) {
        t1 = this.array;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t1[0] = 0;
        if (1 >= t2)
          return H.ioore(t1, 1);
        t1[1] = 0;
        if (2 >= t2)
          return H.ioore(t1, 2);
        t1[2] = 0;
      } else {
        t1 = this.array;
        if (len === 1) {
          t2 = t1.length;
          if (0 >= t2)
            return H.ioore(t1, 0);
          t1[0] = x;
          if (1 >= t2)
            return H.ioore(t1, 1);
          t1[1] = y;
          if (2 >= t2)
            return H.ioore(t1, 2);
          t1[2] = z;
        } else {
          len = 1 / len;
          t2 = t1.length;
          if (0 >= t2)
            return H.ioore(t1, 0);
          t1[0] = x * len;
          if (1 >= t2)
            return H.ioore(t1, 1);
          t1[1] = y * len;
          if (2 >= t2)
            return H.ioore(t1, 2);
          t1[2] = z * len;
        }
      }
      return this;
    },
    cross2$2: function(vec1, vec2) {
      var t1, t2, x, y, z, x2, y2, z2;
      t1 = vec1.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      x = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      y = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      z = t1[2];
      t1 = vec2.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      x2 = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      y2 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      z2 = t1[2];
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t1[0] = y * z2 - z * y2;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t1[1] = z * x2 - x * z2;
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1[2] = x * y2 - y * x2;
      return this;
    },
    dot$1: function(vec2) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      t4 = vec2.array;
      t5 = t4.length;
      if (0 >= t5)
        return H.ioore(t4, 0);
      t6 = t4[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      t7 = t1[1];
      if (1 >= t5)
        return H.ioore(t4, 1);
      t8 = t4[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      if (2 >= t5)
        return H.ioore(t4, 2);
      return t3 * t6 + t7 * t8 + t1 * t4[2];
    },
    dist$1: function(to) {
      var t1, t2, t3, x, y, z;
      t1 = J.getInterceptor$asx(to);
      t2 = t1.$index(to, 0);
      t3 = this.array;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      x = J.$sub$n(t2, t3[0]);
      t3 = t1.$index(to, 1);
      t2 = this.array;
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      y = J.$sub$n(t3, t2[1]);
      t1 = t1.$index(to, 2);
      t2 = this.array;
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      z = J.$sub$n(t1, t2[2]);
      return Math.sqrt(H.checkNum(J.$add$ns(J.$add$ns(J.$mul$ns(x, x), J.$mul$ns(y, y)), J.$mul$ns(z, z))));
    },
    length$0: [function(_) {
      var t1, t2, x, y, z;
      t1 = this.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      x = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      y = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      z = t1[2];
      return Math.sqrt(H.checkNum(x * x + y * y + z * z));
    }, "call$0", "get$length", 0, 0, 18],
    toString$0: function(_) {
      return C.NativeFloat32List_methods.toString$0(this.array);
    },
    Vector$fromVector$1: function(vector) {
      var t1, t2, t3, t4;
      t1 = H._checkLength(3);
      t2 = new Float32Array(t1);
      this.array = t2;
      t3 = J.getInterceptor$asx(vector);
      t4 = t3.$index(vector, 0);
      if (0 >= t1)
        return H.ioore(t2, 0);
      t2[0] = t4;
      t4 = this.array;
      t2 = t3.$index(vector, 1);
      if (1 >= t4.length)
        return H.ioore(t4, 1);
      t4[1] = t2;
      t2 = this.array;
      t3 = t3.$index(vector, 2);
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      t2[2] = t3;
    },
    Vector$fromList$1: function(list) {
      var t1, t2, t3, t4;
      t1 = H._checkLength(3);
      t2 = new Float32Array(t1);
      this.array = t2;
      t3 = list.length;
      if (0 >= t3)
        return H.ioore(list, 0);
      t4 = list[0];
      if (0 >= t1)
        return H.ioore(t2, 0);
      t2[0] = t4;
      if (1 >= t3)
        return H.ioore(list, 1);
      t4 = list[1];
      if (1 >= t1)
        return H.ioore(t2, 1);
      t2[1] = t4;
      if (2 >= t3)
        return H.ioore(list, 2);
      t3 = list[2];
      if (2 >= t1)
        return H.ioore(t2, 2);
      t2[2] = t3;
    },
    Vector$3: function(x, y, z) {
      var t1, t2;
      t1 = H._checkLength(3);
      t2 = new Float32Array(t1);
      this.array = t2;
      if (0 >= t1)
        return H.ioore(t2, 0);
      t2[0] = x;
      if (1 >= t1)
        return H.ioore(t2, 1);
      t2[1] = y;
      if (2 >= t1)
        return H.ioore(t2, 2);
      t2[2] = z;
    },
    static: {Vector$fromList: function(list) {
        var t1 = new Q.Vector(null, null, H.setRuntimeTypeInfo(Array(4), [P.$double]));
        t1.Vector$fromList$1(list);
        return t1;
      }, Vector$fromVector: function(vector) {
        var t1 = new Q.Vector(null, null, H.setRuntimeTypeInfo(Array(4), [P.$double]));
        t1.Vector$fromVector$1(vector);
        return t1;
      }, Vector$: function(x, y, z) {
        var t1 = new Q.Vector(null, null, H.setRuntimeTypeInfo(Array(4), [P.$double]));
        t1.Vector$3(x, y, z);
        return t1;
      }}
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableMixinWorkaround__rangeCheck: function(list, start, end) {
    if (start < 0 || start > list.length)
      throw H.wrapException(P.RangeError$range(start, 0, list.length, null, null));
    if (end < start || end > list.length)
      throw H.wrapException(P.RangeError$range(end, start, list.length, null, null));
  },
  IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
    var $length;
    H.IterableMixinWorkaround__rangeCheck(list, start, end);
    $length = end - start;
    if ($length === 0)
      return;
    if (skipCount < 0)
      throw H.wrapException(P.ArgumentError$(skipCount));
    if (skipCount + $length > from.length)
      throw H.wrapException(H.IterableElementError_tooFew());
    H.Lists_copy(from, skipCount, list, start, $length);
  },
  IterableMixinWorkaround_fillRangeList: function(list, start, end, fillValue) {
    var i;
    H.IterableMixinWorkaround__rangeCheck(list, start, end);
    for (i = start; i < end; ++i)
      C.JSArray_methods.$indexSet(list, i, fillValue);
  },
  IterableMixinWorkaround_setAllList: function(list, index, iterable) {
    var t1, index0;
    if (index > list.length)
      throw H.wrapException(P.RangeError$range(index, 0, list.length, null, null));
    for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0(); index = index0) {
      index0 = index + 1;
      C.JSArray_methods.$indexSet(list, index, t1.__internal$_current);
    }
  },
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var i, j, t1;
    if (srcStart < dstStart)
      for (i = srcStart + count - 1, j = dstStart + count - 1; i >= srcStart; --i, --j) {
        if (i < 0 || i >= src.length)
          return H.ioore(src, i);
        C.JSArray_methods.$indexSet(dst, j, src[i]);
      }
    else
      for (t1 = srcStart + count, j = dstStart, i = srcStart; i < t1; ++i, ++j) {
        if (i < 0 || i >= src.length)
          return H.ioore(src, i);
        C.JSArray_methods.$indexSet(dst, j, src[i]);
      }
  },
  Symbol_getName: function(symbol) {
    return symbol.get$_name();
  },
  ListIterator: {
    "^": "Object;_iterable,__internal$_length,_index,__internal$_current",
    get$current: function() {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (t3 >= $length) {
        this.__internal$_current = null;
        return false;
      }
      this.__internal$_current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = this._iterable;
      t1 = new H.MappedIterator(null, t1.get$iterator(t1), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      var t1 = this._iterable;
      return t1.get$length(t1);
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f"
  },
  MappedIterator: {
    "^": "Iterator;__internal$_current,_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this.__internal$_current = this._f$1(t1.get$current());
        return true;
      }
      this.__internal$_current = null;
      return false;
    },
    get$current: function() {
      return this.__internal$_current;
    }
  },
  FixedLengthListMixin: {
    "^": "Object;"
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(function(victim, hasOwnProperty) {
      var result = [];
      for (var key in victim) {
        if (hasOwnProperty.call(victim, key))
          result.push(key);
      }
      return result;
    }(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = Array;
    return t1;
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return P._AsyncRun__scheduleImmediateJsOverride$closure();
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1.storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    } else if (self.setImmediate != null)
      return P._AsyncRun__scheduleImmediateWithSetImmediate$closure();
    return P._AsyncRun__scheduleImmediateWithTimer$closure();
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 0],
  _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateWithSetImmediate$closure", 2, 0, 0],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, callback);
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 0],
  _registerErrorHandler: function(errorHandler, zone) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1) {
      zone.toString;
      return errorHandler;
    } else {
      zone.toString;
      return errorHandler;
    }
  },
  Future_wait: function(futures, eagerError) {
    var t1, result, t2, t3, values;
    t1 = {};
    result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.List]);
    t1.values_0 = null;
    t1.remaining_1 = 0;
    t1.error_2 = null;
    t1.stackTrace_3 = null;
    t2 = new P.Future_wait_handleError(t1, eagerError, result);
    for (t3 = new H.ListIterator(futures, futures.length, 0, null); t3.moveNext$0();)
      t3.__internal$_current.then$2$onError(new P.Future_wait_closure(t1, eagerError, result, t1.remaining_1++), t2);
    t2 = t1.remaining_1;
    if (t2 === 0) {
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._asyncComplete$1(C.List_empty);
      return t1;
    }
    values = Array(t2);
    values.fixed$length = init;
    t1.values_0 = values;
    return result;
  },
  _completeWithErrorCallback: function(result, error, stackTrace) {
    $.Zone__current.toString;
    result._completeError$2(error, stackTrace);
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.next;
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 1],
  _scheduleAsyncCallback: function(callback) {
    var t1, newEntry;
    if ($._nextCallback == null) {
      t1 = new P._AsyncCallbackEntry(callback, null);
      $._lastCallback = t1;
      $._nextCallback = t1;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      newEntry = new P._AsyncCallbackEntry(callback, null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  },
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, replacement, error, stackTrace, exception, t1;
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      $.Zone__current.toString;
      replacement = null;
      if (replacement == null)
        onError.call$2(e, s);
      else {
        t1 = J.get$error$x(replacement);
        error = t1;
        stackTrace = replacement.get$stackTrace();
        onError.call$2(error, stackTrace);
      }
    }

  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0(0);
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0(0);
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  Timer_Timer: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createTimer(duration, callback);
    }
    return P.Timer__createTimer(duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  Timer__createTimer: function(duration, callback) {
    var milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var t1, entry, t2;
    t1 = new P._rootHandleUncaughtError_closure(error, stackTrace);
    entry = new P._AsyncCallbackEntry(t1, null);
    t2 = $._nextCallback;
    if (t2 == null) {
      P._scheduleAsyncCallback(t1);
      $._lastPriorityCallback = $._lastCallback;
    } else {
      t1 = $._lastPriorityCallback;
      if (t1 == null) {
        entry.next = t2;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t1.next;
        t1.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    var t1 = C.C__RootZone !== zone;
    if (t1)
      f = zone.bindCallback$2$runGuarded(f, !(!t1 || C.C__RootZone.get$errorZone() === zone));
    P._scheduleAsyncCallback(f);
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:8;box_0",
    call$1: function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this.box_0;
      f = t1.storedCallback_0;
      t1.storedCallback_0 = null;
      f.call$0();
    }
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:19;box_0,div_1,span_2",
    call$1: function(callback) {
      var t1, t2;
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      this.box_0.storedCallback_0 = callback;
      t1 = this.div_1;
      t2 = this.span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    }
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:6;callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }
  },
  _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
    "^": "Closure:6;callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }
  },
  _UncaughtAsyncError: {
    "^": "AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + H.S(t1)) : result;
    },
    static: {_UncaughtAsyncError$: function(error, stackTrace) {
        return new P._UncaughtAsyncError(error, P._UncaughtAsyncError__getBestStackTrace(error, stackTrace));
      }, _UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  Future: {
    "^": "Object;",
    $isFuture: true
  },
  Future_wait_handleError: {
    "^": "Closure:7;box_0,eagerError_1,result_2",
    call$2: function(theError, theStackTrace) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = t1.values_0;
      t1.values_0 = null;
      t3 = --t1.remaining_1;
      if (t2 != null)
        if (t3 === 0 || this.eagerError_1)
          this.result_2._completeError$2(theError, theStackTrace);
        else {
          t1.error_2 = theError;
          t1.stackTrace_3 = theStackTrace;
        }
      else if (t3 === 0 && !this.eagerError_1)
        this.result_2._completeError$2(t1.error_2, t1.stackTrace_3);
    }
  },
  Future_wait_closure: {
    "^": "Closure:20;box_0,eagerError_3,result_4,pos_5",
    call$1: function(value) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = --t1.remaining_1;
      t3 = t1.values_0;
      if (t3 != null) {
        t1 = this.pos_5;
        if (t1 < 0 || t1 >= t3.length)
          return H.ioore(t3, t1);
        t3[t1] = value;
        if (t2 === 0)
          this.result_4._completeWithValue$1(t3);
      } else if (t2 === 0 && !this.eagerError_3)
        this.result_4._completeError$2(t1.error_2, t1.stackTrace_3);
    }
  },
  _Completer: {
    "^": "Object;",
    completeError$2: function(error, stackTrace) {
      error = error != null ? error : new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      $.Zone__current.toString;
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    }
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    complete$1: function(_, value) {
      var t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  },
  _FutureListener: {
    "^": "Object;_nextListener<,result>,state,callback,errorCallback",
    get$_zone: function() {
      return this.result._zone;
    },
    get$handlesValue: function() {
      return (this.state & 1) !== 0;
    },
    get$hasErrorTest: function() {
      return this.state === 6;
    },
    get$handlesComplete: function() {
      return this.state === 8;
    },
    get$_onValue: function() {
      return this.callback;
    },
    get$_whenCompleteAction: function() {
      return this.callback;
    },
    static: {"^": "_FutureListener_MASK_VALUE,_FutureListener_MASK_ERROR,_FutureListener_MASK_TEST_ERROR,_FutureListener_MASK_WHENCOMPLETE,_FutureListener_STATE_CHAIN,_FutureListener_STATE_THEN,_FutureListener_STATE_THEN_ONERROR,_FutureListener_STATE_CATCHERROR,_FutureListener_STATE_CATCHERROR_TEST,_FutureListener_STATE_WHENCOMPLETE"}
  },
  _Future: {
    "^": "Object;_state,_zone<,_resultOrListeners",
    get$_hasError: function() {
      return this._state === 8;
    },
    set$_isChained: function(value) {
      if (value)
        this._state = 2;
      else
        this._state = 0;
    },
    then$2$onError: function(f, onError) {
      var result, t1;
      result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1 = result._zone;
      if (t1 !== C.C__RootZone) {
        t1.toString;
        if (onError != null)
          onError = P._registerErrorHandler(onError, t1);
      }
      t1 = onError == null ? 1 : 3;
      this._addListener$1(new P._FutureListener(null, result, t1, f, onError));
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      t1 = $.Zone__current;
      result = new P._Future(0, t1, null);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      if (t1 !== C.C__RootZone)
        t1.toString;
      this._addListener$1(new P._FutureListener(null, result, 8, action, null));
      return result;
    },
    _markPendingCompletion$0: function() {
      if (this._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      this._state = 1;
    },
    get$_async$_value: function() {
      return this._resultOrListeners;
    },
    get$_error: function() {
      return this._resultOrListeners;
    },
    _setValue$1: function(value) {
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setErrorObject$1: function(error) {
      this._state = 8;
      this._resultOrListeners = error;
    },
    _setError$2: function(error, stackTrace) {
      this._setErrorObject$1(new P.AsyncError(error, stackTrace));
    },
    _addListener$1: function(listener) {
      var t1;
      if (this._state >= 4) {
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__addListener_closure(this, listener));
      } else {
        listener._nextListener = this._resultOrListeners;
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      current = this._resultOrListeners;
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current.get$_nextListener();
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners = this._removeListeners$0();
      this._setErrorObject$1(new P.AsyncError(error, stackTrace));
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 21, 14],
    _asyncComplete$1: function(value) {
      var t1;
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          if (!!t1.$is_Future) {
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              this._markPendingCompletion$0();
              t1 = this._zone;
              t1.toString;
              P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        }
      }
      this._markPendingCompletion$0();
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure0(this, value));
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1;
      this._markPendingCompletion$0();
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    $is_Future: true,
    $isFuture: true,
    static: {"^": "_Future__INCOMPLETE,_Future__PENDING_COMPLETE,_Future__CHAINED,_Future__VALUE,_Future__ERROR", _Future__chainForeignFuture: function(source, target) {
        target._state = 2;
        source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
      }, _Future__chainCoreFuture: function(source, target) {
        var listener;
        target._state = 2;
        listener = new P._FutureListener(null, target, 0, null, null);
        if (source._state >= 4)
          P._Future__propagateToListeners(source, listener);
        else
          source._addListener$1(listener);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, hasError, asyncError, t4, listeners0, sourceValue, zone, oldZone, chainSource, result;
        t1 = {};
        t1.source_4 = source;
        for (t2 = source; true;) {
          t3 = {};
          hasError = t2.get$_hasError();
          if (listeners == null) {
            if (hasError) {
              asyncError = t1.source_4.get$_error();
              t2 = t1.source_4.get$_zone();
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
            }
            return;
          }
          for (; listeners.get$_nextListener() != null; listeners = listeners0) {
            listeners0 = listeners._nextListener;
            listeners._nextListener = null;
            P._Future__propagateToListeners(t1.source_4, listeners);
          }
          t3.listenerHasValue_1 = true;
          sourceValue = hasError ? null : t1.source_4.get$_async$_value();
          t3.listenerValueOrError_2 = sourceValue;
          t3.isPropagationAborted_3 = false;
          t2 = !hasError;
          if (!t2 || listeners.get$handlesValue() || listeners.state === 8) {
            zone = listeners.get$_zone();
            if (hasError) {
              t4 = t1.source_4.get$_zone();
              t4.toString;
              if (t4 == null ? zone != null : t4 !== zone) {
                t4 = t4.get$errorZone();
                zone.toString;
                t4 = t4 === zone;
              } else
                t4 = true;
              t4 = !t4;
            } else
              t4 = false;
            if (t4) {
              asyncError = t1.source_4.get$_error();
              t2 = t1.source_4.get$_zone();
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
              return;
            }
            oldZone = $.Zone__current;
            if (oldZone == null ? zone != null : oldZone !== zone)
              $.Zone__current = zone;
            else
              oldZone = null;
            if (t2) {
              if (listeners.get$handlesValue())
                t3.listenerHasValue_1 = new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0();
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if (listeners.get$handlesComplete())
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null)
              $.Zone__current = oldZone;
            if (t3.isPropagationAborted_3)
              return;
            if (t3.listenerHasValue_1 === true) {
              t2 = t3.listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = t3.listenerValueOrError_2;
              result = listeners.result;
              if (!!J.getInterceptor(chainSource).$is_Future)
                if (chainSource._state >= 4) {
                  result._state = 2;
                  t1.source_4 = chainSource;
                  listeners = new P._FutureListener(null, result, 0, null, null);
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, result);
              else
                P._Future__chainForeignFuture(chainSource, result);
              return;
            }
          }
          result = listeners.result;
          listeners = result._removeListeners$0();
          t2 = t3.listenerHasValue_1;
          t3 = t3.listenerValueOrError_2;
          if (t2 === true) {
            result._state = 4;
            result._resultOrListeners = t3;
          } else {
            result._state = 8;
            result._resultOrListeners = t3;
          }
          t1.source_4 = result;
          t2 = result;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:6;this_0,listener_1",
    call$0: function() {
      P._Future__propagateToListeners(this.this_0, this.listener_1);
    }
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:8;target_0",
    call$1: function(value) {
      this.target_0._completeWithValue$1(value);
    }
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:22;target_1",
    call$2: function(error, stackTrace) {
      this.target_1._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:6;this_0,coreFuture_1",
    call$0: function() {
      P._Future__chainCoreFuture(this.coreFuture_1, this.this_0);
    }
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:6;this_2,value_3",
    call$0: function() {
      this.this_2._completeWithValue$1(this.value_3);
    }
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:6;this_0,error_1,stackTrace_2",
    call$0: function() {
      this.this_0._completeError$2(this.error_1, this.stackTrace_2);
    }
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:23;box_1,listener_3,sourceValue_4,zone_5",
    call$0: function() {
      var e, s, exception, t1;
      try {
        this.box_1.listenerValueOrError_2 = this.zone_5.runUnary$2(this.listener_3.get$_onValue(), this.sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.box_1.listenerValueOrError_2 = new P.AsyncError(e, s);
        return false;
      }

    }
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:1;box_2,box_1,listener_6,zone_7",
    call$0: function() {
      var asyncError, matchesTest, test, e, s, errorCallback, e0, s0, t1, exception, t2, listenerValueOrError, t3, t4;
      asyncError = this.box_2.source_4.get$_error();
      matchesTest = true;
      t1 = this.listener_6;
      if (t1.get$hasErrorTest()) {
        test = t1.callback;
        try {
          matchesTest = this.zone_7.runUnary$2(test, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e, s);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

      }
      errorCallback = t1.errorCallback;
      if (matchesTest === true && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this.zone_7;
          t4 = this.box_1;
          if (t2)
            t4.listenerValueOrError_2 = t3.runBinary$3(errorCallback, J.get$error$x(asyncError), asyncError.get$stackTrace());
          else
            t4.listenerValueOrError_2 = t3.runUnary$2(errorCallback, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e0, s0);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

        this.box_1.listenerHasValue_1 = true;
      } else {
        t1 = this.box_1;
        t1.listenerValueOrError_2 = asyncError;
        t1.listenerHasValue_1 = false;
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:1;box_2,box_1,hasError_8,listener_9,zone_10",
    call$0: function() {
      var t1, e, s, completeResult, t2, exception, result;
      t1 = {};
      t1.completeResult_0 = null;
      try {
        completeResult = this.zone_10.run$1(this.listener_9.get$_whenCompleteAction());
        t1.completeResult_0 = completeResult;
        t2 = completeResult;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        if (this.hasError_8) {
          t1 = J.get$error$x(this.box_2.source_4.get$_error());
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        t2 = this.box_1;
        if (t1)
          t2.listenerValueOrError_2 = this.box_2.source_4.get$_error();
        else
          t2.listenerValueOrError_2 = new P.AsyncError(e, s);
        t2.listenerHasValue_1 = false;
        return;
      }

      if (!!J.getInterceptor(t2).$isFuture) {
        t2 = this.listener_9;
        result = t2.get$result(t2);
        result.set$_isChained(true);
        this.box_1.isPropagationAborted_3 = true;
        t1.completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this.box_2, result), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, result));
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:8;box_2,result_11",
    call$1: function(ignored) {
      P._Future__propagateToListeners(this.box_2.source_4, new P._FutureListener(null, this.result_11, 0, null, null));
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:22;box_0,result_12",
    call$2: function(error, stackTrace) {
      var t1, completeResult;
      t1 = this.box_0;
      if (!J.getInterceptor(t1.completeResult_0).$is_Future) {
        completeResult = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1.completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1.completeResult_0, new P._FutureListener(null, this.result_12, 0, null, null));
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    forEach$1: function(_, action) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.$int]);
      t1.count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$first: function(_) {
      var t1, future;
      t1 = {};
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
      return future;
    }
  },
  Stream_forEach_closure: {
    "^": "Closure;box_0,this_1,action_2,future_3",
    call$1: function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this.action_2, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this.box_0.subscription_0, this.future_3));
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:6;action_4,element_5",
    call$0: function() {
      return this.action_4.call$1(this.element_5);
    }
  },
  Stream_forEach__closure0: {
    "^": "Closure:8;",
    call$1: function(_) {
    }
  },
  Stream_forEach_closure0: {
    "^": "Closure:6;future_6",
    call$0: function() {
      this.future_6._complete$1(null);
    }
  },
  Stream_length_closure: {
    "^": "Closure:8;box_0",
    call$1: function(_) {
      ++this.box_0.count_0;
    }
  },
  Stream_length_closure0: {
    "^": "Closure:6;box_0,future_1",
    call$0: function() {
      this.future_1._complete$1(this.box_0.count_0);
    }
  },
  Stream_first_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: function(value) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_2, value);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_first_closure0: {
    "^": "Closure:6;future_3",
    call$0: function() {
      var e, s, t1, exception;
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        P._completeWithErrorCallback(this.future_3, e, s);
      }

    }
  },
  StreamSubscription: {
    "^": "Object;"
  },
  _EventSink: {
    "^": "Object;"
  },
  _DelayedEvent: {
    "^": "Object;"
  },
  _cancelAndError_closure: {
    "^": "Closure:6;future_0,error_1,stackTrace_2",
    call$0: function() {
      return this.future_0._completeError$2(this.error_1, this.stackTrace_2);
    }
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:24;subscription_0,future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this.subscription_0, this.future_1, error, stackTrace);
    }
  },
  _cancelAndValue_closure: {
    "^": "Closure:6;future_0,value_1",
    call$0: function() {
      return this.future_0._complete$1(this.value_1);
    }
  },
  AsyncError: {
    "^": "Object;error>,stackTrace<",
    toString$0: function(_) {
      return J.toString$0(this.error);
    },
    $isError: true
  },
  _Zone: {
    "^": "Object;"
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:6;error_0,stackTrace_1",
    call$0: function() {
      throw H.wrapException(P._UncaughtAsyncError$(this.error_0, this.stackTrace_1));
    }
  },
  _RootZone: {
    "^": "_Zone;",
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindCallback_closure(this, f);
      else
        return new P._RootZone_bindCallback_closure0(this, f);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindUnaryCallback_closure(this, f);
      else
        return new P._RootZone_bindUnaryCallback_closure0(this, f);
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    runUnary$2: function(f, arg) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2);
    },
    static: {"^": "_RootZone__rootMap,_RootZone__rootDelegate"}
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:6;this_0,f_1",
    call$0: function() {
      return this.this_0.runGuarded$1(this.f_1);
    }
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:6;this_2,f_3",
    call$0: function() {
      return this.this_2.run$1(this.f_3);
    }
  },
  _RootZone_bindUnaryCallback_closure: {
    "^": "Closure:8;this_0,f_1",
    call$1: function(arg) {
      return this.this_0.runUnaryGuarded$2(this.f_1, arg);
    }
  },
  _RootZone_bindUnaryCallback_closure0: {
    "^": "Closure:8;this_2,f_3",
    call$1: function(arg) {
      return this.this_2.runUnary$2(this.f_3, arg);
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 2],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 3],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = P.StringBuffer$(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1.write$1(0, rightDelimiter);
    t1 = t1._contents;
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    J.write$1$x(buffer, rightDelimiter);
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  Maps_mapToString: function(m) {
    var t1, result;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = P.StringBuffer$("");
    try {
      $.get$IterableBase__toStringVisiting().push(m);
      J.write$1$x(result, "{");
      t1.first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      J.write$1$x(result, "}");
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = result.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(0, key);
    },
    _get$1: function(_, key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._keys = null;
        }
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    $asMap: null,
    static: {_HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:8;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      return new P.HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null);
    },
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    }
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_keys,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._keys;
      offset = this._offset;
      t1 = this._map;
      if (keys !== t1._keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$keys: function(_) {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(_, key) {
      var nums;
      if ((key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_value();
      } else
        return this._get$1(0, key);
    },
    _get$1: function(_, key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(0, key);
    },
    _remove$1: function(_, key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_value();
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell.get$_key(cell), cell._value);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(J.get$_key$x(bucket[i]), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    $asMap: null,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:8;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    }
  },
  LinkedHashMapCell: {
    "^": "Object;_key>,_value@,_next@,_previous@"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2._cell = t1._first;
      return t2;
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.get$_key(cell));
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._next;
      }
    }
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_key(t1);
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$iterator: function(_) {
      var t1 = new P.LinkedHashSetIterator(this, this._modifications, null, null);
      t1._cell = this._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index).get$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell.get$_element());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    add$1: function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(0, element);
    },
    _add$1: function(_, element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(0, object);
    },
    _remove$1: function(_, object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_element(), element))
          return i;
      return -1;
    },
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_element<,_next@,_previous@"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_element();
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  _HashSetBase: {
    "^": "SetBase;"
  },
  IterableBase: {
    "^": "Object;",
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element;
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        if (remaining === 0)
          return element;
        --remaining;
      }
      throw H.wrapException(P.RangeError$value(index, null, null));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver), 0, null);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: true,
    $asList: null
  },
  Maps_mapToString_closure: {
    "^": "Closure:7;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(0, ", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(0, k);
      t1.write$1(0, ": ");
      t1.write$1(0, v);
    }
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    get$iterator: function(_) {
      return new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return result;
    },
    _add$1: function(_, element) {
      var t1, t2, t3;
      t1 = this._table;
      t2 = this._tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      C.JSArray_methods.checkMutable$1(newTable, "set range");
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t2 = this._head;
      t1 = this._table;
      C.JSArray_methods.checkMutable$1(newTable, "set range");
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t2, t1, 0);
      this._head = 0;
      this._tail = this._table.length;
      this._table = newTable;
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    static: {"^": "ListQueue__INITIAL_CAPACITY", ListQueue$: function(initialCapacity, $E) {
        var t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [$E]);
        t1.ListQueue$1(initialCapacity, $E);
        return t1;
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._collection$_position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  },
  SetMixin: {
    "^": "Object;",
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1._collection$_current);
    }
  },
  SetBase: {
    "^": "SetMixin;"
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  _symbolToString: function(symbol) {
    return H.Symbol_getName(symbol);
  },
  String__stringFromIterable: function(charCodes, start, end) {
    var it, i, list;
    it = C.NativeUint8List_methods.get$iterator(charCodes);
    for (i = 0; i < start; ++i)
      if (!it.moveNext$0())
        throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
    list = [];
    for (; it.moveNext$0();)
      list.push(it.__internal$_current);
    return H.Primitives_stringFromCharCodes(list);
  },
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 4],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 5],
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = other.get$iterator(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = Array;
    return list;
  },
  List_List$generate: function($length, generator, growable, $E) {
    var result, i, t1;
    if (growable) {
      result = [];
      result.$builtinTypeInfo = [$E];
      C.JSArray_methods.set$length(result, $length);
    } else {
      result = Array($length);
      result.fixed$length = init;
      result.$builtinTypeInfo = [$E];
    }
    for (i = 0; i < $length; ++i) {
      t1 = generator.call$1(i);
      if (i >= result.length)
        return H.ioore(result, i);
      result[i] = t1;
    }
    return result;
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  String_String$fromCharCodes: function(charCodes, start, end) {
    return P.String__stringFromIterable(charCodes, start, end);
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:25;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(0, ", ");
      t1.sb_0.write$1(0, P._symbolToString(key));
    }
  },
  bool: {
    "^": "Object;",
    $isbool: true
  },
  "+bool": 0,
  DateTime: {
    "^": "Object;millisecondsSinceEpoch,isUtc",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDateTime)
        return false;
      return this.millisecondsSinceEpoch === other.millisecondsSinceEpoch && this.isUtc === other.isUtc;
    },
    get$hashCode: function(_) {
      return this.millisecondsSinceEpoch;
    },
    toString$0: function(_) {
      var t1, y, m, d, h, min, sec, ms;
      t1 = this.isUtc;
      y = P.DateTime__fourDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(this).getFullYear() + 0);
      m = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(this).getMonth() + 1);
      d = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(this).getDate() + 0);
      h = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(this).getHours() + 0);
      min = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(this).getMinutes() + 0);
      sec = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0);
      ms = P.DateTime__threeDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(this).getMilliseconds() + 0);
      if (t1)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    DateTime$fromMillisecondsSinceEpoch$2$isUtc: function(millisecondsSinceEpoch, isUtc) {
      if (Math.abs(millisecondsSinceEpoch) > 8640000000000000)
        throw H.wrapException(P.ArgumentError$(millisecondsSinceEpoch));
    },
    $isDateTime: true,
    static: {"^": "DateTime_MONDAY,DateTime_TUESDAY,DateTime_WEDNESDAY,DateTime_THURSDAY,DateTime_FRIDAY,DateTime_SATURDAY,DateTime_SUNDAY,DateTime_DAYS_PER_WEEK,DateTime_JANUARY,DateTime_FEBRUARY,DateTime_MARCH,DateTime_APRIL,DateTime_MAY,DateTime_JUNE,DateTime_JULY,DateTime_AUGUST,DateTime_SEPTEMBER,DateTime_OCTOBER,DateTime_NOVEMBER,DateTime_DECEMBER,DateTime_MONTHS_PER_YEAR,DateTime__MAX_MILLISECONDS_SINCE_EPOCH", DateTime$fromMillisecondsSinceEpoch: function(millisecondsSinceEpoch, isUtc) {
        var t1 = new P.DateTime(millisecondsSinceEpoch, isUtc);
        t1.DateTime$fromMillisecondsSinceEpoch$2$isUtc(millisecondsSinceEpoch, isUtc);
        return t1;
      }, DateTime__fourDigits: function(n) {
        var absN, sign;
        absN = Math.abs(n);
        sign = n < 0 ? "-" : "";
        if (absN >= 1000)
          return "" + n;
        if (absN >= 100)
          return sign + "0" + H.S(absN);
        if (absN >= 10)
          return sign + "00" + H.S(absN);
        return sign + "000" + H.S(absN);
      }, DateTime__threeDigits: function(n) {
        if (n >= 100)
          return "" + n;
        if (n >= 10)
          return "0" + n;
        return "00" + n;
      }, DateTime__twoDigits: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }}
  },
  $double: {
    "^": "num;",
    $is$double: true
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, this._duration + other.get$_duration(), 0, 0, 0);
    },
    $sub: function(_, other) {
      return P.Duration$(0, 0, this._duration - other.get$_duration(), 0, 0, 0);
    },
    $mul: function(_, factor) {
      if (typeof factor !== "number")
        return H.iae(factor);
      return P.Duration$(0, 0, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(this._duration * factor)), 0, 0, 0);
    },
    $lt: function(_, other) {
      return this._duration < other.get$_duration();
    },
    $gt: function(_, other) {
      return this._duration > other.get$_duration();
    },
    $le: function(_, other) {
      return C.JSInt_methods.$le(this._duration, other.get$_duration());
    },
    $ge: function(_, other) {
      return C.JSInt_methods.$ge(this._duration, other.get$_duration());
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSInt_methods.remainder$1(t2, 1000000));
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    abs$0: function(_) {
      return P.Duration$(0, 0, Math.abs(this._duration), 0, 0, 0);
    },
    $negate: function(_) {
      return P.Duration$(0, 0, -this._duration, 0, 0, 0);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:26;",
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    }
  },
  Duration_toString_twoDigits: {
    "^": "Closure:26;",
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    }
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name,message",
    toString$0: function(_) {
      var t1;
      if (!this._hasValue) {
        t1 = this.message;
        return t1 != null ? "Invalid arguments(s): " + H.S(t1) : "Invalid arguments(s)";
      }
      return H.S(this.message) + ": " + H.S(P.Error_safeToString(this.invalidValue));
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start,end,_hasValue,invalidValue,name,message",
    toString$0: function(_) {
      var value, t1, explanation, t2;
      if (!this._hasValue)
        return "RangeError: " + H.S(this.message);
      value = P.Error_safeToString(this.invalidValue);
      t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else {
          if (typeof t2 !== "number")
            return t2.$gt();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (t2 > t1)
            explanation = ": Not in range " + t1 + ".." + t2 + ", inclusive.";
          else
            explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + t1;
        }
      }
      return "RangeError: " + H.S(this.message) + " (" + H.S(value) + ")" + explanation;
    },
    static: {RangeError$value: function(value, $name, message) {
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }, RangeError$range: function(invalidValue, start, end, $name, message) {
        return new P.RangeError(start, end, true, invalidValue, $name, "Invalid value");
      }}
  },
  IndexError: {
    "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message",
    toString$0: function(_) {
      var target, explanation, t1;
      target = P.Error_safeToString(this.indexable);
      explanation = "index should be less than " + this.length;
      t1 = this.invalidValue;
      if (J.$lt$n(t1, 0))
        explanation = "index must not be negative";
      return "RangeError: " + H.S(this.message) + " (" + H.S(target) + "[" + H.S(t1) + "]): " + explanation;
    },
    $isError: true,
    static: {IndexError$: function(invalidValue, indexable, $name, message, $length) {
        var t1 = J.get$length$asx(indexable);
        return new P.IndexError(indexable, t1, true, invalidValue, $name, "Index out of range");
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  Expando: {
    "^": "Object;name",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0(0));
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(0), value);
    },
    _getKey$0: function(_) {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount"}
  },
  Function: {
    "^": "Object;",
    $isFunction: true
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isList: true,
    $asList: null
  },
  "+List": 0,
  Map: {
    "^": "Object;",
    $isMap: true,
    $asMap: null
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  StackTrace: {
    "^": "Object;"
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(_, obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(0, iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol: {
    "^": "Object;"
  }
}],
["dart.dom.html", "dart:html", , W, {
  "^": "",
  HtmlElement: {
    "^": "Element;",
    "%": "HTMLAppletElement|HTMLBRElement|HTMLBaseElement|HTMLButtonElement|HTMLContentElement|HTMLDListElement|HTMLDataListElement|HTMLDetailsElement|HTMLDialogElement|HTMLDirectoryElement|HTMLDivElement|HTMLFieldSetElement|HTMLFontElement|HTMLFrameElement|HTMLFrameSetElement|HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLKeygenElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLLinkElement|HTMLMapElement|HTMLMarqueeElement|HTMLMenuElement|HTMLMenuItemElement|HTMLMetaElement|HTMLMeterElement|HTMLModElement|HTMLOListElement|HTMLOptGroupElement|HTMLOptionElement|HTMLOutputElement|HTMLParagraphElement|HTMLParamElement|HTMLPictureElement|HTMLPreElement|HTMLProgressElement|HTMLQuoteElement|HTMLShadowElement|HTMLSpanElement|HTMLStyleElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement|HTMLTableRowElement|HTMLTableSectionElement|HTMLTemplateElement|HTMLTextAreaElement|HTMLTitleElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
  },
  _EntryArray: {
    "^": "Interceptor;",
    $isList: true,
    $asList: function() {
      return [W.Entry];
    },
    "%": "EntryArray"
  },
  AnchorElement: {
    "^": "HtmlElement;",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAnchorElement"
  },
  AreaElement: {
    "^": "HtmlElement;",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAreaElement"
  },
  AudioTrack: {
    "^": "Interceptor;enabled=",
    "%": "AudioTrack"
  },
  AudioTrackList: {
    "^": "EventTarget;length=",
    "%": "AudioTrackList"
  },
  Blob: {
    "^": "Interceptor;",
    "%": ";Blob"
  },
  BodyElement: {
    "^": "HtmlElement;",
    get$onLoad: function(receiver) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "load", false), [null]);
    },
    "%": "HTMLBodyElement"
  },
  CanvasElement: {
    "^": "HtmlElement;height%,width%",
    getContext$2: function(receiver, contextId, attrs) {
      return receiver.getContext(contextId);
    },
    getContext$1: function($receiver, contextId) {
      return this.getContext$2($receiver, contextId, null);
    },
    "%": "HTMLCanvasElement"
  },
  CanvasRenderingContext2D: {
    "^": "Interceptor;fillStyle}",
    "%": "CanvasRenderingContext2D"
  },
  CharacterData: {
    "^": "Node0;length=",
    "%": "CDATASection|CharacterData|Comment|ProcessingInstruction|Text"
  },
  CssRule: {
    "^": "Interceptor;",
    "%": "CSSCharsetRule|CSSFontFaceRule|CSSImportRule|CSSKeyframeRule|CSSKeyframesRule|CSSMediaRule|CSSPageRule|CSSRule|CSSStyleRule|CSSSupportsRule|CSSUnknownRule|CSSViewportRule|MozCSSKeyframeRule|MozCSSKeyframesRule|WebKitCSSFilterRule|WebKitCSSKeyframeRule|WebKitCSSKeyframesRule"
  },
  CssStyleDeclaration: {
    "^": "Interceptor_CssStyleDeclarationBase;length=",
    "%": "CSS2Properties|CSSStyleDeclaration|MSStyleCSSProperties"
  },
  DataTransferItem: {
    "^": "Interceptor;",
    "%": "DataTransferItem"
  },
  DataTransferItemList: {
    "^": "Interceptor;length=",
    $index: function(receiver, index) {
      return receiver[index];
    },
    "%": "DataTransferItemList"
  },
  DeviceAcceleration: {
    "^": "Interceptor;x=,y=",
    "%": "DeviceAcceleration"
  },
  Document: {
    "^": "Node0;",
    $isDocument: true,
    "%": "Document|HTMLDocument|XMLDocument"
  },
  DomException: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "DOMException"
  },
  DomPoint: {
    "^": "DomPointReadOnly;",
    get$x: function(receiver) {
      return receiver.x;
    },
    get$y: function(receiver) {
      return receiver.y;
    },
    "%": "DOMPoint"
  },
  DomPointReadOnly: {
    "^": "Interceptor;x=,y=",
    "%": ";DOMPointReadOnly"
  },
  DomRectReadOnly: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=,x=,y=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = this.get$width(receiver);
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = this.get$height(receiver);
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(this.get$width(receiver));
      t4 = J.get$hashCode$(this.get$height(receiver));
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": ";DOMRectReadOnly"
  },
  DomStringList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [P.String];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "DOMStringList"
  },
  DomTokenList: {
    "^": "Interceptor;length=",
    "%": "DOMSettableTokenList|DOMTokenList"
  },
  Element: {
    "^": "Node0;",
    toString$0: function(receiver) {
      return receiver.localName;
    },
    animate$2: function(receiver, effect, timing) {
      return receiver.animate(effect, timing);
    },
    animate$1: function($receiver, effect) {
      return $receiver.animate(effect);
    },
    get$onDragStart: function(receiver) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "dragstart", false), [null]);
    },
    get$onLoad: function(receiver) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "load", false), [null]);
    },
    "%": ";Element"
  },
  EmbedElement: {
    "^": "HtmlElement;height%,src},width%",
    "%": "HTMLEmbedElement"
  },
  Entry: {
    "^": "Interceptor;",
    "%": "DirectoryEntry|Entry|FileEntry"
  },
  ErrorEvent: {
    "^": "Event;error=",
    "%": "ErrorEvent"
  },
  Event: {
    "^": "Interceptor;",
    preventDefault$0: function(receiver) {
      return receiver.preventDefault();
    },
    "%": "AnimationPlayerEvent|ApplicationCacheErrorEvent|AudioProcessingEvent|AutocompleteErrorEvent|BeforeUnloadEvent|CloseEvent|CustomEvent|DeviceLightEvent|DeviceMotionEvent|DeviceOrientationEvent|FetchEvent|FontFaceSetLoadEvent|GamepadEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|InstallPhaseEvent|MIDIConnectionEvent|MIDIMessageEvent|MediaKeyEvent|MediaKeyMessageEvent|MediaKeyNeededEvent|MediaStreamEvent|MediaStreamTrackEvent|MessageEvent|MutationEvent|OfflineAudioCompletionEvent|OverflowEvent|PageTransitionEvent|PopStateEvent|PushEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|RelatedEvent|SecurityPolicyViolationEvent|SpeechRecognitionEvent|SpeechSynthesisEvent|StorageEvent|TrackEvent|TransitionEvent|WebGLContextEvent|WebKitAnimationEvent|WebKitTransitionEvent;ClipboardEvent|Event|InputEvent"
  },
  EventTarget: {
    "^": "Interceptor;",
    addEventListener$3: function(receiver, type, listener, useCapture) {
      if (listener != null)
        this._addEventListener$3(receiver, type, listener, useCapture);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      if (listener != null)
        this._removeEventListener$3(receiver, type, listener, useCapture);
    },
    _addEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    _removeEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    "%": "AnalyserNode|AnimationPlayer|ApplicationCache|AudioBufferSourceNode|AudioChannelMerger|AudioChannelSplitter|AudioDestinationNode|AudioGainNode|AudioNode|AudioPannerNode|AudioSourceNode|BatteryManager|BiquadFilterNode|ChannelMergerNode|ChannelSplitterNode|ConvolverNode|DOMApplicationCache|DedicatedWorkerGlobalScope|DelayNode|DynamicsCompressorNode|EventSource|GainNode|IDBDatabase|InputMethodContext|JavaScriptAudioNode|MIDIAccess|MediaController|MediaElementAudioSourceNode|MediaSource|MediaStream|MediaStreamAudioDestinationNode|MediaStreamAudioSourceNode|MessagePort|NetworkInformation|Notification|OfflineResourceList|Oscillator|OscillatorNode|PannerNode|Performance|RTCDTMFSender|RTCPeerConnection|RealtimeAnalyserNode|ScreenOrientation|ScriptProcessorNode|ServiceWorker|ServiceWorkerGlobalScope|ServiceWorkerRegistration|SharedWorker|SharedWorkerGlobalScope|SpeechRecognition|SpeechSynthesis|SpeechSynthesisUtterance|WaveShaperNode|Worker|WorkerGlobalScope|mozRTCPeerConnection;EventTarget;EventTarget_ListMixin|EventTarget_ListMixin_ImmutableListMixin|EventTarget_ListMixin0|EventTarget_ListMixin_ImmutableListMixin0"
  },
  File: {
    "^": "Blob;",
    "%": "File"
  },
  FileList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.File];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "FileList"
  },
  FileReader: {
    "^": "EventTarget;error=",
    "%": "FileReader"
  },
  FileWriter: {
    "^": "EventTarget;error=,length=",
    write$1: function(receiver, data) {
      return receiver.write(data);
    },
    "%": "FileWriter"
  },
  FontFace: {
    "^": "Interceptor;loaded=",
    "%": "FontFace"
  },
  FontFaceSet: {
    "^": "EventTarget;",
    forEach$2: function(receiver, callback, thisArg) {
      return receiver.forEach(H.convertDartClosureToJS(callback, 3), thisArg);
    },
    forEach$1: function($receiver, callback) {
      callback = H.convertDartClosureToJS(callback, 3);
      return $receiver.forEach(callback);
    },
    "%": "FontFaceSet"
  },
  FormElement: {
    "^": "HtmlElement;length=",
    "%": "HTMLFormElement"
  },
  Gamepad: {
    "^": "Interceptor;",
    "%": "Gamepad"
  },
  Headers: {
    "^": "Interceptor;",
    forEach$2: function(receiver, callback, thisArg) {
      return receiver.forEach(H.convertDartClosureToJS(callback, 3), thisArg);
    },
    forEach$1: function($receiver, callback) {
      callback = H.convertDartClosureToJS(callback, 3);
      return $receiver.forEach(callback);
    },
    "%": "Headers"
  },
  History: {
    "^": "Interceptor;length=",
    "%": "History"
  },
  HtmlCollection: {
    "^": "Interceptor_ListMixin_ImmutableListMixin1;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
  },
  HttpRequest: {
    "^": "HttpRequestEventTarget;",
    open$5$async$password$user: function(receiver, method, url, async, password, user) {
      return receiver.open(method, url, async, user, password);
    },
    open$2: function($receiver, method, url) {
      return $receiver.open(method, url);
    },
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    "%": "XMLHttpRequest"
  },
  HttpRequestEventTarget: {
    "^": "EventTarget;",
    "%": "XMLHttpRequestUpload;XMLHttpRequestEventTarget"
  },
  IFrameElement: {
    "^": "HtmlElement;height%,src},width%",
    "%": "HTMLIFrameElement"
  },
  ImageElement: {
    "^": "HtmlElement;height%,src},width%",
    "%": "HTMLImageElement"
  },
  InputElement: {
    "^": "HtmlElement;height%,src},width%",
    "%": "HTMLInputElement"
  },
  KeyboardEvent: {
    "^": "UIEvent;",
    get$keyCode: function(receiver) {
      return receiver.keyCode;
    },
    "%": "KeyboardEvent"
  },
  Location: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "Location"
  },
  MediaElement: {
    "^": "HtmlElement;error=,src}",
    "%": "HTMLAudioElement;HTMLMediaElement"
  },
  MediaKeySession: {
    "^": "EventTarget;error=",
    "%": "MediaKeySession"
  },
  MediaList: {
    "^": "Interceptor;length=",
    "%": "MediaList"
  },
  MediaStreamTrack: {
    "^": "EventTarget;enabled=",
    "%": "MediaStreamTrack"
  },
  MidiOutput: {
    "^": "MidiPort;",
    send$2: function(receiver, data, timestamp) {
      return receiver.send(data, timestamp);
    },
    send$1: function($receiver, data) {
      return $receiver.send(data);
    },
    "%": "MIDIOutput"
  },
  MidiPort: {
    "^": "EventTarget;",
    "%": "MIDIInput;MIDIPort"
  },
  MimeType: {
    "^": "Interceptor;",
    "%": "MimeType"
  },
  MimeTypeArray: {
    "^": "Interceptor_ListMixin_ImmutableListMixin2;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.MimeType];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "MimeTypeArray"
  },
  MouseEvent: {
    "^": "UIEvent;button=",
    get$client: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point(receiver.clientX, receiver.clientY), [null]);
    },
    get$movement: function(receiver) {
      return H.setRuntimeTypeInfo(new P.Point(receiver.webkitMovementX, receiver.webkitMovementY), [null]);
    },
    "%": "DragEvent|MSPointerEvent|MouseEvent|MouseScrollEvent|MouseWheelEvent|PointerEvent|WheelEvent"
  },
  Node0: {
    "^": "EventTarget;",
    toString$0: function(receiver) {
      var t1 = receiver.nodeValue;
      return t1 == null ? J.Interceptor.prototype.toString$0.call(this, receiver) : t1;
    },
    "%": "Attr|DocumentFragment|DocumentType|Notation|ShadowRoot;Node"
  },
  NodeList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin3;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "NodeList|RadioNodeList"
  },
  ObjectElement: {
    "^": "HtmlElement;height%,width%",
    "%": "HTMLObjectElement"
  },
  Plugin: {
    "^": "Interceptor;length=",
    "%": "Plugin"
  },
  PluginArray: {
    "^": "Interceptor_ListMixin_ImmutableListMixin4;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Plugin];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "PluginArray"
  },
  ProgressEvent: {
    "^": "Event;loaded=",
    "%": "ProgressEvent|ResourceProgressEvent|XMLHttpRequestProgressEvent"
  },
  RtcDataChannel: {
    "^": "EventTarget;",
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    "%": "DataChannel|RTCDataChannel"
  },
  RtcStatsReport: {
    "^": "Interceptor;",
    "%": "RTCStatsReport"
  },
  ScriptElement: {
    "^": "HtmlElement;src}",
    "%": "HTMLScriptElement"
  },
  SelectElement: {
    "^": "HtmlElement;length=",
    "%": "HTMLSelectElement"
  },
  SourceBuffer: {
    "^": "EventTarget;",
    "%": "SourceBuffer"
  },
  SourceBufferList: {
    "^": "EventTarget_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.SourceBuffer];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "SourceBufferList"
  },
  SourceElement: {
    "^": "HtmlElement;src}",
    "%": "HTMLSourceElement"
  },
  SpeechGrammar: {
    "^": "Interceptor;",
    "%": "SpeechGrammar"
  },
  SpeechGrammarList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin5;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.SpeechGrammar];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "SpeechGrammarList"
  },
  SpeechRecognitionError: {
    "^": "Event;error=",
    "%": "SpeechRecognitionError"
  },
  SpeechRecognitionResult: {
    "^": "Interceptor;length=",
    "%": "SpeechRecognitionResult"
  },
  Storage: {
    "^": "Interceptor;",
    $index: function(receiver, key) {
      return receiver.getItem(key);
    },
    $indexSet: function(receiver, key, value) {
      receiver.setItem(key, value);
    },
    forEach$1: function(receiver, f) {
      var i, key;
      for (i = 0; true; ++i) {
        key = receiver.key(i);
        if (key == null)
          return;
        f.call$2(key, receiver.getItem(key));
      }
    },
    get$keys: function(receiver) {
      var keys = [];
      this.forEach$1(receiver, new W.Storage_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = [];
      this.forEach$1(receiver, new W.Storage_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isMap: true,
    $asMap: function() {
      return [P.String, P.String];
    },
    "%": "Storage"
  },
  StyleSheet: {
    "^": "Interceptor;",
    "%": "CSSStyleSheet|StyleSheet"
  },
  TextTrack: {
    "^": "EventTarget;",
    "%": "TextTrack"
  },
  TextTrackCue: {
    "^": "EventTarget;",
    "%": "TextTrackCue|VTTCue"
  },
  TextTrackCueList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin6;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: function() {
      return [W.TextTrackCue];
    },
    "%": "TextTrackCueList"
  },
  TextTrackList: {
    "^": "EventTarget_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.TextTrack];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "TextTrackList"
  },
  TimeRanges: {
    "^": "Interceptor;length=",
    "%": "TimeRanges"
  },
  Touch: {
    "^": "Interceptor;",
    "%": "Touch"
  },
  TouchList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin7;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Touch];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "TouchList"
  },
  TrackElement: {
    "^": "HtmlElement;src}",
    "%": "HTMLTrackElement"
  },
  UIEvent: {
    "^": "Event;which=",
    "%": "CompositionEvent|FocusEvent|SVGZoomEvent|TextEvent|TouchEvent;UIEvent"
  },
  Url: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "URL"
  },
  VideoElement: {
    "^": "MediaElement;height%,width%",
    "%": "HTMLVideoElement"
  },
  VideoTrackList: {
    "^": "EventTarget;length=",
    "%": "VideoTrackList"
  },
  VttRegionList: {
    "^": "Interceptor;length=",
    "%": "VTTRegionList"
  },
  WebSocket: {
    "^": "EventTarget;",
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    "%": "WebSocket"
  },
  Window: {
    "^": "EventTarget;",
    _requestAnimationFrame$1: function(receiver, callback) {
      return receiver.requestAnimationFrame(H.convertDartClosureToJS(callback, 1));
    },
    _ensureRequestAnimationFrame$0: function(receiver) {
      if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
        return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
          return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(receiver);
    },
    "%": "DOMWindow|Window"
  },
  _CSSValue: {
    "^": "Interceptor;",
    "%": "CSSPrimitiveValue;CSSValue;_CSSValue_ListMixin|_CSSValue_ListMixin_ImmutableListMixin"
  },
  _ClientRect: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.width;
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.height;
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(receiver.width);
      t4 = J.get$hashCode$(receiver.height);
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": "ClientRect"
  },
  _ClientRectList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin8;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: function() {
      return [P.Rectangle];
    },
    "%": "ClientRectList|DOMRectList"
  },
  _CssRuleList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin9;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.CssRule];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "CSSRuleList"
  },
  _CssValueList: {
    "^": "_CSSValue_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W._CSSValue];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "CSSValueList|WebKitCSSFilterValue|WebKitCSSTransformValue"
  },
  _DomPoint: {
    "^": "Interceptor;x=,y=",
    "%": "WebKitPoint"
  },
  _DomRect: {
    "^": "DomRectReadOnly;",
    get$height: function(receiver) {
      return receiver.height;
    },
    get$width: function(receiver) {
      return receiver.width;
    },
    get$x: function(receiver) {
      return receiver.x;
    },
    get$y: function(receiver) {
      return receiver.y;
    },
    "%": "DOMRect"
  },
  _GamepadList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin10;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Gamepad];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "GamepadList"
  },
  _NamedNodeMap: {
    "^": "Interceptor_ListMixin_ImmutableListMixin11;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node0];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "MozNamedAttrMap|NamedNodeMap"
  },
  _SpeechRecognitionResultList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin12;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.SpeechRecognitionResult];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "SpeechRecognitionResultList"
  },
  _StyleSheetList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin13;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.StyleSheet];
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true,
    "%": "StyleSheetList"
  },
  _JenkinsSmiHash_combine: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  _convertNativeToDart_XHR_Response: function(o) {
    if (!!J.getInterceptor(o).$isDocument)
      return o;
    return P.convertNativeToDart_AcceptStructuredClone(o, true);
  },
  _wrapZone: function(callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone)
      return callback;
    return t1.bindUnaryCallback$2$runGuarded(callback, true);
  },
  Interceptor_CssStyleDeclarationBase: {
    "^": "Interceptor+CssStyleDeclarationBase;"
  },
  CssStyleDeclarationBase: {
    "^": "Object;"
  },
  Interceptor_ListMixin: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.String];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin: {
    "^": "Interceptor_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.String];
    }
  },
  Interceptor_ListMixin0: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.File];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin0: {
    "^": "Interceptor_ListMixin0+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.File];
    }
  },
  Interceptor_ListMixin1: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin1: {
    "^": "Interceptor_ListMixin1+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin2: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.MimeType];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin2: {
    "^": "Interceptor_ListMixin2+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.MimeType];
    }
  },
  Interceptor_ListMixin3: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin3: {
    "^": "Interceptor_ListMixin3+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin4: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Plugin];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin4: {
    "^": "Interceptor_ListMixin4+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Plugin];
    }
  },
  EventTarget_ListMixin: {
    "^": "EventTarget+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.SourceBuffer];
    }
  },
  EventTarget_ListMixin_ImmutableListMixin: {
    "^": "EventTarget_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.SourceBuffer];
    }
  },
  Interceptor_ListMixin5: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.SpeechGrammar];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin5: {
    "^": "Interceptor_ListMixin5+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.SpeechGrammar];
    }
  },
  Storage_keys_closure: {
    "^": "Closure:7;keys_0",
    call$2: function(k, v) {
      return this.keys_0.push(k);
    }
  },
  Storage_values_closure: {
    "^": "Closure:7;values_0",
    call$2: function(k, v) {
      return this.values_0.push(v);
    }
  },
  Interceptor_ListMixin6: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.TextTrackCue];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin6: {
    "^": "Interceptor_ListMixin6+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.TextTrackCue];
    }
  },
  EventTarget_ListMixin0: {
    "^": "EventTarget+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.TextTrack];
    }
  },
  EventTarget_ListMixin_ImmutableListMixin0: {
    "^": "EventTarget_ListMixin0+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.TextTrack];
    }
  },
  Interceptor_ListMixin7: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Touch];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin7: {
    "^": "Interceptor_ListMixin7+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Touch];
    }
  },
  Interceptor_ListMixin8: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Rectangle];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin8: {
    "^": "Interceptor_ListMixin8+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Rectangle];
    }
  },
  Interceptor_ListMixin9: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.CssRule];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin9: {
    "^": "Interceptor_ListMixin9+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.CssRule];
    }
  },
  _CSSValue_ListMixin: {
    "^": "_CSSValue+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W._CSSValue];
    }
  },
  _CSSValue_ListMixin_ImmutableListMixin: {
    "^": "_CSSValue_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W._CSSValue];
    }
  },
  Interceptor_ListMixin10: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Gamepad];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin10: {
    "^": "Interceptor_ListMixin10+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Gamepad];
    }
  },
  Interceptor_ListMixin11: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin11: {
    "^": "Interceptor_ListMixin11+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node0];
    }
  },
  Interceptor_ListMixin12: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.SpeechRecognitionResult];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin12: {
    "^": "Interceptor_ListMixin12+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.SpeechRecognitionResult];
    }
  },
  Interceptor_ListMixin13: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.StyleSheet];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin13: {
    "^": "Interceptor_ListMixin13+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.StyleSheet];
    }
  },
  _EventStream: {
    "^": "Stream;_html$_target,_eventType,_useCapture",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = new W._EventStreamSubscription(0, this._html$_target, this._eventType, W._wrapZone(onData), this._useCapture);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    }
  },
  _ElementEventStreamImpl: {
    "^": "_EventStream;_html$_target,_eventType,_useCapture"
  },
  _EventStreamSubscription: {
    "^": "StreamSubscription;_pauseCount,_html$_target,_eventType,_onData,_useCapture",
    cancel$0: function(_) {
      if (this._html$_target == null)
        return;
      this._unlisten$0();
      this._html$_target = null;
      this._onData = null;
      return;
    },
    _tryResume$0: function() {
      var t1 = this._onData;
      if (t1 != null && this._pauseCount <= 0)
        J.addEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    },
    _unlisten$0: function() {
      var t1 = this._onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    }
  },
  ImmutableListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return new W.FixedSizeListIterator(receiver, this.get$length(receiver), -1, null);
    },
    $isList: true,
    $asList: null
  },
  FixedSizeListIterator: {
    "^": "Object;_array,_length,_position,_current",
    moveNext$0: function() {
      var nextPosition, t1;
      nextPosition = this._position + 1;
      t1 = this._length;
      if (nextPosition < t1) {
        this._current = J.$index$asx(this._array, nextPosition);
        this._position = nextPosition;
        return true;
      }
      this._current = null;
      this._position = t1;
      return false;
    },
    get$current: function() {
      return this._current;
    }
  }
}],
["dart.dom.indexed_db", "dart:indexed_db", , P, {
  "^": "",
  Request: {
    "^": "EventTarget;error=",
    "%": "IDBOpenDBRequest|IDBRequest|IDBVersionChangeRequest"
  },
  Transaction: {
    "^": "EventTarget;error=",
    "%": "IDBTransaction"
  }
}],
["dart.dom.svg", "dart:svg", , P, {
  "^": "",
  FEBlendElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEBlendElement"
  },
  FEColorMatrixElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEColorMatrixElement"
  },
  FEComponentTransferElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEComponentTransferElement"
  },
  FECompositeElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFECompositeElement"
  },
  FEConvolveMatrixElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEConvolveMatrixElement"
  },
  FEDiffuseLightingElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEDiffuseLightingElement"
  },
  FEDisplacementMapElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    scale$1: function($receiver, arg0) {
      return $receiver.scale.call$1(arg0);
    },
    "%": "SVGFEDisplacementMapElement"
  },
  FEFloodElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEFloodElement"
  },
  FEGaussianBlurElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEGaussianBlurElement"
  },
  FEImageElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEImageElement"
  },
  FEMergeElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEMergeElement"
  },
  FEMorphologyElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEMorphologyElement"
  },
  FEOffsetElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFEOffsetElement"
  },
  FEPointLightElement: {
    "^": "SvgElement;x=,y=",
    "%": "SVGFEPointLightElement"
  },
  FESpecularLightingElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFESpecularLightingElement"
  },
  FESpotLightElement: {
    "^": "SvgElement;x=,y=",
    "%": "SVGFESpotLightElement"
  },
  FETileElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFETileElement"
  },
  FETurbulenceElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFETurbulenceElement"
  },
  FilterElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGFilterElement"
  },
  ForeignObjectElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGForeignObjectElement"
  },
  GeometryElement: {
    "^": "GraphicsElement;",
    "%": "SVGCircleElement|SVGEllipseElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement;SVGGeometryElement"
  },
  GraphicsElement: {
    "^": "SvgElement;",
    "%": "SVGAElement|SVGClipPathElement|SVGDefsElement|SVGGElement|SVGSwitchElement;SVGGraphicsElement"
  },
  ImageElement0: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGImageElement"
  },
  Length: {
    "^": "Interceptor;",
    "%": "SVGLength"
  },
  LengthList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin14;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isList: true,
    $asList: function() {
      return [P.Length];
    },
    "%": "SVGLengthList"
  },
  MaskElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGMaskElement"
  },
  Matrix: {
    "^": "Interceptor;",
    scale$1: function(receiver, scaleFactor) {
      return receiver.scale(scaleFactor);
    },
    "%": "SVGMatrix"
  },
  Number: {
    "^": "Interceptor;",
    "%": "SVGNumber"
  },
  NumberList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin15;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isList: true,
    $asList: function() {
      return [P.Number];
    },
    "%": "SVGNumberList"
  },
  PathSeg: {
    "^": "Interceptor;",
    "%": "SVGPathSegClosePath;SVGPathSeg"
  },
  PathSegArcAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegArcAbs"
  },
  PathSegArcRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegArcRel"
  },
  PathSegCurvetoCubicAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoCubicAbs"
  },
  PathSegCurvetoCubicRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoCubicRel"
  },
  PathSegCurvetoCubicSmoothAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoCubicSmoothAbs"
  },
  PathSegCurvetoCubicSmoothRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoCubicSmoothRel"
  },
  PathSegCurvetoQuadraticAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoQuadraticAbs"
  },
  PathSegCurvetoQuadraticRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoQuadraticRel"
  },
  PathSegCurvetoQuadraticSmoothAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoQuadraticSmoothAbs"
  },
  PathSegCurvetoQuadraticSmoothRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegCurvetoQuadraticSmoothRel"
  },
  PathSegLinetoAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegLinetoAbs"
  },
  PathSegLinetoHorizontalAbs: {
    "^": "PathSeg;x=",
    "%": "SVGPathSegLinetoHorizontalAbs"
  },
  PathSegLinetoHorizontalRel: {
    "^": "PathSeg;x=",
    "%": "SVGPathSegLinetoHorizontalRel"
  },
  PathSegLinetoRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegLinetoRel"
  },
  PathSegLinetoVerticalAbs: {
    "^": "PathSeg;y=",
    "%": "SVGPathSegLinetoVerticalAbs"
  },
  PathSegLinetoVerticalRel: {
    "^": "PathSeg;y=",
    "%": "SVGPathSegLinetoVerticalRel"
  },
  PathSegList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin16;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isList: true,
    $asList: function() {
      return [P.PathSeg];
    },
    "%": "SVGPathSegList"
  },
  PathSegMovetoAbs: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegMovetoAbs"
  },
  PathSegMovetoRel: {
    "^": "PathSeg;x=,y=",
    "%": "SVGPathSegMovetoRel"
  },
  PatternElement: {
    "^": "SvgElement;height=,width=,x=,y=",
    "%": "SVGPatternElement"
  },
  Point0: {
    "^": "Interceptor;x=,y=",
    "%": "SVGPoint"
  },
  PointList: {
    "^": "Interceptor;length=",
    "%": "SVGPointList"
  },
  Rect: {
    "^": "Interceptor;x=,y=",
    "%": "SVGRect"
  },
  RectElement: {
    "^": "GeometryElement;height=,width=,x=,y=",
    "%": "SVGRectElement"
  },
  StringList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin17;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isList: true,
    $asList: function() {
      return [P.String];
    },
    "%": "SVGStringList"
  },
  SvgElement: {
    "^": "Element;",
    get$onDragStart: function(receiver) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "dragstart", false), [null]);
    },
    get$onLoad: function(receiver) {
      return H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "load", false), [null]);
    },
    "%": "SVGAltGlyphDefElement|SVGAltGlyphItemElement|SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGComponentTransferFunctionElement|SVGCursorElement|SVGDescElement|SVGDiscardElement|SVGFEDistantLightElement|SVGFEDropShadowElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEMergeNodeElement|SVGFontElement|SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement|SVGGlyphElement|SVGGlyphRefElement|SVGGradientElement|SVGHKernElement|SVGLinearGradientElement|SVGMPathElement|SVGMarkerElement|SVGMetadataElement|SVGMissingGlyphElement|SVGRadialGradientElement|SVGScriptElement|SVGSetElement|SVGStopElement|SVGStyleElement|SVGSymbolElement|SVGTitleElement|SVGVKernElement|SVGViewElement;SVGElement"
  },
  SvgSvgElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGSVGElement"
  },
  TextContentElement: {
    "^": "GraphicsElement;",
    "%": "SVGTextPathElement;SVGTextContentElement"
  },
  TextPositioningElement: {
    "^": "TextContentElement;x=,y=",
    "%": "SVGAltGlyphElement|SVGTSpanElement|SVGTextElement|SVGTextPositioningElement"
  },
  Transform: {
    "^": "Interceptor;",
    "%": "SVGTransform"
  },
  TransformList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin18;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isList: true,
    $asList: function() {
      return [P.Transform];
    },
    "%": "SVGTransformList"
  },
  UseElement: {
    "^": "GraphicsElement;height=,width=,x=,y=",
    "%": "SVGUseElement"
  },
  Interceptor_ListMixin14: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Length];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin14: {
    "^": "Interceptor_ListMixin14+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Length];
    }
  },
  Interceptor_ListMixin15: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Number];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin15: {
    "^": "Interceptor_ListMixin15+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Number];
    }
  },
  Interceptor_ListMixin16: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.PathSeg];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin16: {
    "^": "Interceptor_ListMixin16+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.PathSeg];
    }
  },
  Interceptor_ListMixin17: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.String];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin17: {
    "^": "Interceptor_ListMixin17+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.String];
    }
  },
  Interceptor_ListMixin18: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Transform];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin18: {
    "^": "Interceptor_ListMixin18+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Transform];
    }
  }
}],
["dart.dom.web_audio", "dart:web_audio", , P, {
  "^": "",
  AudioBuffer: {
    "^": "Interceptor;length=",
    "%": "AudioBuffer"
  },
  AudioContext: {
    "^": "EventTarget;",
    _decodeAudioData$3: function(receiver, audioData, successCallback, errorCallback) {
      return receiver.decodeAudioData(audioData, H.convertDartClosureToJS(successCallback, 1), H.convertDartClosureToJS(errorCallback, 1));
    },
    createGain$0: function(receiver) {
      if (receiver.createGain !== undefined)
        return receiver.createGain();
      else
        return receiver.createGainNode();
    },
    decodeAudioData$1: function(receiver, audioData) {
      var t1, completer;
      t1 = P.AudioBuffer;
      completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [t1])), [t1]);
      this._decodeAudioData$3(receiver, audioData, new P.AudioContext_decodeAudioData_closure(completer), new P.AudioContext_decodeAudioData_closure0(completer));
      return completer.future;
    },
    "%": "AudioContext|OfflineAudioContext|webkitAudioContext"
  },
  AudioContext_decodeAudioData_closure: {
    "^": "Closure:8;completer_0",
    call$1: function(value) {
      this.completer_0.complete$1(0, value);
    }
  },
  AudioContext_decodeAudioData_closure0: {
    "^": "Closure:8;completer_1",
    call$1: function(error) {
      var t1 = this.completer_1;
      if (error == null)
        t1.completeError$1("");
      else
        t1.completeError$1(error);
    }
  }
}],
["dart.dom.web_gl", "dart:web_gl", , P, {
  "^": "",
  RenderingContext: {
    "^": "Interceptor;",
    activeTexture$1: function(receiver, texture) {
      return receiver.activeTexture(texture);
    },
    attachShader$2: function(receiver, program, shader) {
      return receiver.attachShader(program, shader);
    },
    bindBuffer$2: function(receiver, target, buffer) {
      return receiver.bindBuffer(target, buffer);
    },
    bindFramebuffer$2: function(receiver, target, framebuffer) {
      return receiver.bindFramebuffer(target, framebuffer);
    },
    bindTexture$2: function(receiver, target, texture) {
      return receiver.bindTexture(target, texture);
    },
    blendFunc$2: function(receiver, sfactor, dfactor) {
      return receiver.blendFunc(sfactor, dfactor);
    },
    bufferDataTyped$3: function(receiver, target, data, usage) {
      return receiver.bufferData(target, data, usage);
    },
    checkFramebufferStatus$1: function(receiver, target) {
      return receiver.checkFramebufferStatus(target);
    },
    clear$1: function(receiver, mask) {
      return receiver.clear(mask);
    },
    clearColor$4: function(receiver, red, green, blue, alpha) {
      return receiver.clearColor(red, green, blue, alpha);
    },
    compileShader$1: function(receiver, shader) {
      return receiver.compileShader(shader);
    },
    createBuffer$0: function(receiver) {
      return receiver.createBuffer();
    },
    createFramebuffer$0: function(receiver) {
      return receiver.createFramebuffer();
    },
    createProgram$0: function(receiver) {
      return receiver.createProgram();
    },
    createShader$1: function(receiver, type) {
      return receiver.createShader(type);
    },
    createTexture$0: function(receiver) {
      return receiver.createTexture();
    },
    disable$1: function(receiver, cap) {
      return receiver.disable(cap);
    },
    disableVertexAttribArray$1: function(receiver, index) {
      return receiver.disableVertexAttribArray(index);
    },
    drawArrays$3: function(receiver, mode, first, count) {
      return receiver.drawArrays(mode, first, count);
    },
    drawElements$4: function(receiver, mode, count, type, offset) {
      return receiver.drawElements(mode, count, type, offset);
    },
    enable$1: function(receiver, cap) {
      return receiver.enable(cap);
    },
    enableVertexAttribArray$1: function(receiver, index) {
      return receiver.enableVertexAttribArray(index);
    },
    framebufferTexture2D$5: function(receiver, target, attachment, textarget, texture, level) {
      return receiver.framebufferTexture2D(target, attachment, textarget, texture, level);
    },
    getAttribLocation$2: function(receiver, program, $name) {
      return receiver.getAttribLocation(program, $name);
    },
    getExtension$1: function(receiver, $name) {
      return receiver.getExtension($name);
    },
    getProgramInfoLog$1: function(receiver, program) {
      return receiver.getProgramInfoLog(program);
    },
    getProgramParameter$2: function(receiver, program, pname) {
      return receiver.getProgramParameter(program, pname);
    },
    getShaderInfoLog$1: function(receiver, shader) {
      return receiver.getShaderInfoLog(shader);
    },
    getShaderParameter$2: function(receiver, shader, pname) {
      return receiver.getShaderParameter(shader, pname);
    },
    getUniformLocation$2: function(receiver, program, $name) {
      return receiver.getUniformLocation(program, $name);
    },
    linkProgram$1: function(receiver, program) {
      return receiver.linkProgram(program);
    },
    pixelStorei$2: function(receiver, pname, param) {
      return receiver.pixelStorei(pname, param);
    },
    shaderSource$2: function(receiver, shader, string) {
      return receiver.shaderSource(shader, string);
    },
    texImage2DCanvas$6: function(receiver, target, level, internalformat, format, type, canvas) {
      return receiver.texImage2D(target, level, internalformat, format, type, canvas);
    },
    texImage2DImage$6: function(receiver, target, level, internalformat, format, type, image) {
      return receiver.texImage2D(target, level, internalformat, format, type, image);
    },
    texParameteri$3: function(receiver, target, pname, param) {
      return receiver.texParameteri(target, pname, param);
    },
    uniform1f$2: function(receiver, $location, x) {
      return receiver.uniform1f($location, x);
    },
    uniform1i$2: function(receiver, $location, x) {
      return receiver.uniform1i($location, x);
    },
    uniform2f$3: function(receiver, $location, x, y) {
      return receiver.uniform2f($location, x, y);
    },
    uniformMatrix4fv$3: function(receiver, $location, transpose, array) {
      return receiver.uniformMatrix4fv($location, transpose, array);
    },
    useProgram$1: function(receiver, program) {
      return receiver.useProgram(program);
    },
    vertexAttribPointer$6: function(receiver, indx, size, type, normalized, stride, offset) {
      return receiver.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    },
    viewport$4: function(receiver, x, y, width, height) {
      return receiver.viewport(x, y, width, height);
    },
    texImage2DTyped$9: function(receiver, targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data) {
      return receiver.texImage2D(targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data);
    },
    "%": "WebGLRenderingContext"
  }
}],
["dart.dom.web_sql", "dart:web_sql", , P, {
  "^": "",
  SqlResultSetRowList: {
    "^": "Interceptor_ListMixin_ImmutableListMixin19;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return P.convertNativeToDart_Dictionary(receiver.item(index));
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isList: true,
    $asList: function() {
      return [P.Map];
    },
    "%": "SQLResultSetRowList"
  },
  Interceptor_ListMixin19: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Map];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin19: {
    "^": "Interceptor_ListMixin19+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [P.Map];
    }
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;",
    $isCapability: true
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  _JenkinsSmiHash_combine0: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish0: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  max: function(a, b) {
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (a === 0)
        return a + b;
      if (isNaN(b))
        return b;
      return a;
    }
    if (b === 0 && C.JSDouble_methods.get$isNegative(a))
      return b;
    return a;
  },
  Point: {
    "^": "Object;x>,y>",
    toString$0: function(_) {
      return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isPoint)
        return false;
      t1 = this.x;
      t2 = other.x;
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = this.y;
        t2 = other.y;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(this.x);
      t2 = J.get$hashCode$(this.y);
      return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t1), t2));
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      t1 = this.x;
      t2 = J.getInterceptor$x(other);
      t3 = t2.get$x(other);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.y;
      t2 = t2.get$y(other);
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new P.Point(t1 + t3, t4 + t2);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      t1 = this.x;
      t2 = J.getInterceptor$x(other);
      t3 = t2.get$x(other);
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = this.y;
      t2 = t2.get$y(other);
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new P.Point(t1 - t3, t4 - t2);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $mul: function(_, factor) {
      var t1, t2;
      t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof factor !== "number")
        return H.iae(factor);
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 = new P.Point(t1 * factor, t2 * factor);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return t2;
    },
    $isPoint: true
  },
  _RectangleBase: {
    "^": "Object;",
    get$right: function(_) {
      return this.get$left(this) + this.width;
    },
    get$bottom: function(_) {
      return this.get$top(this) + this.height;
    },
    toString$0: function(_) {
      return "Rectangle (" + this.get$left(this) + ", " + this.top + ") " + this.width + " x " + this.height;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      if (this.get$left(this) === t1.get$left(other)) {
        t2 = this.top;
        t1 = t2 === t1.get$top(other) && this.left + this.width === t1.get$right(other) && t2 + this.height === t1.get$bottom(other);
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this.top;
      return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, this.get$left(this) & 0x1FFFFFFF), t1 & 0x1FFFFFFF), this.left + this.width & 0x1FFFFFFF), t1 + this.height & 0x1FFFFFFF));
    }
  },
  Rectangle: {
    "^": "_RectangleBase;left>,top>,width>,height>",
    $isRectangle: true,
    $asRectangle: null
  }
}],
["dart.typed_data", "dart:typed_data", , P, {
  "^": "",
  ByteBuffer: {
    "^": "Object;",
    $isByteBuffer: true
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  NativeByteBuffer: {
    "^": "Interceptor;",
    asInt32List$2: function(receiver, offsetInBytes, $length) {
      H._checkViewArguments(receiver, offsetInBytes, $length);
      return new Int32Array(receiver, offsetInBytes, $length);
    },
    asByteData$2: function(receiver, offsetInBytes, $length) {
      H._checkViewArguments(receiver, offsetInBytes, $length);
      return new DataView(receiver, offsetInBytes, $length);
    },
    $isByteBuffer: true,
    "%": "ArrayBuffer"
  },
  NativeTypedData: {
    "^": "Interceptor;",
    _invalidIndex$2: function(receiver, index, $length) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, $length)) {
        if (!!this.$isList)
          if ($length === receiver.length)
            throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        throw H.wrapException(P.RangeError$range(index, 0, $length - 1, null, null));
      } else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + H.S(index)));
    },
    $isTypedData: true,
    "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
  },
  NativeByteData: {
    "^": "NativeTypedData;",
    $isTypedData: true,
    "%": "DataView"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    $isFloat32List: true,
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    "%": "Float32Array"
  },
  NativeFloat64List: {
    "^": "NativeTypedArrayOfDouble;",
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    "%": "Float64Array"
  },
  NativeInt16List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": "Int16Array"
  },
  NativeInt32List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": "Int32Array"
  },
  NativeInt8List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": "Int8Array"
  },
  NativeUint16List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isUint16List: true,
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": "Uint16Array"
  },
  NativeUint32List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isUint32List: true,
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": "Uint32Array"
  },
  NativeUint8ClampedList: {
    "^": "NativeTypedArrayOfInt;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": "CanvasPixelArray|Uint8ClampedArray"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isTypedData: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    "%": ";Uint8Array"
  },
  _checkLength: function($length) {
    return $length;
  },
  _checkViewArguments: function(buffer, offsetInBytes, $length) {
    if ($length != null && false)
      throw H.wrapException(P.ArgumentError$("Invalid view length " + H.S($length)));
  },
  _ensureNativeList: function(list) {
    var t1, result, i;
    if (!!J.getInterceptor(list).$isJSIndexable)
      return list;
    t1 = list.length;
    result = Array(t1);
    result.fixed$length = init;
    for (i = 0; i < t1; ++i)
      result[i] = list[i];
    return result;
  },
  NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
    H._checkViewArguments(buffer, offsetInBytes, $length);
    return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    }
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$double];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin0: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin0: {
    "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["html_common", "dart:html_common", , P, {
  "^": "",
  convertNativeToDart_Dictionary: function(object) {
    var dict, keys, t1, key;
    if (object == null)
      return;
    dict = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    keys = Object.getOwnPropertyNames(object);
    for (t1 = new H.ListIterator(keys, keys.length, 0, null); t1.moveNext$0();) {
      key = t1.__internal$_current;
      dict.$indexSet(0, key, object[key]);
    }
    return dict;
  },
  convertNativeToDart_AcceptStructuredClone: function(object, mustCopy) {
    var copies = [];
    return new P.convertNativeToDart_AcceptStructuredClone_walk(mustCopy, new P.convertNativeToDart_AcceptStructuredClone_findSlot([], copies), new P.convertNativeToDart_AcceptStructuredClone_readSlot(copies), new P.convertNativeToDart_AcceptStructuredClone_writeSlot(copies)).call$1(object);
  },
  convertNativeToDart_AcceptStructuredClone_findSlot: {
    "^": "Closure:3;values_0,copies_1",
    call$1: function(value) {
      var t1, $length, i, t2;
      t1 = this.values_0;
      $length = t1.length;
      for (i = 0; i < $length; ++i) {
        t2 = t1[i];
        if (t2 == null ? value == null : t2 === value)
          return i;
      }
      t1.push(value);
      this.copies_1.push(null);
      return $length;
    }
  },
  convertNativeToDart_AcceptStructuredClone_readSlot: {
    "^": "Closure:11;copies_2",
    call$1: function(i) {
      var t1 = this.copies_2;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return t1[i];
    }
  },
  convertNativeToDart_AcceptStructuredClone_writeSlot: {
    "^": "Closure:27;copies_3",
    call$2: function(i, x) {
      var t1 = this.copies_3;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t1[i] = x;
    }
  },
  convertNativeToDart_AcceptStructuredClone_walk: {
    "^": "Closure:8;mustCopy_4,findSlot_5,readSlot_6,writeSlot_7",
    call$1: function(e) {
      var slot, copy, t1, key, $length, t2, i;
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      if (e instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(e.getTime(), true);
      if (e instanceof RegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (Object.getPrototypeOf(e) === Object.prototype) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        copy = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        this.writeSlot_7.call$2(slot, copy);
        for (t1 = Object.keys(e), t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
          key = t1.__internal$_current;
          copy.$indexSet(0, key, this.call$1(e[key]));
        }
        return copy;
      }
      if (e instanceof Array) {
        slot = this.findSlot_5.call$1(e);
        copy = this.readSlot_6.call$1(slot);
        if (copy != null)
          return copy;
        t1 = J.getInterceptor$asx(e);
        $length = t1.get$length(e);
        copy = this.mustCopy_4 ? new Array($length) : e;
        this.writeSlot_7.call$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t2.$indexSet(copy, i, this.call$1(t1.$index(e, i)));
        return copy;
      }
      return e;
    }
  }
}],
["instagib", "instagib.dart", , X, {
  "^": "",
  main: [function() {
    var shaderObject, sp, t1, t2, t3, fpscam, utils, tw, e, ctx, texture;
    $.skipDefaultMouseMoveListener = true;
    shaderObject = new B.ShaderObject("Sobel", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "", "", "", "");
    shaderObject.vertexShader = "  precision mediump float;\n  attribute vec3 aVertexPosition;\n  attribute vec2 aTextureCoord;\n  \n  uniform mat4 uMVMatrix;\n  uniform mat4 uPMatrix;\n  \n  varying vec2 vTextureCoord;\n  \n  void main(void) {\n    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n  }\n  ";
    shaderObject.fragmentShader = "  precision mediump float;\n  \n  varying vec2 vTextureCoord;\n  uniform sampler2D colorSampler;\n  \n  uniform float cameraNear;\n  uniform float cameraFar;\n  uniform vec2 size;\n\n  float lum(vec4 c) {\n    return dot(c.xyz, vec3(0.3, 0.59, 0.11));\n  }\n\n  float sobel() {\n      vec2 imageIncrement = vec2(1.0/size.x,1.0/size.y);\n      float t00 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2(-1, -1)));\n      float t10 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2( 0, -1)));\n      float t20 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2( 1, -1)));\n      float t01 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2(-1,  0)));\n      float t21 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2( 1,  0)));\n      float t02 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2(-1,  1)));\n      float t12 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2( 0,  1)));\n      float t22 = lum(texture2D(colorSampler, vTextureCoord + imageIncrement * vec2( 1,  1)));\n      vec2 grad;\n      grad.x = t00 + 2.0 * t01 + t02 - t20 - 2.0 * t21 - t22;\n      grad.y = t00 + 2.0 * t10 + t20 - t02 - 2.0 * t12 - t22;\n      return length(grad);\n  } \n\n  void main(void) {\n      float len = sobel();\n      gl_FragColor = vec4(len, len, len, 1.0); // \n  }\n  ";
    shaderObject.vertexPositionAttribute = "aVertexPosition";
    shaderObject.textureCoordinatesAttribute = "aTextureCoord";
    shaderObject.modelViewMatrixUniform = "uMVMatrix";
    shaderObject.perpectiveMatrixUniform = "uPMatrix";
    shaderObject.textureSamplerUniform = "colorSampler";
    shaderObject.cameraNear = "cameraNear";
    shaderObject.cameraFar = "cameraFar";
    shaderObject.size = "size";
    $.chronosGL = B.ChronosGL$("#webgl-canvas", 2520, shaderObject, 0.1, false, false, false);
    shaderObject = new B.ShaderObject("Color", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "", "", "", "");
    shaderObject.vertexPositionAttribute = "aVertexPosition";
    shaderObject.colorsAttribute = "aColor";
    shaderObject.modelViewMatrixUniform = "uMVMatrix";
    shaderObject.perpectiveMatrixUniform = "uPMatrix";
    shaderObject.fragmentShaderBody = "gl_FragColor = vec4( vaColor, 1.0 );";
    shaderObject = B.generateShader(shaderObject);
    sp = $.chronosGL.createProgram$1(0, shaderObject);
    t1 = $.chronosGL._camera;
    $.camera = t1;
    t1.setPos$3(0, 0, 6);
    t1 = $.camera;
    t2 = Q.Vector$(1, 0, 6);
    t3 = Q.Vector$(0, 0, 1);
    t1.matrix.lookAt_alt$3(t1.getPos$0(), t2, t3);
    fpscam = X.QuakeCamera$($.camera);
    $.chronosGL.animatables.$indexSet(0, "fpscam", fpscam);
    t3 = $.chronosGL;
    utils = t3._utils;
    t3 = t3._textureCache;
    $.textureCache = t3;
    tw = B.TextureWrapper$(t3.gl, false);
    tw.loaded = true;
    t2 = t3.chronosGL._utils;
    t2.toString;
    e = document.createElement("canvas", null);
    J.set$width$x(e, 2);
    J.set$height$x(e, 2);
    ctx = J.getContext$1$x(e, "2d");
    J.set$fillStyle$x(ctx, "rgba(255,0,0,255)");
    ctx.fillRect(0, 0, e.width, e.height);
    texture = J.createTexture$0$x(t2.gl);
    J.bindTexture$2$x(t2.gl, 3553, texture);
    J.texImage2DCanvas$6$x(t2.gl, 3553, 0, 6408, 6408, 5121, e);
    J.texParameteri$3$x(t2.gl, 3553, 10240, 9729);
    J.texParameteri$3$x(t2.gl, 3553, 10241, 9729);
    tw.texture = texture;
    t3.textureCache.$indexSet(0, "red", tw);
    C.JSArray_methods.forEach$1(["nx", "px", "nz", "pz", "ny", "py"], new X.main_closure());
    $.get$snd().loadSound$2("data/jump1.wav", "jump");
    $.get$snd().loadSound$2("data/railgf1a.wav", "rail");
    $.textureCache.loadAllThenExecute$1(new X.main_closure0(sp, fpscam, utils));
  }, "call$0", "main$closure", 0, 0, 1],
  addLaser: function(spatial, moveLeft, moveUp) {
    var objects, laserBeam, found, t1, i, t2, laserMesh, t3, t4, t5, t6, t7, t8, t9;
    objects = $.chronosGL.programBasic.objects;
    t1 = objects.length;
    i = 0;
    while (true) {
      if (!(i < t1)) {
        laserBeam = null;
        found = false;
        break;
      }
      t2 = objects[i];
      if ("laser" === t2.type && !t2.enabled) {
        H.interceptedTypeCast(t2, "$isLaserBeam");
        laserBeam = t2;
        found = true;
        break;
      }
      ++i;
    }
    if (found) {
      laserBeam.enabled = true;
      laserBeam.matrix.identity$0();
    } else {
      laserMesh = B.Mesh$(B.createCylinder(0.1, 30, 20, $.textureCache.textureCache.$index(0, "red").get$texture()), false);
      laserMesh.matrix.rotate$2(0, 1.5707963267948966, laserMesh.getRight$0());
      t1 = Q.Vector$(0, 0, 0);
      t2 = Q.Vector$(0, 0, 0);
      t3 = Q.Vector$(0, 0, 0);
      t4 = Q.Vector$(0, 0, 0);
      t5 = Q.Vector$(0, 0, 0);
      t6 = H.setRuntimeTypeInfo([], [B.Node]);
      t7 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t7.identity$0();
      t8 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t8.identity$0();
      t9 = new Q.Matrix4(new Float32Array(H._checkLength(16)), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t9.identity$0();
      laserBeam = new X.LaserBeam(0, t1, t2, t3, t4, t5, "", "", true, false, t6, t7, t8, null, t9, Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0));
      t6.push(laserMesh);
      laserBeam.type = "laser";
      laserBeam.invert = true;
    }
    laserBeam.lifeTime = 10000;
    t1 = laserBeam.matrix;
    t1.setElements$1(spatial.matrix);
    t2 = -moveLeft;
    t3 = $.Matrix4_POSX;
    t4 = t1.array;
    if (t3 >= 16)
      return H.ioore(t4, t3);
    t5 = t4[t3];
    t6 = $.Matrix4_RIGHTX;
    if (t6 >= 16)
      return H.ioore(t4, t6);
    t4[t3] = t5 + t4[t6] * t2;
    t6 = $.Matrix4_POSY;
    if (t6 >= 16)
      return H.ioore(t4, t6);
    t5 = t4[t6];
    t7 = $.Matrix4_RIGHTY;
    if (t7 >= 16)
      return H.ioore(t4, t7);
    t4[t6] = t5 + t4[t7] * t2;
    t7 = $.Matrix4_POSZ;
    if (t7 >= 16)
      return H.ioore(t4, t7);
    t5 = t4[t7];
    t8 = $.Matrix4_RIGHTZ;
    if (t8 >= 16)
      return H.ioore(t4, t8);
    t4[t7] = t5 + t4[t8] * t2;
    t2 = t4[t3];
    t8 = $.Matrix4_UPX;
    if (t8 >= 16)
      return H.ioore(t4, t8);
    t4[t3] = t2 + t4[t8] * moveUp;
    t8 = t4[t6];
    t2 = $.Matrix4_UPY;
    if (t2 >= 16)
      return H.ioore(t4, t2);
    t4[t6] = t8 + t4[t2] * moveUp;
    t2 = t4[t7];
    t8 = $.Matrix4_UPZ;
    if (t8 >= 16)
      return H.ioore(t4, t8);
    t4[t7] = t2 + t4[t8] * moveUp;
    t1.rotate$2(0, -($.mouseY * 0.0012), laserBeam.getRight$0());
    t1.rotate$2(0, -(-$.mouseX * 0.0009), laserBeam.getUp$0());
    if (!found)
      $.chronosGL.programBasic.objects.push(laserBeam);
  },
  removeUnneededObjects: function(surfaces, shaders, indexes) {
    var skip, indicesList, t1, surface, t2, k, t3;
    skip = H.setRuntimeTypeInfo([], [P.String]);
    skip.push("flareShader");
    skip.push("textures/skies/blacksky");
    skip.push("textures/sfx/beam");
    skip.push("models/mapobjects/spotlamp/beam");
    skip.push("models/mapobjects/lamps/flare03");
    skip.push("models/mapobjects/teleporter/energy");
    skip.push("models/mapobjects/spotlamp/spotlamp");
    skip.push("models/mapobjects/spotlamp/spotlamp_l");
    skip.push("models/mapobjects/lamps/bot_lamp");
    skip.push("models/mapobjects/lamps/bot_lamp2");
    skip.push("models/mapobjects/lamps/bot_flare");
    skip.push("models/mapobjects/lamps/bot_flare2");
    skip.push("models/mapobjects/lamps/bot_wing");
    indicesList = H.setRuntimeTypeInfo([], [P.$int]);
    for (t1 = new H.ListIterator(surfaces, surfaces.length, 0, null); t1.moveNext$0();) {
      surface = t1.__internal$_current;
      t2 = surface.get$shaderNum();
      if (t2 < 0 || t2 >= shaders.length)
        return H.ioore(shaders, t2);
      if (C.JSArray_methods.contains$1(skip, shaders[t2].shader))
        continue;
      for (k = 0; k < surface.get$numIndexes(); ++k) {
        t2 = surface.firstVert;
        t3 = surface.firstIndex + k;
        if (t3 >= indexes.length)
          return H.ioore(indexes, t3);
        indicesList.push(t2 + indexes[t3]);
      }
    }
    return indicesList;
  },
  changeColors: function(surfaces, indexes, shaders, vertexes) {
    var blue, red, t1, face, t2, t3, k, t4, i, z;
    blue = H.setRuntimeTypeInfo([], [P.String]);
    blue.push("textures/base_wall/c_met5_2");
    blue.push("textures/base_trim/border11b");
    blue.push("textures/base_trim/border11light");
    blue.push("textures/base_light/lt2_2000");
    blue.push("textures/base_light/lt2_8000");
    blue.push("textures/base_light/baslt4_1_4k");
    blue.push("textures/base_wall/metaltech12final");
    blue.push("textures/base_light/light5_5k");
    blue.push("textures/base_wall/main_q3abanner");
    blue.push("textures/base_support/cable");
    blue.push("models/mapobjects/kmlamp1");
    blue.push("models/mapobjects/kmlamp_white");
    blue.push("models/mapobjects/teleporter/teleporter");
    blue.push("textures/base_trim/pewter_shiney");
    red = H.setRuntimeTypeInfo([], [P.String]);
    for (t1 = new H.ListIterator(surfaces, surfaces.length, 0, null); t1.moveNext$0();) {
      face = t1.__internal$_current;
      t2 = face.get$shaderNum();
      t3 = shaders.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(shaders, t2);
      if (C.JSArray_methods.contains$1(blue, shaders[t2].shader))
        for (k = 0; k < face.get$numIndexes(); ++k) {
          t2 = face.firstVert;
          t4 = face.firstIndex + k;
          if (t4 >= indexes.length)
            return H.ioore(indexes, t4);
          i = t2 + indexes[t4];
          if (i >= vertexes.length)
            return H.ioore(vertexes, i);
          t4 = vertexes[i].color;
          if (2 >= t4.length)
            return H.ioore(t4, 2);
          t4[2] = 1;
        }
      t2 = face.get$shaderNum();
      if (t2 < 0 || t2 >= t3)
        return H.ioore(shaders, t2);
      if (C.JSArray_methods.contains$1(red, shaders[t2].shader))
        for (k = 0; k < face.get$numIndexes(); ++k) {
          t2 = face.firstVert;
          t4 = face.firstIndex + k;
          if (t4 >= indexes.length)
            return H.ioore(indexes, t4);
          i = t2 + indexes[t4];
          if (i >= vertexes.length)
            return H.ioore(vertexes, i);
          t4 = vertexes[i].color;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          t4[0] = 1;
        }
      t2 = face.get$shaderNum();
      if (t2 < 0 || t2 >= t3)
        return H.ioore(shaders, t2);
      if (shaders[t2].shader === "textures/base_floor/diamond2c")
        for (k = 0; k < face.get$numIndexes(); ++k) {
          t2 = face.firstVert;
          t3 = face.firstIndex + k;
          if (t3 >= indexes.length)
            return H.ioore(indexes, t3);
          i = t2 + indexes[t3];
          if (i >= vertexes.length)
            return H.ioore(vertexes, i);
          t3 = vertexes[i];
          t2 = t3.xyz;
          if (2 >= t2.length)
            return H.ioore(t2, 2);
          z = t2[2];
          if (z >= 95 && z <= 108) {
            t2 = t3.color;
            t3 = t2.length;
            if (0 >= t3)
              return H.ioore(t2, 0);
            t2[0] = 0.25;
            if (1 >= t3)
              return H.ioore(t2, 1);
            t2[1] = 0.25;
            if (2 >= t3)
              return H.ioore(t2, 2);
            t2[2] = 1;
          }
        }
    }
  },
  QuakeCamera: {
    "^": "Animatable;camera,dir,velocity,position,onGround,groundTrace,smTrace,ssmTrace,tmp,bsp,qup,movementX,movementY,mins,maxs,checkPoint,tmp_cv,tmp_j,endVelocity,clipVelocity_,endClipVelocity,start_o,start_v,down_o,down_v,up,down",
    animate$1: function(_, elapsed) {
      var cpk, t1, t2, t3, t4, t5, x, y, z, t6, t7;
      cpk = $.get$currentlyPressedKeys();
      $.get$currentlyPressedMouseButtons();
      t1 = this.dir;
      t1.scale$1(0, 0);
      if (cpk.$index(0, $.Key_W) != null)
        t1.subtract$1(this.camera.getBack$0());
      if (cpk.$index(0, $.Key_A) != null)
        t1.subtract$1(this.camera.getRight$0());
      if (cpk.$index(0, $.Key_S) != null)
        t1.add$1(0, this.camera.getBack$0());
      if (cpk.$index(0, $.Key_D) != null)
        t1.add$1(0, this.camera.getRight$0());
      t2 = t1.array;
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      t2[2] = 0;
      t2 = this.position;
      t3 = this.camera;
      t2.set$1(t3.getPos$0()).scale$1(0, 100);
      if (cpk.$index(0, $.Key_SPACE) != null) {
        this.jump$0();
        cpk.$indexSet(0, $.Key_SPACE, null);
      }
      $.q3movement_frameTime = 0.125;
      this.groundCheck$0();
      t1.normalize$0(0);
      if (this.onGround)
        this.walkMove$1(t1);
      else {
        t4 = t1.array;
        t5 = t4.length;
        if (0 >= t5)
          return H.ioore(t4, 0);
        x = t4[0];
        if (1 >= t5)
          return H.ioore(t4, 1);
        y = t4[1];
        if (2 >= t5)
          return H.ioore(t4, 2);
        z = t4[2];
        this.accelerate$3(t1, Math.sqrt(H.checkNum(x * x + y * y + z * z)) * $.q3movement_scale, $.q3movement_airaccelerate);
        this.stepSlideMove$1(true);
      }
      t1 = t2.scale$1(0, 0.01);
      t2 = t3.matrix;
      t4 = $.Matrix4_POSX;
      t1 = t1.array;
      t5 = t1.length;
      if (0 >= t5)
        return H.ioore(t1, 0);
      t6 = t1[0];
      t7 = t2.array;
      if (t4 >= 16)
        return H.ioore(t7, t4);
      t7[t4] = t6;
      t6 = $.Matrix4_POSY;
      if (1 >= t5)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (t6 >= 16)
        return H.ioore(t7, t6);
      t7[t6] = t4;
      t4 = $.Matrix4_POSZ;
      if (2 >= t5)
        return H.ioore(t1, 2);
      t1 = t1[2];
      if (t4 >= 16)
        return H.ioore(t7, t4);
      t7[t4] = t1;
      t1 = this.movementY;
      if (t1 !== 0)
        t2.rotate$2(0, t1 * 0.006, t3.getRight$0());
      t1 = this.movementX;
      if (t1 !== 0)
        t2.rotate$2(0, t1 * 0.006, this.qup);
      this.movementX = 0;
      this.movementY = 0;
    },
    friction$0: function() {
      var t1, t2, t3, x, y, z, speed, newSpeed;
      if (!this.onGround)
        return;
      t1 = this.velocity;
      t2 = t1.array;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      x = t2[0];
      if (1 >= t3)
        return H.ioore(t2, 1);
      y = t2[1];
      if (2 >= t3)
        return H.ioore(t2, 2);
      z = t2[2];
      speed = Math.sqrt(H.checkNum(x * x + y * y + z * z));
      newSpeed = speed - P.max(speed, $.q3movement_stopspeed) * $.q3movement_friction * $.q3movement_frameTime;
      if (newSpeed < 0)
        newSpeed = 0;
      if (speed !== 0)
        t1.scale$1(0, newSpeed / speed);
      else
        t1.scale$1(0, 0);
    },
    groundCheck$0: function() {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = this.checkPoint;
      t2 = this.position;
      t3 = t2.array;
      t4 = t3.length;
      if (0 >= t4)
        return H.ioore(t3, 0);
      t5 = t3[0];
      t6 = t1.array;
      t7 = t6.length;
      if (0 >= t7)
        return H.ioore(t6, 0);
      t6[0] = t5;
      if (1 >= t4)
        return H.ioore(t3, 1);
      t5 = t3[1];
      if (1 >= t7)
        return H.ioore(t6, 1);
      t6[1] = t5;
      if (2 >= t4)
        return H.ioore(t3, 2);
      t3 = t3[2];
      if (2 >= t7)
        return H.ioore(t6, 2);
      t6[2] = t3 - 0.25;
      t3 = this.groundTrace;
      this.bsp.trace$5(t3, t2, t1, this.mins, this.maxs);
      if (t3.fraction === 1) {
        this.onGround = false;
        return;
      }
      t1 = this.velocity;
      t2 = t1.array;
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      if (t2[2] > 0 && t1.dot$1(t3.plane.normal) > 10) {
        this.onGround = false;
        return;
      }
      t1 = t3.plane.normal.array;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      if (t1[2] < 0.7) {
        this.onGround = false;
        return;
      }
      this.onGround = true;
    },
    clipVelocity$3: function(velIn, normal, out) {
      var backoff, t1, t2, t3;
      backoff = velIn.dot$1(normal);
      t1 = $.q3movement_overclip;
      backoff = backoff < 0 ? backoff * t1 : backoff / t1;
      t1 = out.array;
      t2 = velIn.$index(0, 0);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = t2;
      t2 = out.array;
      t1 = velIn.$index(0, 1);
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      t2[1] = t1;
      t1 = out.array;
      t2 = velIn.$index(0, 2);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2] = t2;
      t2 = this.tmp_cv;
      t1 = t2.array;
      t3 = normal.$index(0, 0);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0] = t3;
      t3 = t2.array;
      t1 = normal.$index(0, 1);
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      t3[1] = t1;
      t1 = t2.array;
      t3 = normal.$index(0, 2);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2] = t3;
      t3 = t2.array;
      t1 = t3.length;
      if (0 >= t1)
        return H.ioore(t3, 0);
      t3[0] = t3[0] * backoff;
      if (1 >= t1)
        return H.ioore(t3, 1);
      t3[1] = t3[1] * backoff;
      if (2 >= t1)
        return H.ioore(t3, 2);
      t3[2] = t3[2] * backoff;
      t3 = out.array;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t3[0] = t3[0] - t2.$index(0, 0);
      t3 = out.array;
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      t3[1] = t3[1] - t2.$index(0, 1);
      t3 = out.array;
      if (2 >= t3.length)
        return H.ioore(t3, 2);
      t3[2] = t3[2] - t2.$index(0, 2);
      return out;
    },
    accelerate$3: function(wishdir, wishspeed, accel) {
      var t1, addSpeed, accelSpeed;
      t1 = this.velocity;
      addSpeed = wishspeed - t1.dot$1(wishdir);
      if (addSpeed <= 0)
        return;
      accelSpeed = accel * $.q3movement_frameTime * wishspeed;
      t1.addScaledVector$2(wishdir, accelSpeed > addSpeed ? addSpeed : accelSpeed);
    },
    jump$0: function() {
      var t1, t2, t3, t4, t5, t6;
      if (!this.onGround)
        return false;
      this.onGround = false;
      t1 = $.q3movement_jumpvelocity;
      t2 = this.velocity.array;
      if (2 >= t2.length)
        return H.ioore(t2, 2);
      t2[2] = t1 * 2.5;
      t1 = this.position;
      t2 = this.groundTrace;
      t3 = t1.dot$1(t2.plane.normal);
      t2 = t2.plane;
      t4 = t2.dist;
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = $.q3movement_playerRadius;
      t6 = this.tmp_j;
      t6.set$1(t2.normal);
      t1.add$1(0, t6.scale$1(0, t3 - t4 - t5 + 5));
      $.get$snd().playSound$1("jump");
      return true;
    },
    walkMove$1: function(dir) {
      var t1, t2, x, y, z;
      this.friction$0();
      t1 = dir.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      x = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      y = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      z = t1[2];
      this.accelerate$3(dir, Math.sqrt(H.checkNum(x * x + y * y + z * z)) * $.q3movement_scale, $.q3movement_accelerate);
      t1 = this.velocity;
      this.clipVelocity$3(t1, this.groundTrace.plane.normal, t1);
      t1 = t1.array;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      if (t1[0] === 0) {
        if (1 >= t2)
          return H.ioore(t1, 1);
        t1 = t1[1] === 0;
      } else
        t1 = false;
      if (t1)
        return;
      this.stepSlideMove$1(false);
    },
    slideMove$1: function(gravity) {
      var planes, t1, t2, t3, time_left, end, t4, t5, t6, t7, bumpcount, t8, t9, t10, t11, i, j, dir, d, k;
      planes = H.setRuntimeTypeInfo([], [Q.Vector]);
      if (gravity) {
        t1 = this.endVelocity;
        t2 = this.velocity;
        t1.set$1(t2);
        t1 = t1.array;
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1[2] = t1[2] - $.q3movement_gravity * $.q3movement_frameTime;
        t3 = t2.array;
        if (2 >= t3.length)
          return H.ioore(t3, 2);
        t3[2] = (t3[2] + t1[2]) * 0.5;
        if (this.groundTrace.plane != null)
          this.clipVelocity$3(t2, this.groundTrace.plane.normal, t2);
      }
      if (this.groundTrace.plane != null)
        planes.push(this.groundTrace.plane.normal);
      t1 = this.velocity;
      planes.push(Q.Vector$fromList(t1.array).normalize$0(0));
      time_left = $.q3movement_frameTime;
      end = Q.Vector$(0, 0, 0);
      for (t2 = this.smTrace, t3 = this.position, t4 = t2.endPos, t5 = this.clipVelocity_, t6 = this.endVelocity, t7 = this.endClipVelocity, bumpcount = 0; bumpcount < 4; ++bumpcount) {
        t8 = end.array;
        t9 = t3.$index(0, 0);
        if (0 >= t8.length)
          return H.ioore(t8, 0);
        t8[0] = t9;
        t9 = end.array;
        t8 = t3.$index(0, 1);
        if (1 >= t9.length)
          return H.ioore(t9, 1);
        t9[1] = t8;
        t8 = end.array;
        t9 = t3.$index(0, 2);
        if (2 >= t8.length)
          return H.ioore(t8, 2);
        t8[2] = t9;
        end.addScaledVector$2(t1, time_left);
        this.bsp.trace$5(t2, t3, end, this.mins, this.maxs);
        if (t2.allSolid) {
          t2 = t1.array;
          if (2 >= t2.length)
            return H.ioore(t2, 2);
          t2[2] = 0;
          return true;
        }
        t8 = t2.fraction;
        if (typeof t8 !== "number")
          return t8.$gt();
        if (t8 > 0) {
          t8 = t3.array;
          t9 = t4.$index(0, 0);
          if (0 >= t8.length)
            return H.ioore(t8, 0);
          t8[0] = t9;
          t9 = t3.array;
          t8 = t4.$index(0, 1);
          if (1 >= t9.length)
            return H.ioore(t9, 1);
          t9[1] = t8;
          t8 = t3.array;
          t9 = t4.$index(0, 2);
          if (2 >= t8.length)
            return H.ioore(t8, 2);
          t8[2] = t9;
        }
        t8 = t2.fraction;
        if (t8 === 1)
          break;
        if (typeof t8 !== "number")
          return H.iae(t8);
        time_left -= time_left * t8;
        t8 = Array(4);
        t8.$builtinTypeInfo = [P.$double];
        t8 = new Q.Vector(null, null, t8);
        t9 = new Float32Array(3);
        t8.array = t9;
        if (0 >= 3)
          return H.ioore(t9, 0);
        t9[0] = 0;
        if (1 >= 3)
          return H.ioore(t9, 1);
        t9[1] = 0;
        if (2 >= 3)
          return H.ioore(t9, 2);
        t9[2] = 0;
        t10 = t2.plane.normal;
        t9[0] = t10.$index(0, 0);
        t11 = t10.$index(0, 1);
        if (1 >= 3)
          return H.ioore(t9, 1);
        t9[1] = t11;
        t10 = t10.$index(0, 2);
        if (2 >= 3)
          return H.ioore(t9, 2);
        t9[2] = t10;
        planes.push(t8);
        for (i = 0; i < planes.length; ++i) {
          if (t1.dot$1(planes[i]) >= 0.1)
            continue;
          if (i >= planes.length)
            return H.ioore(planes, i);
          this.clipVelocity$3(t1, planes[i], t5);
          if (i >= planes.length)
            return H.ioore(planes, i);
          this.clipVelocity$3(t6, planes[i], t7);
          for (j = 0; j < planes.length; ++j) {
            if (j === i)
              continue;
            if (t5.dot$1(planes[j]) >= 0.1)
              continue;
            if (j >= planes.length)
              return H.ioore(planes, j);
            this.clipVelocity$3(t5, planes[j], t5);
            if (j >= planes.length)
              return H.ioore(planes, j);
            this.clipVelocity$3(t7, planes[j], t7);
            if (i >= planes.length)
              return H.ioore(planes, i);
            if (t5.dot$1(planes[i]) >= 0)
              continue;
            t8 = Array(4);
            t8.$builtinTypeInfo = [P.$double];
            dir = new Q.Vector(null, null, t8);
            t8 = new Float32Array(3);
            dir.array = t8;
            if (0 >= 3)
              return H.ioore(t8, 0);
            t8[0] = 0;
            if (1 >= 3)
              return H.ioore(t8, 1);
            t8[1] = 0;
            if (2 >= 3)
              return H.ioore(t8, 2);
            t8[2] = 0;
            t8 = planes.length;
            if (i >= t8)
              return H.ioore(planes, i);
            t9 = planes[i];
            if (j >= t8)
              return H.ioore(planes, j);
            dir.cross2$2(t9, planes[j]);
            dir.normalize$0(0);
            d = dir.dot$1(t1);
            t9 = t5.array;
            t8 = dir.$index(0, 0);
            if (0 >= t9.length)
              return H.ioore(t9, 0);
            t9[0] = t8;
            t8 = t5.array;
            t9 = dir.$index(0, 1);
            if (1 >= t8.length)
              return H.ioore(t8, 1);
            t8[1] = t9;
            t9 = t5.array;
            t8 = dir.$index(0, 2);
            if (2 >= t9.length)
              return H.ioore(t9, 2);
            t9[2] = t8;
            t8 = t5.array;
            t9 = t8.length;
            if (0 >= t9)
              return H.ioore(t8, 0);
            t8[0] = t8[0] * d;
            if (1 >= t9)
              return H.ioore(t8, 1);
            t8[1] = t8[1] * d;
            if (2 >= t9)
              return H.ioore(t8, 2);
            t8[2] = t8[2] * d;
            t8 = planes.length;
            if (i >= t8)
              return H.ioore(planes, i);
            t9 = planes[i];
            if (j >= t8)
              return H.ioore(planes, j);
            dir.cross2$2(t9, planes[j]);
            dir.normalize$0(0);
            d = dir.dot$1(t6);
            t9 = t7.array;
            t8 = dir.$index(0, 0);
            if (0 >= t9.length)
              return H.ioore(t9, 0);
            t9[0] = t8;
            t8 = t7.array;
            t9 = dir.$index(0, 1);
            if (1 >= t8.length)
              return H.ioore(t8, 1);
            t8[1] = t9;
            t9 = t7.array;
            t8 = dir.$index(0, 2);
            if (2 >= t9.length)
              return H.ioore(t9, 2);
            t9[2] = t8;
            t8 = t7.array;
            t9 = t8.length;
            if (0 >= t9)
              return H.ioore(t8, 0);
            t8[0] = t8[0] * d;
            if (1 >= t9)
              return H.ioore(t8, 1);
            t8[1] = t8[1] * d;
            if (2 >= t9)
              return H.ioore(t8, 2);
            t8[2] = t8[2] * d;
            for (k = 0; k < planes.length; ++k) {
              if (k === i || k === j)
                continue;
              if (t5.dot$1(planes[k]) >= 0.1)
                continue;
              t2 = t1.array;
              t3 = t2.length;
              if (0 >= t3)
                return H.ioore(t2, 0);
              t2[0] = t2[0] * 0;
              if (1 >= t3)
                return H.ioore(t2, 1);
              t2[1] = t2[1] * 0;
              if (2 >= t3)
                return H.ioore(t2, 2);
              t2[2] = t2[2] * 0;
              return true;
            }
          }
          t8 = t1.array;
          t9 = t5.$index(0, 0);
          if (0 >= t8.length)
            return H.ioore(t8, 0);
          t8[0] = t9;
          t9 = t1.array;
          t8 = t5.$index(0, 1);
          if (1 >= t9.length)
            return H.ioore(t9, 1);
          t9[1] = t8;
          t8 = t1.array;
          t9 = t5.$index(0, 2);
          if (2 >= t8.length)
            return H.ioore(t8, 2);
          t8[2] = t9;
          t9 = t6.array;
          t8 = t7.$index(0, 0);
          if (0 >= t9.length)
            return H.ioore(t9, 0);
          t9[0] = t8;
          t8 = t6.array;
          t9 = t7.$index(0, 1);
          if (1 >= t8.length)
            return H.ioore(t8, 1);
          t8[1] = t9;
          t9 = t6.array;
          t8 = t7.$index(0, 2);
          if (2 >= t9.length)
            return H.ioore(t9, 2);
          t9[2] = t8;
          break;
        }
      }
      if (gravity)
        t1.set$1(t6);
      return bumpcount !== 0;
    },
    stepSlideMove$1: function(gravity) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      t1 = this.start_o;
      t2 = this.position;
      t1.set$1(t2);
      t3 = this.start_v;
      t4 = this.velocity;
      t3.set$1(t4);
      if (!this.slideMove$1(gravity))
        return;
      t5 = this.down;
      t5.set$1(t1);
      t6 = t5.array;
      if (2 >= t6.length)
        return H.ioore(t6, 2);
      t6[2] = t6[2] - $.STEPSIZE;
      t6 = this.ssmTrace;
      this.bsp.trace$5(t6, t1, t5, this.mins, this.maxs);
      t7 = this.up;
      t7.set$1(this.qup);
      t8 = t4.array;
      if (2 >= t8.length)
        return H.ioore(t8, 2);
      if (t8[2] > 0)
        t8 = t6.fraction === 1 || t6.plane.normal.dot$1(t7) < 0.7;
      else
        t8 = false;
      if (t8)
        return;
      this.down_o.set$1(t2);
      this.down_v.set$1(t4);
      t7.set$1(t1);
      t8 = t7.array;
      if (2 >= t8.length)
        return H.ioore(t8, 2);
      t8[2] = t8[2] + $.STEPSIZE;
      this.bsp.trace$5(t6, t1, t7, this.mins, this.maxs);
      if (t6.allSolid)
        return;
      t7 = t6.endPos;
      t8 = t7.array;
      if (2 >= t8.length)
        return H.ioore(t8, 2);
      t8 = t8[2];
      t1 = t1.array;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2.set$1(t7);
      t4.set$1(t3);
      this.slideMove$1(gravity);
      t5.set$1(t2);
      t3 = t5.array;
      if (2 >= t3.length)
        return H.ioore(t3, 2);
      t3[2] = t3[2] - (t8 - t1);
      this.bsp.trace$5(t6, t2, t5, this.mins, this.maxs);
      if (!t6.allSolid)
        t2.set$1(t7);
      t1 = t6.fraction;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 1)
        this.clipVelocity$3(t4, t6.plane.normal, t4);
    },
    QuakeCamera$1: function(camera) {
      var canvas, t1;
      canvas = document.body;
      canvas.toString;
      t1 = H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(canvas, "mousedown", false), [null]);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new X.QuakeCamera_closure(this, canvas)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
      t1 = H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(canvas, "mousemove", false), [null]);
      H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new X.QuakeCamera_closure0(this)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    },
    static: {QuakeCamera$: function(camera) {
        var t1 = new X.QuakeCamera(camera, Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), false, new X.Trace(false, false, 1, Q.Vector$(0, 0, 0), B.Plane$(null, null), null, null, null), new X.Trace(false, false, 1, Q.Vector$(0, 0, 0), B.Plane$(null, null), null, null, null), new X.Trace(false, false, 1, Q.Vector$(0, 0, 0), B.Plane$(null, null), null, null, null), Q.Vector$(0, 0, 0), null, Q.Vector$(0, 0, 1), 0, 0, Q.Vector$(-15, -15, -24), Q.Vector$(15, 15, 32), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 1), Q.Vector$(0, 0, 0));
        t1.QuakeCamera$1(camera);
        return t1;
      }}
  },
  QuakeCamera_closure: {
    "^": "Closure:15;this_0,canvas_1",
    call$1: function(e) {
      var t1;
      J.preventDefault$0$x(e);
      t1 = this.canvas_1;
      if (document.pointerLockElement !== t1) {
        t1.requestPointerLock();
        t1.requestFullscreen();
      } else {
        $.get$snd().playSound$1("rail");
        X.addLaser(this.this_0.camera, 0, -0.2);
      }
    }
  },
  QuakeCamera_closure0: {
    "^": "Closure:15;this_2",
    call$1: function(e) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(e);
      t1.preventDefault$0(e);
      t2 = this.this_2;
      t3 = t2.movementX;
      t1 = t1.get$movement(e).x;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2.movementX = t3 + t1;
      t1 = t2.movementY;
      t3 = H.setRuntimeTypeInfo(new P.Point(e.webkitMovementX, e.webkitMovementY), [null]).y;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2.movementY = t1 + t3;
    }
  },
  main_closure: {
    "^": "Closure:8;",
    call$1: function(n) {
      var t1, t2, t3;
      t1 = $.textureCache;
      t2 = "textures/skybox_" + H.S(n) + ".png";
      t3 = t1.textureCache;
      t1 = B.TextureWrapper$(t1.gl, null);
      t3.$indexSet(0, t2, t1);
      return t1;
    }
  },
  main_closure0: {
    "^": "Closure:6;sp_0,fpscam_1,utils_2",
    call$0: function() {
      var t1, tnx, tpx, tnz, tpz, tny, tpy, skybox_nx, t2, skybox_px, skybox_nz, skybox_pz, skybox_ny, t3, skybox_py;
      t1 = this.utils_2;
      tnx = t1.textureCache.textureCache.$index(0, "textures/skybox_nx.png").get$texture();
      tpx = t1.textureCache.textureCache.$index(0, "textures/skybox_px.png").get$texture();
      tnz = t1.textureCache.textureCache.$index(0, "textures/skybox_nz.png").get$texture();
      tpz = t1.textureCache.textureCache.$index(0, "textures/skybox_pz.png").get$texture();
      tny = t1.textureCache.textureCache.$index(0, "textures/skybox_ny.png").get$texture();
      tpy = t1.textureCache.textureCache.$index(0, "textures/skybox_py.png").get$texture();
      skybox_nx = t1.getWall$2(tnx, 1004);
      skybox_nx.setPos$3(-2, 2, -1000);
      t2 = t1.chronosGL;
      t2.programBasic.followCameraObjects.push(skybox_nx);
      skybox_px = t1.getWall$2(tpx, 1004);
      skybox_px.setPos$3(-2, 2, 1000);
      skybox_px.matrix.rotateY$1(3.141592653589793);
      t2.programBasic.followCameraObjects.push(skybox_px);
      skybox_nz = t1.getWall$2(tnz, 1004);
      skybox_nz.setPos$3(-1000, 2, -2);
      skybox_nz.matrix.rotateY$1(1.5707963267948966);
      t2.programBasic.followCameraObjects.push(skybox_nz);
      skybox_pz = t1.getWall$2(tpz, 1004);
      skybox_pz.setPos$3(1000, 2, -2);
      skybox_pz.matrix.rotateY$1(4.71238898038469);
      t2.programBasic.followCameraObjects.push(skybox_pz);
      skybox_ny = t1.getWall$2(tny, 1004);
      skybox_ny.setPos$3(-2, -1000, -2);
      t3 = skybox_ny.matrix;
      t3.rotateX$1(4.71238898038469);
      t3.rotateZ$1(4.71238898038469);
      t2.programBasic.followCameraObjects.push(skybox_ny);
      skybox_py = t1.getWall$2(tpy, 1004);
      skybox_py.setPos$3(-2, 1000, -2);
      t1 = skybox_py.matrix;
      t1.rotateX$1(1.5707963267948966);
      t1.rotateZ$1(1.5707963267948966);
      t2.programBasic.followCameraObjects.push(skybox_py);
      $.chronosGL._utils.loadFile$2("data/q3dm17.bsp", true).then$1(new X.main__closure(this.sp_0, this.fpscam_1));
    }
  },
  main__closure: {
    "^": "Closure:28;sp_3,fpscam_4",
    call$1: function(bspFile) {
      var parser, cm, vertsList, normalsList, texCoordsList, lmCoordsList, colorsList, t1, vertex, t2, xs, vs, ns, cs, a;
      parser = new B.BSPParser(null, null, null);
      parser.BSPParser$1(bspFile);
      cm = parser.getClipMap$0();
      X.changeColors(cm.surfaces, cm.drawIndexes, cm.shaders, cm.drawVerts);
      vertsList = H.setRuntimeTypeInfo([], [P.$double]);
      normalsList = H.setRuntimeTypeInfo([], [P.$double]);
      texCoordsList = H.setRuntimeTypeInfo([], [P.$double]);
      lmCoordsList = H.setRuntimeTypeInfo([], [P.$double]);
      colorsList = H.setRuntimeTypeInfo([], [P.$double]);
      for (t1 = cm.drawVerts, t1 = new H.ListIterator(t1, t1.length, 0, null); t1.moveNext$0();) {
        vertex = t1.__internal$_current;
        C.JSArray_methods.addAll$1(vertsList, vertex.get$xyz());
        C.JSArray_methods.addAll$1(normalsList, vertex.normal);
        t2 = vertex.st;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        texCoordsList.push(t2[0]);
        t2 = vertex.st;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        texCoordsList.push(t2[1]);
        t2 = vertex.lightmap;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        lmCoordsList.push(t2[0]);
        t2 = vertex.lightmap;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        lmCoordsList.push(t2[1]);
        C.JSArray_methods.addAll$1(colorsList, vertex.color);
      }
      xs = new Uint16Array(H._ensureNativeList(X.removeUnneededObjects(cm.surfaces, cm.shaders, cm.drawIndexes)));
      vs = new Float32Array(H._ensureNativeList(vertsList));
      ns = new Float32Array(H._ensureNativeList(normalsList));
      cs = new Float32Array(H._ensureNativeList(colorsList));
      this.fpscam_4.bsp = X.BSPTree$(cm);
      for (t1 = vs.length, a = 0; a < t1; ++a)
        vs[a] = vs[a] / 100;
      t1 = new B.MeshData(vs, cs, ns, null, null, xs, null, null, false);
      t1.optimize$0();
      this.sp_3.objects.push(B.Mesh$(t1, false));
      $.chronosGL.run$0();
    }
  },
  LaserBeam: {
    "^": "Node;lifeTime,boxCorner1,boxCorner2,lineStart,lineEnd,Hit,name,type,enabled,invert,children,mvMatrix,tempMatrix,animateCallback,matrix,_pos,_back,_up,_right",
    animate$1: function(_, elapsed) {
      var t1, t2, $back, objects, t3, t4, t5, found, currentDistance, currentBlock, i, object, t6, t7, t8, d;
      t1 = this.lifeTime -= elapsed;
      if (t1 < 0) {
        this.enabled = false;
        return;
      }
      this.moveBackward$1(-(elapsed / 2));
      t1 = this.lineStart;
      t1.set$1(this.getPos$0());
      t2 = this.lineEnd;
      t2.set$1(this.getPos$0());
      $back = this.getBack$0();
      $back.scale$1(0, 15);
      t1.add$1(0, $back);
      t2.subtract$1($back);
      objects = $.chronosGL.programBasic.objects;
      for (t3 = this.boxCorner1, t4 = this.boxCorner2, t5 = this.Hit, found = false, currentDistance = 1000, currentBlock = null, i = 0; i < objects.length; ++i) {
        object = objects[i];
        if ("block" === object.type && object.enabled) {
          t6 = object.getPos$0();
          t7 = t3.array;
          t8 = t6.$index(0, 0);
          if (0 >= t7.length)
            return H.ioore(t7, 0);
          t7[0] = t8;
          t8 = t3.array;
          t7 = t6.$index(0, 1);
          if (1 >= t8.length)
            return H.ioore(t8, 1);
          t8[1] = t7;
          t7 = t3.array;
          t6 = t6.$index(0, 2);
          if (2 >= t7.length)
            return H.ioore(t7, 2);
          t7[2] = t6;
          t6 = object.getPos$0();
          t7 = t4.array;
          t8 = t6.$index(0, 0);
          if (0 >= t7.length)
            return H.ioore(t7, 0);
          t7[0] = t8;
          t8 = t4.array;
          t7 = t6.$index(0, 1);
          if (1 >= t8.length)
            return H.ioore(t8, 1);
          t8[1] = t7;
          t7 = t4.array;
          t6 = t6.$index(0, 2);
          if (2 >= t7.length)
            return H.ioore(t7, 2);
          t7[2] = t6;
          t6 = t3.array;
          t7 = t6.length;
          if (0 >= t7)
            return H.ioore(t6, 0);
          t6[0] = t6[0] - 1;
          if (1 >= t7)
            return H.ioore(t6, 1);
          t6[1] = t6[1] - 1;
          if (2 >= t7)
            return H.ioore(t6, 2);
          t6[2] = t6[2] - 1;
          t6 = t4.array;
          t7 = t6.length;
          if (0 >= t7)
            return H.ioore(t6, 0);
          t6[0] = t6[0] + 1;
          if (1 >= t7)
            return H.ioore(t6, 1);
          t6[1] = t6[1] + 1;
          if (2 >= t7)
            return H.ioore(t6, 2);
          t6[2] = t6[2] + 1;
          if (B.checkLineBox(t3, t4, t1, t2, t5) > 0) {
            d = t1.dist$1(t5);
            if (d < currentDistance) {
              currentBlock = object;
              currentDistance = d;
            }
            found = true;
          }
        }
      }
      if (found) {
        currentBlock.enabled = false;
        this.lifeTime = 0;
      }
    },
    $isLaserBeam: true
  },
  Trace: {
    "^": "Object;allSolid<,startSolid,fraction,endPos,plane<,surfaceFlags,contents,entityNum",
    set$1: function(trace) {
      var t1;
      this.allSolid = trace.get$allSolid();
      this.startSolid = trace.startSolid;
      this.fraction = trace.fraction;
      this.endPos.set$1(trace.endPos);
      if (trace.plane != null) {
        t1 = this.plane;
        if (t1 == null) {
          t1 = B.Plane$(null, null);
          this.plane = t1;
        }
        t1.normal.set$1(trace.plane.normal);
        t1 = this.plane;
        t1.dist = trace.plane.dist;
        t1.setTypeAndSignbits$0();
      } else
        this.plane = null;
      this.surfaceFlags = trace.surfaceFlags;
      this.contents = trace.contents;
      this.entityNum = trace.entityNum;
    }
  },
  TraceWork: {
    "^": "Object;start,end,size,offsets,maxOffset,extents,bounds,modelOrigin,contents,isPoint,trace",
    reset$0: function(_) {
      var t1, t2;
      this.start.scale$1(0, 0);
      this.end.scale$1(0, 0);
      C.JSArray_methods.forEach$1(this.size, new X.TraceWork_reset_closure());
      C.JSArray_methods.forEach$1(this.offsets, new X.TraceWork_reset_closure0());
      this.maxOffset = 0;
      this.extents.scale$1(0, 0);
      C.JSArray_methods.forEach$1(this.bounds, new X.TraceWork_reset_closure1());
      this.modelOrigin.scale$1(0, 0);
      this.contents = 0;
      this.isPoint = false;
      t1 = this.trace;
      t1.allSolid = false;
      t1.startSolid = false;
      t1.fraction = 1;
      t1.endPos.scale$1(0, 0);
      t2 = t1.plane;
      t2.normal.scale$1(0, 0);
      t2.dist = 0;
      t2.setTypeAndSignbits$0();
      t1.surfaceFlags = 0;
      t1.contents = 0;
      t1.entityNum = 0;
    }
  },
  TraceWork_reset_closure: {
    "^": "Closure:8;",
    call$1: function(v) {
      return J.scale$1$x(v, 0);
    }
  },
  TraceWork_reset_closure0: {
    "^": "Closure:8;",
    call$1: function(v) {
      return J.scale$1$x(v, 0);
    }
  },
  TraceWork_reset_closure1: {
    "^": "Closure:8;",
    call$1: function(v) {
      return J.scale$1$x(v, 0);
    }
  },
  WrapHit: {
    "^": "Object;hit,enterFrac,leaveFrac"
  },
  BSPTree: {
    "^": "Object;cm,tw,plane<,bestplane,startp,endp,wrapHit",
    trace$9: function(trace, start, end, mins, maxs, modelClipHandle, origin, brushmask, capsule) {
      var t1, offset, t2, t3, t4, i, t5, t6, t7, t8, t9;
      t1 = H._checkLength(3);
      offset = new Float32Array(t1);
      ++this.cm.checkcount;
      t2 = this.tw;
      t2.reset$0(0);
      origin = $.get$ORIGIN();
      t2.modelOrigin.set$1(origin);
      t2.contents = brushmask;
      for (t3 = t2.start, t4 = t2.end, i = 0; i < 3; ++i) {
        t5 = mins.array;
        if (i >= t5.length)
          return H.ioore(t5, i);
        t6 = t5[i];
        t7 = maxs.array;
        if (i >= t7.length)
          return H.ioore(t7, i);
        t7 = t7[i];
        if (i >= t1)
          return H.ioore(offset, i);
        offset[i] = (t6 + t7) * 0.5;
        t7 = t2.size;
        if (0 >= t7.length)
          return H.ioore(t7, 0);
        J.$indexSet$ax(t7[0], i, t5[i] - offset[i]);
        t5 = t2.size;
        if (1 >= t5.length)
          return H.ioore(t5, 1);
        t5 = t5[1];
        t7 = maxs.array;
        if (i >= t7.length)
          return H.ioore(t7, i);
        J.$indexSet$ax(t5, i, t7[i] - offset[i]);
        t7 = start.array;
        if (i >= t7.length)
          return H.ioore(t7, i);
        t7 = t7[i];
        t5 = offset[i];
        t6 = t3.array;
        if (i >= t6.length)
          return H.ioore(t6, i);
        t6[i] = t7 + t5;
        t5 = end.array;
        if (i >= t5.length)
          return H.ioore(t5, i);
        t5 = t5[i];
        t7 = offset[i];
        t6 = t4.array;
        if (i >= t6.length)
          return H.ioore(t6, i);
        t6[i] = t5 + t7;
      }
      t1 = t2.size;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t1 = J.$index$asx(t1[1], 0);
      t5 = t2.size;
      if (1 >= t5.length)
        return H.ioore(t5, 1);
      t5 = J.$add$ns(t1, J.$index$asx(t5[1], 1));
      t1 = t2.size;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t2.maxOffset = J.$add$ns(t5, J.$index$asx(t1[1], 2));
      for (t1 = t2.offsets, i = 0; i < 8; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t5 = t1[i];
        t6 = t2.size;
        t7 = (i & 1) > 0 ? 1 : 0;
        if (t7 >= t6.length)
          return H.ioore(t6, t7);
        J.$indexSet$ax(t5, 0, J.$index$asx(t6[t7], 0));
        if (i >= t1.length)
          return H.ioore(t1, i);
        t7 = t1[i];
        t6 = t2.size;
        t5 = (i & 2) > 0 ? 1 : 0;
        if (t5 >= t6.length)
          return H.ioore(t6, t5);
        J.$indexSet$ax(t7, 1, J.$index$asx(t6[t5], 1));
        if (i >= t1.length)
          return H.ioore(t1, i);
        t5 = t1[i];
        t6 = t2.size;
        t7 = (i & 4) > 0 ? 1 : 0;
        if (t7 >= t6.length)
          return H.ioore(t6, t7);
        J.$indexSet$ax(t5, 2, J.$index$asx(t6[t7], 2));
      }
      for (t1 = t2.bounds, i = 0; i < 3; ++i) {
        t5 = t3.array;
        if (i >= t5.length)
          return H.ioore(t5, i);
        t5 = t5[i];
        t6 = t4.array;
        if (i >= t6.length)
          return H.ioore(t6, i);
        t6 = t6[i];
        t7 = t1.length;
        t8 = t1[0];
        t9 = t2.size;
        if (t5 < t6) {
          if (0 >= t7)
            return H.ioore(t1, 0);
          if (0 >= t9.length)
            return H.ioore(t9, 0);
          t6 = J.$index$asx(t9[0], i);
          if (typeof t6 !== "number")
            return H.iae(t6);
          J.$indexSet$ax(t8, i, t5 + t6);
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          t6 = t1[1];
          t5 = t4.array;
          if (i >= t5.length)
            return H.ioore(t5, i);
          t5 = t5[i];
          t8 = t2.size;
          if (1 >= t8.length)
            return H.ioore(t8, 1);
          t8 = J.$index$asx(t8[1], i);
          if (typeof t8 !== "number")
            return H.iae(t8);
          J.$indexSet$ax(t6, i, t5 + t8);
        } else {
          if (0 >= t7)
            return H.ioore(t1, 0);
          if (0 >= t9.length)
            return H.ioore(t9, 0);
          t5 = J.$index$asx(t9[0], i);
          if (typeof t5 !== "number")
            return H.iae(t5);
          J.$indexSet$ax(t8, i, t6 + t5);
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          t5 = t1[1];
          t6 = t3.array;
          if (i >= t6.length)
            return H.ioore(t6, i);
          t6 = t6[i];
          t8 = t2.size;
          if (1 >= t8.length)
            return H.ioore(t8, 1);
          t8 = J.$index$asx(t8[1], i);
          if (typeof t8 !== "number")
            return H.iae(t8);
          J.$indexSet$ax(t5, i, t6 + t8);
        }
      }
      t1 = t2.size;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      if (J.$eq(J.$index$asx(t1[0], 0), 0)) {
        t1 = t2.size;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        if (J.$eq(J.$index$asx(t1[0], 1), 0)) {
          t1 = t2.size;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = J.$eq(J.$index$asx(t1[0], 2), 0);
        } else
          t1 = false;
      } else
        t1 = false;
      t3 = t2.extents;
      if (t1) {
        t2.isPoint = true;
        t3.scale$1(0, 0);
      } else {
        t2.isPoint = false;
        t1 = t2.size;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t1 = J.$index$asx(t1[1], 0);
        t4 = t3.array;
        if (0 >= t4.length)
          return H.ioore(t4, 0);
        t4[0] = t1;
        t1 = t2.size;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t1 = J.$index$asx(t1[1], 1);
        t4 = t3.array;
        if (1 >= t4.length)
          return H.ioore(t4, 1);
        t4[1] = t1;
        t1 = t2.size;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t1 = J.$index$asx(t1[1], 2);
        t3 = t3.array;
        if (2 >= t3.length)
          return H.ioore(t3, 2);
        t3[2] = t1;
      }
      this.traceThroughTree$6(t2, 0, 0, 1, start, end);
      t1 = t2.trace;
      t2 = t1.endPos;
      if (t1.fraction === 1)
        t2.set$1(end);
      else {
        t2 = t2.set$1(start);
        t3 = t1.fraction;
        t2 = t2.array;
        t4 = t2.length;
        if (0 >= t4)
          return H.ioore(t2, 0);
        t5 = t2[0];
        t6 = end.array;
        t7 = t6.length;
        if (0 >= t7)
          return H.ioore(t6, 0);
        t8 = t6[0];
        if (typeof t3 !== "number")
          return t3.$mul();
        t2[0] = t5 + t3 * (t8 - t5);
        if (1 >= t4)
          return H.ioore(t2, 1);
        t5 = t2[1];
        if (1 >= t7)
          return H.ioore(t6, 1);
        t2[1] = t5 + t3 * (t6[1] - t5);
        if (2 >= t4)
          return H.ioore(t2, 2);
        t4 = t2[2];
        if (2 >= t7)
          return H.ioore(t6, 2);
        t2[2] = t4 + t3 * (t6[2] - t4);
      }
      trace.set$1(t1);
    },
    trace$5: function(trace, start, end, mins, maxs) {
      return this.trace$9(trace, start, end, mins, maxs, 0, null, 0, false);
    },
    traceThroughLeaf$2: function(tw, leaf) {
      var t1, i, t2, t3, t4, brush, shader, k, t5, patch, oldFrac;
      for (t1 = this.cm, i = 0; i < leaf.numLeafBrushes; ++i) {
        t2 = t1.brushes;
        t3 = t1.leafBrushes;
        t4 = leaf.firstLeafBrush + i;
        if (t4 < 0 || t4 >= t3.length)
          return H.ioore(t3, t4);
        t4 = t3[t4];
        if (t4 < 0 || t4 >= t2.length)
          return H.ioore(t2, t4);
        brush = t2[t4];
        t4 = t1.shaders;
        t2 = brush.shaderNum;
        if (t2 < 0 || t2 >= t4.length)
          return H.ioore(t4, t2);
        shader = t4[t2];
        if (brush.numSides > 0 && (shader.contentFlags & 1) === 1)
          this.traceThroughBrush$2(tw, brush);
      }
      for (t2 = tw.trace, k = 0; k < leaf.numLeafSurfaces; ++k) {
        t3 = t1.surfacesUntessellated;
        t4 = t1.leafSurfaces;
        t5 = leaf.firstLeafSurface + k;
        if (t5 < 0 || t5 >= t4.length)
          return H.ioore(t4, t5);
        t5 = t4[t5];
        if (t5 < 0 || t5 >= t3.length)
          return H.ioore(t3, t5);
        patch = t3[t5].get$patchRef();
        if (patch == null)
          continue;
        oldFrac = t2.fraction;
        this.traceThroughPatchCollide$2(tw, patch.pc);
        t3 = t2.fraction;
        if (typeof t3 !== "number")
          return t3.$lt();
        if (typeof oldFrac !== "number")
          return H.iae(oldFrac);
        if (t3 < oldFrac) {
          t2.surfaceFlags = patch.surfaceFlags;
          t2.contents = patch.contents;
        }
      }
    },
    traceThroughPatchCollide$2: function(tw, pc) {
      var t1, t2, t3, t4, t5, t6, t7, t8, j, i, t9, facet, t10, planes, offset, t11, t12, hitnum, t13, t14;
      t1 = this.wrapHit;
      t2 = this.startp;
      t3 = this.endp;
      t4 = tw.offsets;
      t5 = tw.start;
      t6 = tw.end;
      t7 = this.bestplane;
      t8 = tw.trace;
      j = null;
      i = 0;
      while (true) {
        t9 = pc.numFacets;
        if (typeof t9 !== "number")
          return H.iae(t9);
        if (!(i < t9))
          break;
        c$0: {
          t9 = pc.facets;
          if (i >= t9.length)
            return H.ioore(t9, i);
          facet = t9[i];
          t1.enterFrac = -1;
          t1.leaveFrac = 1;
          t9 = pc.planes;
          t10 = facet._surfacePlane;
          if (t10 >>> 0 !== t10 || t10 >= t9.length)
            return H.ioore(t9, t10);
          planes = t9[t10];
          B.VectorCopy(planes.plane, this.plane);
          t10 = planes.signbits;
          if (t10 >>> 0 !== t10 || t10 >= t4.length)
            return H.ioore(t4, t10);
          offset = B.DotProduct(t4[t10].get$array(), this.plane);
          t10 = this.plane;
          t10[3] = J.$sub$n(t10[3], offset);
          t10 = t2.array;
          t9 = t5.$index(0, 0);
          if (0 >= t10.length)
            return H.ioore(t10, 0);
          t10[0] = t9;
          t9 = t2.array;
          t10 = t5.$index(0, 1);
          if (1 >= t9.length)
            return H.ioore(t9, 1);
          t9[1] = t10;
          t10 = t2.array;
          t9 = t5.$index(0, 2);
          if (2 >= t10.length)
            return H.ioore(t10, 2);
          t10[2] = t9;
          t9 = t3.array;
          t10 = t6.$index(0, 0);
          if (0 >= t9.length)
            return H.ioore(t9, 0);
          t9[0] = t10;
          t10 = t3.array;
          t9 = t6.$index(0, 1);
          if (1 >= t10.length)
            return H.ioore(t10, 1);
          t10[1] = t9;
          t9 = t3.array;
          t10 = t6.$index(0, 2);
          if (2 >= t9.length)
            return H.ioore(t9, 2);
          t9[2] = t10;
          if (!this.checkFacetPlane$4(this.plane, t2, t3, t1))
            break c$0;
          if (t1.hit !== 0) {
            t9 = this.plane;
            H.IterableMixinWorkaround_setAllList(t7, 0, t9);
          }
          t9 = facet.borderInward;
          t10 = t9.length;
          t11 = facet.borderPlanes;
          t12 = t11.length;
          j = 0;
          hitnum = -1;
          while (true) {
            t13 = facet.numBorders;
            if (typeof t13 !== "number")
              return H.iae(t13);
            if (!(j < t13))
              break;
            t13 = pc.planes;
            if (j >= t12)
              return H.ioore(t11, j);
            t14 = t11[j];
            if (t14 >>> 0 !== t14 || t14 >= t13.length)
              return H.ioore(t13, t14);
            planes = t13[t14];
            if (j >= t10)
              return H.ioore(t9, j);
            t13 = t9[j];
            t14 = this.plane;
            if (t13 === true) {
              t14[0] = J.$negate$n(planes.plane[0]);
              this.plane[1] = J.$negate$n(planes.plane[1]);
              this.plane[2] = J.$negate$n(planes.plane[2]);
              this.plane[3] = J.$negate$n(planes.plane[3]);
            } else
              B.VectorCopy(planes.plane, t14);
            t13 = planes.signbits;
            if (t13 >>> 0 !== t13 || t13 >= t4.length)
              return H.ioore(t4, t13);
            offset = B.DotProduct(t4[t13].get$array(), this.plane);
            t13 = this.plane;
            t13[3] = J.$add$ns(t13[3], Math.abs(offset));
            t13 = t2.array;
            t14 = t5.$index(0, 0);
            if (0 >= t13.length)
              return H.ioore(t13, 0);
            t13[0] = t14;
            t14 = t2.array;
            t13 = t5.$index(0, 1);
            if (1 >= t14.length)
              return H.ioore(t14, 1);
            t14[1] = t13;
            t13 = t2.array;
            t14 = t5.$index(0, 2);
            if (2 >= t13.length)
              return H.ioore(t13, 2);
            t13[2] = t14;
            t14 = t3.array;
            t13 = t6.$index(0, 0);
            if (0 >= t14.length)
              return H.ioore(t14, 0);
            t14[0] = t13;
            t13 = t3.array;
            t14 = t6.$index(0, 1);
            if (1 >= t13.length)
              return H.ioore(t13, 1);
            t13[1] = t14;
            t14 = t3.array;
            t13 = t6.$index(0, 2);
            if (2 >= t14.length)
              return H.ioore(t14, 2);
            t14[2] = t13;
            if (!this.checkFacetPlane$4(this.plane, t2, t3, t1))
              break;
            if (t1.hit !== 0) {
              B.VectorCopy(this.plane, t7);
              hitnum = j;
            }
            ++j;
          }
          t9 = facet.numBorders;
          if (typeof t9 !== "number")
            return H.iae(t9);
          if (j < t9)
            break c$0;
          if (hitnum === t9 - 1)
            break c$0;
          t9 = t1.enterFrac;
          t10 = t1.leaveFrac;
          if (typeof t9 !== "number")
            return t9.$lt();
          if (typeof t10 !== "number")
            return H.iae(t10);
          if (t9 < t10 && t9 >= 0) {
            t10 = t8.fraction;
            if (typeof t10 !== "number")
              return H.iae(t10);
            if (t9 < t10) {
              if (t9 < 0) {
                t1.enterFrac = 0;
                t9 = 0;
              }
              t8.fraction = t9;
              B.VectorCopy(t7, t8.plane.normal.array);
              t8.plane.dist = t7[3];
            }
          }
        }
        ++i;
      }
    },
    checkFacetPlane$4: function(plane, start, end, wrapHit) {
      var t1, t2, d1, d2, f;
      wrapHit.hit = 0;
      t1 = B.DotProduct(start.array, plane);
      t2 = plane[3];
      if (typeof t2 !== "number")
        return H.iae(t2);
      d1 = t1 - t2;
      t2 = B.DotProduct(end.array, plane);
      t1 = plane[3];
      if (typeof t1 !== "number")
        return H.iae(t1);
      d2 = t2 - t1;
      if (d1 > 0)
        t1 = d2 >= 0.125 || d2 >= d1;
      else
        t1 = false;
      if (t1)
        return false;
      if (d1 <= 0 && d2 <= 0)
        return true;
      t1 = d1 - d2;
      if (d1 > d2) {
        f = (d1 - 0.125) / t1;
        if (f < 0)
          f = 0;
        t1 = wrapHit.enterFrac;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (f > t1) {
          wrapHit.enterFrac = f;
          wrapHit.hit = 1;
        }
      } else {
        f = (d1 + 0.125) / t1;
        if (f > 1)
          f = 1;
        t1 = wrapHit.leaveFrac;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (f < t1)
          wrapHit.leaveFrac = f;
      }
      return true;
    },
    traceThroughTree$6: function(tw, num, p1f, p2f, p1, p2) {
      var mid, t1, t2, node, plane, t3, t10, offset, idist, frac2, frac, side, t4, t5, t6, t7, i, t8, t9;
      mid = Q.Vector$(0, 0, 0);
      t1 = tw.trace.fraction;
      if (typeof t1 !== "number")
        return t1.$le();
      if (t1 <= p1f)
        return;
      if (num < 0) {
        t1 = this.cm.leafs;
        t2 = -1 - num;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        this.traceThroughLeaf$2(tw, t1[t2]);
        return;
      }
      t1 = this.cm;
      t2 = t1.nodes;
      if (num >= t2.length)
        return H.ioore(t2, num);
      node = t2[num];
      t1 = t1.planes;
      t2 = node.planeNum;
      if (t2 < 0 || t2 >= t1.length)
        return H.ioore(t1, t2);
      plane = t1[t2];
      t1 = plane.type;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 3) {
        t2 = p1.array;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        t2 = t2[t1];
        t3 = plane.dist;
        if (typeof t3 !== "number")
          return H.iae(t3);
        t10 = t2 - t3;
        t2 = p2.array;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        t2 = t2[t1] - t3;
        t3 = tw.extents.array;
        if (t1 >= t3.length)
          return H.ioore(t3, t1);
        offset = t3[t1];
        t1 = t10;
      } else {
        t1 = plane.normal.dot$1(p1);
        t2 = plane.dist;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1 -= t2;
        t2 = plane.normal.dot$1(p2);
        t3 = plane.dist;
        if (typeof t3 !== "number")
          return H.iae(t3);
        t2 -= t3;
        offset = tw.isPoint === true ? 0 : 2048;
      }
      t3 = offset + 1;
      if (t1 >= t3 && t2 >= t3) {
        t1 = node.children;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.traceThroughTree$6(tw, t1[0], p1f, p2f, p1, p2);
        return;
      } else {
        t3 = -offset - 1;
        if (t1 < t3 && t2 < t3) {
          t1 = node.children;
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          this.traceThroughTree$6(tw, t1[1], p1f, p2f, p1, p2);
          return;
        }
      }
      if (t1 < t2) {
        idist = 1 / (t1 - t2);
        frac2 = (t1 + offset + 0.125) * idist;
        frac = (t1 - offset + 0.125) * idist;
        side = 1;
      } else {
        if (t1 > t2) {
          idist = 1 / (t1 - t2);
          frac2 = (t1 - offset - 0.125) * idist;
          frac = (t1 + offset + 0.125) * idist;
        } else {
          frac = 1;
          frac2 = 0;
        }
        side = 0;
      }
      if (frac < 0)
        frac = 0;
      else if (frac > 1)
        frac = 1;
      t1 = p2f - p1f;
      for (t2 = p1.array, t3 = t2.length, t4 = p2.array, t5 = t4.length, t6 = mid.array, t7 = t6.length, i = 0; i < 3; ++i) {
        if (i >= t3)
          return H.ioore(t2, i);
        t8 = t2[i];
        if (i >= t5)
          return H.ioore(t4, i);
        t9 = t4[i];
        if (i >= t7)
          return H.ioore(t6, i);
        t6[i] = t8 + frac * (t9 - t8);
      }
      t2 = node.children;
      if (side >= t2.length)
        return H.ioore(t2, side);
      this.traceThroughTree$6(tw, t2[side], p1f, p1f + t1 * frac, p1, mid);
      if (frac2 < 0)
        frac2 = 0;
      else if (frac2 > 1)
        frac2 = 1;
      for (t2 = p1.array, t3 = t2.length, t4 = p2.array, t5 = t4.length, t6 = mid.array, t7 = t6.length, i = 0; i < 3; ++i) {
        if (i >= t3)
          return H.ioore(t2, i);
        t8 = t2[i];
        if (i >= t5)
          return H.ioore(t4, i);
        t9 = t4[i];
        if (i >= t7)
          return H.ioore(t6, i);
        t6[i] = t8 + frac2 * (t9 - t8);
      }
      t2 = node.children;
      t3 = side === 0 ? 1 : 0;
      if (t3 >= t2.length)
        return H.ioore(t2, t3);
      this.traceThroughTree$6(tw, t2[t3], p1f + t1 * frac2, p2f, mid, p2);
    },
    traceThroughBrush$2: function(tw, brush) {
      var t1, t2, t3, t4, clipplane, enterFrac, leaveFrac, startout, getout, f, leadside, i, t5, t6, side, plane, dist, d1, d2, f0, t7;
      for (t1 = this.cm, t2 = tw.offsets, t3 = tw.start, t4 = tw.end, clipplane = null, enterFrac = -1, leaveFrac = 1, startout = false, getout = false, f = null, leadside = null, i = 0; i < brush.numSides; ++i) {
        t5 = t1.brushSides;
        t6 = brush.firstSide + i;
        if (t6 < 0 || t6 >= t5.length)
          return H.ioore(t5, t6);
        side = t5[t6];
        t6 = t1.planes;
        t5 = side.planeNum;
        if (t5 < 0 || t5 >= t6.length)
          return H.ioore(t6, t5);
        plane = t6[t5];
        t5 = plane.dist;
        t6 = plane.signbits;
        if (t6 >>> 0 !== t6 || t6 >= t2.length)
          return H.ioore(t2, t6);
        dist = J.$sub$n(t5, t2[t6].dot$1(plane.normal));
        t6 = t3.dot$1(plane.normal);
        if (typeof dist !== "number")
          return H.iae(dist);
        d1 = t6 - dist;
        d2 = t4.dot$1(plane.normal) - dist;
        if (d2 > 0)
          getout = true;
        t5 = d1 > 0;
        if (t5)
          startout = true;
        if (t5)
          t5 = d2 >= 0.125 || d2 >= d1;
        else
          t5 = false;
        if (t5)
          return;
        if (d1 <= 0 && d2 <= 0)
          continue;
        t5 = d1 - d2;
        if (d1 > d2) {
          f0 = (d1 - 0.125) / t5;
          if (f0 < 0)
            f0 = 0;
          if (f0 > enterFrac) {
            leadside = side;
            enterFrac = f0;
            clipplane = plane;
          }
        } else {
          f = (d1 + 0.125) / t5;
          if (f > 1)
            f = 1;
          if (f < leaveFrac)
            leaveFrac = f;
        }
      }
      if (!startout) {
        t2 = tw.trace;
        t2.startSolid = true;
        if (!getout) {
          t2.allSolid = true;
          t2.fraction = 0;
          t1 = t1.shaders;
          t3 = brush.shaderNum;
          if (t3 < 0 || t3 >= t1.length)
            return H.ioore(t1, t3);
          t2.contents = t1[t3].contentFlags;
        }
        return;
      }
      if (enterFrac < leaveFrac) {
        if (enterFrac > -1) {
          t2 = tw.trace.fraction;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = enterFrac < t2;
        } else
          t2 = false;
        if (t2) {
          if (enterFrac < 0)
            enterFrac = 0;
          t2 = tw.trace;
          t2.fraction = enterFrac;
          t3 = t2.plane;
          t4 = t3.normal;
          t5 = clipplane.normal;
          t6 = t4.array;
          t7 = t5.$index(0, 0);
          if (0 >= t6.length)
            return H.ioore(t6, 0);
          t6[0] = t7;
          t7 = t4.array;
          t6 = t5.$index(0, 1);
          if (1 >= t7.length)
            return H.ioore(t7, 1);
          t7[1] = t6;
          t4 = t4.array;
          t5 = t5.$index(0, 2);
          if (2 >= t4.length)
            return H.ioore(t4, 2);
          t4[2] = t5;
          t3.dist = clipplane.dist;
          t3.type = clipplane.type;
          t3.signbits = clipplane.signbits;
          t1 = t1.shaders;
          t3 = leadside.shaderNum;
          t5 = t1.length;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t1, t3);
          t2.surfaceFlags = t1[t3].surfaceFlags;
          t3 = brush.shaderNum;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t1, t3);
          t2.contents = t1[t3].contentFlags;
        }
      }
    },
    BSPTree$1: function(cm) {
      var t1, t2, surface, t3, t4, width, height, points, patch;
      for (t1 = this.cm, t2 = t1.surfacesUntessellated, t2 = new H.ListIterator(t2, t2.length, 0, null); t2.moveNext$0();) {
        surface = t2.__internal$_current;
        if (surface.get$surfaceType() !== $.Surface_patch)
          continue;
        t3 = surface.patch_size;
        t4 = t3.length;
        if (0 >= t4)
          return H.ioore(t3, 0);
        width = t3[0];
        if (1 >= t4)
          return H.ioore(t3, 1);
        height = t3[1];
        points = P.List_List$generate(width * height, new X.BSPTree_closure(this, surface), true, Q.Vector);
        t3 = t1.shaders;
        t4 = surface.shaderNum;
        if (t4 >= t3.length)
          return H.ioore(t3, t4);
        t4 = t3[t4];
        patch = new B.Patch(null, null, null, null);
        patch.contents = t4.contentFlags;
        patch.surfaceFlags = t4.surfaceFlags;
        patch.pc = B.generatePatchCollide(width, height, points);
        surface.patchRef = patch;
      }
    },
    static: {BSPTree$: function(cm) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
        t1 = Q.Vector$(0, 0, 0);
        t2 = Q.Vector$(0, 0, 0);
        t3 = B.vectorList(2);
        t4 = B.vectorList(8);
        t5 = Q.Vector$(0, 0, 0);
        t6 = B.vectorList(2);
        t7 = Q.Vector$(0, 0, 0);
        t8 = Q.Vector$(0, 0, 0);
        t9 = B.Plane$(null, null);
        t10 = Array(4);
        t10.fixed$length = init;
        t10 = H.setRuntimeTypeInfo(t10, [P.$double]);
        t11 = Array(4);
        t11.fixed$length = init;
        t11 = new X.BSPTree(cm, new X.TraceWork(t1, t2, t3, t4, null, t5, t6, t7, null, null, new X.Trace(false, false, 1, t8, t9, null, null, null)), t10, H.setRuntimeTypeInfo(t11, [P.$double]), Q.Vector$(0, 0, 0), Q.Vector$(0, 0, 0), new X.WrapHit(null, null, null));
        t11.BSPTree$1(cm);
        return t11;
      }}
  },
  BSPTree_closure: {
    "^": "Closure:8;this_0,surface_1",
    call$1: function(idx) {
      var t1, t2;
      t1 = this.this_0.cm.drawVerts;
      t2 = this.surface_1.firstVert + idx;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return Q.Vector$fromList(t1[t2].xyz);
    }
  }
},
1],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
;(function() {
  var TRUE = !0, _;
  _ = P.$int;
  _.$is$int = TRUE;
  _.$isnum = TRUE;
  _.$isObject = TRUE;
  _ = P.$double;
  _.$is$double = TRUE;
  _.$isnum = TRUE;
  _.$isObject = TRUE;
  _ = W.Node0;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  W._CSSValue.$isObject = TRUE;
  W.StyleSheet.$isObject = TRUE;
  W.SpeechRecognitionResult.$isObject = TRUE;
  W.Gamepad.$isObject = TRUE;
  W.CssRule.$isObject = TRUE;
  P.Rectangle.$isObject = TRUE;
  W.Touch.$isObject = TRUE;
  W.TextTrack.$isObject = TRUE;
  W.TextTrackCue.$isObject = TRUE;
  _ = P.String;
  _.$isString = TRUE;
  _.$isObject = TRUE;
  W.SpeechGrammar.$isObject = TRUE;
  W.SourceBuffer.$isObject = TRUE;
  W.Plugin.$isObject = TRUE;
  W.MimeType.$isObject = TRUE;
  W.File.$isObject = TRUE;
  W.Entry.$isObject = TRUE;
  P.Transform.$isObject = TRUE;
  P.PathSeg.$isObject = TRUE;
  P.Number.$isObject = TRUE;
  P.Length.$isObject = TRUE;
  P.Map.$isObject = TRUE;
  _ = P.num;
  _.$isnum = TRUE;
  _.$isObject = TRUE;
  _ = P.Duration;
  _.$isDuration = TRUE;
  _.$isObject = TRUE;
  _ = P.AudioBuffer;
  _.$isAudioBuffer = TRUE;
  _.$isObject = TRUE;
  _ = Q.Vector;
  _.$isVector = TRUE;
  _.$isObject = TRUE;
  _ = P.bool;
  _.$isbool = TRUE;
  _.$isObject = TRUE;
  _ = B.Node;
  _.$isNode = TRUE;
  _.$isSpatial = TRUE;
  _.$isObject = TRUE;
  B.PatchPlane.$isObject = TRUE;
  B.Facet.$isObject = TRUE;
  _ = P.List;
  _.$isList = TRUE;
  _.$isObject = TRUE;
  B.Surface.$isObject = TRUE;
  B.Model.$isObject = TRUE;
  B.Brushside.$isObject = TRUE;
  B.Brush.$isObject = TRUE;
  B.Leaf.$isObject = TRUE;
  B.Plane.$isObject = TRUE;
  B.BSPNode.$isObject = TRUE;
  B.Vertex.$isObject = TRUE;
  B.Shader.$isObject = TRUE;
  B.ShaderProgram.$isObject = TRUE;
  B.Animatable.$isObject = TRUE;
  _ = B.TextureWrapper;
  _.$isTextureWrapper = TRUE;
  _.$isObject = TRUE;
  _ = P.Future;
  _.$isFuture = TRUE;
  _.$isObject = TRUE;
  W.Event.$isObject = TRUE;
  H.RawReceivePortImpl.$isObject = TRUE;
  H._IsolateEvent.$isObject = TRUE;
  H._IsolateContext.$isObject = TRUE;
  _ = P.Symbol;
  _.$isSymbol = TRUE;
  _.$isObject = TRUE;
  _ = P.StackTrace;
  _.$isStackTrace = TRUE;
  _.$isObject = TRUE;
  _ = P.ByteBuffer;
  _.$isByteBuffer = TRUE;
  _.$isObject = TRUE;
  _ = W.MouseEvent;
  _.$isMouseEvent = TRUE;
  _.$isObject = TRUE;
  _ = W.KeyboardEvent;
  _.$isKeyboardEvent = TRUE;
  _.$isObject = TRUE;
  P.Object.$isObject = TRUE;
  _ = P.AsyncError;
  _.$isAsyncError = TRUE;
  _.$isObject = TRUE;
  _ = P._EventSink;
  _.$is_EventSink = TRUE;
  _.$isObject = TRUE;
  _ = P._DelayedEvent;
  _.$is_DelayedEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.DateTime;
  _.$isDateTime = TRUE;
  _.$isObject = TRUE;
  _ = P.StreamSubscription;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = X.Trace;
  _.$isTrace = TRUE;
  _.$isObject = TRUE;
  _ = W.Element;
  _.$isElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = W.HtmlElement;
  _.$isHtmlElement = TRUE;
  _.$isElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = B.Spatial;
  _.$isSpatial = TRUE;
  _.$isObject = TRUE;
  _ = W.RtcStatsReport;
  _.$isRtcStatsReport = TRUE;
  _.$isObject = TRUE;
  _ = W.FontFace;
  _.$isFontFace = TRUE;
  _.$isObject = TRUE;
  _ = W.DataTransferItem;
  _.$isDataTransferItem = TRUE;
  _.$isObject = TRUE;
  _ = P.Function;
  _.$isFunction = TRUE;
  _.$isObject = TRUE;
})();
;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$ge$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver >= a0;
  return J.getInterceptor$n(receiver).$ge(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$indexSet$ax = function(receiver, a0, a1) {
  if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
};
J.$le$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver <= a0;
  return J.getInterceptor$n(receiver).$le(receiver, a0);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$negate$n = function(receiver) {
  if (typeof receiver == "number")
    return -receiver;
  return J.getInterceptor$n(receiver).$negate(receiver);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.abs$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).abs$0(receiver);
};
J.activeTexture$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).activeTexture$1(receiver, a0);
};
J.addEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
};
J.animate$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).animate$1(receiver, a0);
};
J.asByteData$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).asByteData$2(receiver, a0, a1);
};
J.asInt32List$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).asInt32List$2(receiver, a0, a1);
};
J.attachShader$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).attachShader$2(receiver, a0, a1);
};
J.bindBuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindBuffer$2(receiver, a0, a1);
};
J.bindFramebuffer$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindFramebuffer$2(receiver, a0, a1);
};
J.bindTexture$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).bindTexture$2(receiver, a0, a1);
};
J.blendFunc$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).blendFunc$2(receiver, a0, a1);
};
J.bufferDataTyped$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).bufferDataTyped$3(receiver, a0, a1, a2);
};
J.checkFramebufferStatus$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).checkFramebufferStatus$1(receiver, a0);
};
J.clear$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).clear$1(receiver, a0);
};
J.clearColor$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).clearColor$4(receiver, a0, a1, a2, a3);
};
J.compileShader$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).compileShader$1(receiver, a0);
};
J.contains$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
};
J.createBuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createBuffer$0(receiver);
};
J.createFramebuffer$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createFramebuffer$0(receiver);
};
J.createGain$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createGain$0(receiver);
};
J.createProgram$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createProgram$0(receiver);
};
J.createShader$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).createShader$1(receiver, a0);
};
J.createTexture$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).createTexture$0(receiver);
};
J.decodeAudioData$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).decodeAudioData$1(receiver, a0);
};
J.disable$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).disable$1(receiver, a0);
};
J.disableVertexAttribArray$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).disableVertexAttribArray$1(receiver, a0);
};
J.drawArrays$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).drawArrays$3(receiver, a0, a1, a2);
};
J.drawElements$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).drawElements$4(receiver, a0, a1, a2, a3);
};
J.enable$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).enable$1(receiver, a0);
};
J.enableVertexAttribArray$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).enableVertexAttribArray$1(receiver, a0);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.framebufferTexture2D$5$x = function(receiver, a0, a1, a2, a3, a4) {
  return J.getInterceptor$x(receiver).framebufferTexture2D$5(receiver, a0, a1, a2, a3, a4);
};
J.get$_key$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$_key(receiver);
};
J.get$enabled$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$enabled(receiver);
};
J.get$error$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$error(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$height$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$height(receiver);
};
J.get$isNaN$n = function(receiver) {
  return J.getInterceptor$n(receiver).get$isNaN(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$keyCode$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$keyCode(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$loaded$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$loaded(receiver);
};
J.get$onDragStart$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onDragStart(receiver);
};
J.get$onLoad$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onLoad(receiver);
};
J.get$width$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$width(receiver);
};
J.getAttribLocation$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getAttribLocation$2(receiver, a0, a1);
};
J.getContext$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getContext$1(receiver, a0);
};
J.getExtension$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getExtension$1(receiver, a0);
};
J.getProgramInfoLog$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getProgramInfoLog$1(receiver, a0);
};
J.getProgramParameter$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getProgramParameter$2(receiver, a0, a1);
};
J.getShaderInfoLog$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getShaderInfoLog$1(receiver, a0);
};
J.getShaderParameter$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getShaderParameter$2(receiver, a0, a1);
};
J.getUniformLocation$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).getUniformLocation$2(receiver, a0, a1);
};
J.linkProgram$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).linkProgram$1(receiver, a0);
};
J.pixelStorei$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).pixelStorei$2(receiver, a0, a1);
};
J.preventDefault$0$x = function(receiver) {
  return J.getInterceptor$x(receiver).preventDefault$0(receiver);
};
J.remove$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
};
J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
};
J.scale$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).scale$1(receiver, a0);
};
J.send$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).send$1(receiver, a0);
};
J.set$fillStyle$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$fillStyle(receiver, value);
};
J.set$height$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$height(receiver, value);
};
J.set$src$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$src(receiver, value);
};
J.set$width$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$width(receiver, value);
};
J.shaderSource$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).shaderSource$2(receiver, a0, a1);
};
J.texImage2DCanvas$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).texImage2DCanvas$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.texImage2DImage$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).texImage2DImage$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.texImage2DTyped$9$x = function(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8) {
  return J.getInterceptor$x(receiver).texImage2DTyped$9(receiver, a0, a1, a2, a3, a4, a5, a6, a7, a8);
};
J.texParameteri$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).texParameteri$3(receiver, a0, a1, a2);
};
J.toList$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toList$0(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.uniform1f$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform1f$2(receiver, a0, a1);
};
J.uniform1i$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).uniform1i$2(receiver, a0, a1);
};
J.uniform2f$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).uniform2f$3(receiver, a0, a1, a2);
};
J.uniformMatrix4fv$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).uniformMatrix4fv$3(receiver, a0, a1, a2);
};
J.useProgram$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).useProgram$1(receiver, a0);
};
J.vertexAttribPointer$6$x = function(receiver, a0, a1, a2, a3, a4, a5) {
  return J.getInterceptor$x(receiver).vertexAttribPointer$6(receiver, a0, a1, a2, a3, a4, a5);
};
J.viewport$4$x = function(receiver, a0, a1, a2, a3) {
  return J.getInterceptor$x(receiver).viewport$4(receiver, a0, a1, a2, a3);
};
J.write$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).write$1(receiver, a0);
};
Isolate.makeConstantList = function(list) {
  list.immutable$list = Array;
  list.fixed$length = Array;
  return list;
};
;
C.HttpRequest_methods = W.HttpRequest.prototype;
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.NativeFloat32List_methods = H.NativeFloat32List.prototype;
C.NativeUint8List_methods = H.NativeUint8List.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.Window_methods = W.Window.prototype;
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C__RootZone = new P._RootZone();
C.Duration_0 = new P.Duration(0);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_oRe = function() {
  function typeNameInChrome(o) {
    var name = o.constructor.name;
    if (name) return name;
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.List_empty = Isolate.makeConstantList([]);
init.isHunkLoaded = function(hunkHash) {
  return !!$dart_deferred_initializers[hunkHash];
};
init.initializeLoadedHunk = function(hunkHash) {
  $dart_deferred_initializers[hunkHash](globalsHolder, $);
};
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.totalPatchBlocks = 0;
$.numPlanes = null;
$.Surface_patch = 2;
$.ChronosGL_globalGL = null;
$.ChronosGL_useElementIndexUint = false;
$.clientX = 0;
$.clientY = 0;
$.mouseX = 0;
$.mouseY = 0;
$.skipDefaultMouseMoveListener = false;
$.Key_SPACE = 32;
$.Key_A = 65;
$.Key_D = 68;
$.Key_S = 83;
$.Key_W = 87;
$.currentDist = 0;
$.currentSide = 0;
$.Matrix4_RIGHTX = 0;
$.Matrix4_RIGHTY = 4;
$.Matrix4_RIGHTZ = 8;
$.Matrix4_UPX = 1;
$.Matrix4_UPY = 5;
$.Matrix4_UPZ = 9;
$.Matrix4_BACKX = 2;
$.Matrix4_BACKY = 6;
$.Matrix4_BACKZ = 10;
$.Matrix4_POSX = 12;
$.Matrix4_POSY = 13;
$.Matrix4_POSZ = 14;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.Device__isOpera = null;
$.Device__isIE = null;
$.Device__isFirefox = null;
$.Device__isWebKit = null;
$.Device__cachedCssPrefix = null;
$.q3movement_stopspeed = 100;
$.q3movement_jumpvelocity = 50;
$.q3movement_accelerate = 10;
$.q3movement_airaccelerate = 0.1;
$.q3movement_friction = 6;
$.q3movement_frameTime = 0.3;
$.q3movement_overclip = 0.501;
$.STEPSIZE = 18;
$.q3movement_gravity = 20;
$.q3movement_playerRadius = 10;
$.q3movement_scale = 50;
$.chronosGL = null;
$.camera = null;
$.textureCache = null;
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return new P.Expando(null);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "invplane", "invplane", "get$invplane", function() {
  return H.setRuntimeTypeInfo(Array(4), [P.$double]);
});
Isolate.$lazy($, "d1", "d1", "get$d1", function() {
  return Q.Vector$(0, 0, 0);
});
Isolate.$lazy($, "d2", "d2", "get$d2", function() {
  return Q.Vector$(0, 0, 0);
});
Isolate.$lazy($, "planes", "planes", "get$planes", function() {
  return P.List_List$generate(2048, new B.closure1(), true, B.PatchPlane);
});
Isolate.$lazy($, "currentlyPressedKeys", "currentlyPressedKeys", "get$currentlyPressedKeys", function() {
  return P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P.bool);
});
Isolate.$lazy($, "currentlyPressedMouseButtons", "currentlyPressedMouseButtons", "get$currentlyPressedMouseButtons", function() {
  return P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.bool);
});
Isolate.$lazy($, "currentHit", "currentHit", "get$currentHit", function() {
  return Q.Vector$(0, 0, 0);
});
Isolate.$lazy($, "temp", "temp", "get$temp", function() {
  return Q.Vector$(0, 0, 0);
});
Isolate.$lazy($, "scheduleImmediateClosure", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
});
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});
Isolate.$lazy($, "snd", "snd", "get$snd", function() {
  var t1 = new E.ChronosAL(null, null, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.AudioBuffer));
  t1.ChronosAL$1(0.25);
  return t1;
});
Isolate.$lazy($, "ORIGIN", "ORIGIN", "get$ORIGIN", function() {
  return Q.Vector$(0, 0, 0);
});

// Native classes

init.metadata = [{func: "void__void_", void: true, args: [{func: "void_", void: true}]},
{func: "void_", void: true},
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
{func: "args0"},
{func: "args2", args: [null, null]},
{func: "args1", args: [null]},
{func: "dynamic__dynamic_String", args: [null, P.String]},
{func: "dynamic__String", args: [P.String]},
{func: "dynamic__int", args: [P.$int]},
{func: "dynamic__AudioBuffer", args: [P.AudioBuffer]},
{func: "void___double", void: true, opt: [P.$double]},
,
{func: "dynamic__MouseEvent", args: [W.MouseEvent]},
{func: "dynamic__KeyboardEvent", args: [W.KeyboardEvent]},
{func: "dynamic__List", args: [P.List]},
{func: "double_", ret: P.$double},
{func: "dynamic__void_", args: [{func: "void_", void: true}]},
{func: "dynamic__Object", args: [P.Object]},
{func: "void__dynamic__StackTrace", void: true, args: [null], opt: [P.StackTrace]},
{func: "dynamic__dynamic__dynamic", args: [null], opt: [null]},
{func: "bool_", ret: P.bool},
{func: "dynamic__dynamic_StackTrace", args: [null, P.StackTrace]},
{func: "dynamic__Symbol_dynamic", args: [P.Symbol, null]},
{func: "String__int", ret: P.String, args: [P.$int]},
{func: "dynamic__int_dynamic", args: [P.$int, null]},
{func: "dynamic__ByteBuffer", args: [P.ByteBuffer]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties) {
        if (hasOwnProperty.call(properties, member)) {
          object[member] = properties[member];
        }
      }
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = Object.create(null);
    var allClasses = init.allClasses;
    var constructors;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      var desc = collectedClasses[cls];
      if (desc instanceof Array)
        desc = desc[1];
      var classData = desc["^"], supr, name = cls, fields = classData;
      if (typeof classData == "string") {
        var split = classData.split("/");
        if (split.length == 2) {
          name = split[0];
          fields = split[1];
        }
      }
      var s = fields.split(";");
      fields = s[1] == "" ? [] : s[1].split(",");
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          desc.$signature = function(s) {
            return function() {
              return init.metadata[s];
            };
          }(functionSignature);
      }
      if (supr && supr.indexOf("+") > 0) {
        s = supr.split("+");
        supr = s[0];
        var mixin = collectedClasses[s[1]];
        if (mixin instanceof Array)
          mixin = mixin[1];
        for (var d in mixin) {
          if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
            desc[d] = mixin[d];
        }
      }
      if (typeof dart_precompiled != "function") {
        combinedConstructorFunction += defineClass(name, cls, fields);
        constructorsList.push(cls);
      }
      if (supr)
        pendingClasses[cls] = supr;
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
      if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  (function() {
    init.allClasses = Object.create(null);
    init.interceptorsByTag = Object.create(null);
    init.leafTags = Object.create(null);
    init.finishedClasses = Object.create(null);
  })();
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      var lazies = init.lazies;
      for (var lazyInit in lazies) {
        this[lazies[lazyInit]] = null;
      }
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var lazyInit in lazies) {
        var lazyInitName = lazies[lazyInit];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
}();
init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(function(a) {
      H.startRootIsolate(X.main$closure(), a);
    }, []);
  } else {
    (function(a) {
      H.startRootIsolate(X.main$closure(), a);
    })([]);
  }
});
;
// END invoke [main].
})()

//# sourceMappingURL=instagib.dart.js.map
